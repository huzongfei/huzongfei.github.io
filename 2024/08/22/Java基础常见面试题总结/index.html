<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java常见面试题总结 | 草莓熊的秘密基地</title><meta name="author" content="hzf"><meta name="copyright" content="hzf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="上1. Java SE vs Java EE Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。 Java EE（Java Platform, Enterprise Edition">
<meta property="og:type" content="article">
<meta property="og:title" content="java常见面试题总结">
<meta property="og:url" content="https://huzongfei.github.io/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="草莓熊的秘密基地">
<meta property="og:description" content="上1. Java SE vs Java EE Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。 Java EE（Java Platform, Enterprise Edition">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-08-22T06:18:03.190Z">
<meta property="article:modified_time" content="2024-08-22T11:34:06.807Z">
<meta property="article:author" content="hzf">
<meta property="article:tag" content="积少成多">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huzongfei.github.io/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java常见面试题总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-22 19:34:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="草莓熊的秘密基地"><span class="site-name">草莓熊的秘密基地</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java常见面试题总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-22T06:18:03.190Z" title="发表于 2024-08-22 14:18:03">2024-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-22T11:34:06.807Z" title="更新于 2024-08-22 19:34:06">2024-08-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java常见面试题总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="上"><a href="#上" class="headerlink" title="上"></a>上</h1><h3 id="1-Java-SE-vs-Java-EE"><a href="#1-Java-SE-vs-Java-EE" class="headerlink" title="1. Java SE vs Java EE"></a>1. Java SE vs Java EE</h3><ul>
<li>Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。</li>
<li>Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。</li>
</ul>
<h3 id="2-JVM-vs-JDK-vs-JRE"><a href="#2-JVM-vs-JDK-vs-JRE" class="headerlink" title="2.JVM vs JDK vs JRE"></a>2.JVM vs JDK vs JRE</h3><h5 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm">JVM</a></h5><p><strong>Java 虚拟机（Java Virtual Machine）是运行 Java 字节码的虚拟机</strong>。</p>
<p><strong>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</strong></p>
<p>字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>


<p><strong>JVM不是只有一种</strong> HotSpot VM,  J9 VM</p>
<h5 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h5><p><strong>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件</strong>。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p>
<p><strong>JRE（Java Runtime Environment） 是 Java 运行时环境。</strong>它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20240822193317355.png" class="" title="image-20240822193317355">

<h3 id="3-什么是字节码-采用字节码的好处是什么"><a href="#3-什么是字节码-采用字节码的好处是什么" class="headerlink" title="3. 什么是字节码?采用字节码的好处是什么?"></a>3. 什么是字节码?采用字节码的好处是什么?</h3><p>在 Java 中，<strong>JVM 可以理解的代码就叫做字节码</strong>（即扩展名为 <code>.class</code> 的文件），<strong>它不面向任何特定的处理器，只面向虚拟机</strong>。</p>
<p>Java 语言通过字节码的方式，在一定程度上<strong>解决了传统解释型语言执行效率低的问题</strong>，同时又保留了解释型语言可移植的特点。</p>
<p>所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，<strong>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</strong></p>
<p><strong>Java程序从源代码到运行的过程如下图所示</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程"></p>
<p>javac编译过程：<strong>词法分析 :arrow_right: 语法分析 :arrow_right: 语义分析 :arrow_right: 中间代码生成 :arrow_right: 优化 :arrow_right: 目标代码生成 :arrow_right: 链接</strong></p>
<p>词法分析（Lexical Analysis）：编译器读取源代码，<strong>将代码分解成一系列的符号单元，这些单元被称为“令牌”（tokens）</strong>。词法分析器<strong>识别并提取代码中的关键字、标识符、操作符、常量等。</strong></p>
<p>语法分析（Lexical Analysis）：编译器使用词法分析器产生的令牌<strong>构建抽象语法树（Abstract Syntax Tree, AST）</strong>。<strong>语法分析器检查代码的语法结构是否正确，确保代码符合 Java 的语法规则。</strong></p>
<p>语义分析（Semantic Analysis）：编译器对 AST 进行语义分析，确保代码的语义正确性。包括<strong>类型检查、作用域检查、方法重载检查、异常处理分析等</strong>。</p>
<p>中间代码生成（Intermediate Code Generation）：编译器将 AST 转换为中间代码，<strong>中间代码是接近机器码的代码，但更易于进行后续的优化。</strong></p>
<p>优化（Optimization）：<strong>编译器对中间代码进行优化，以提高程序的执行效率</strong>。优化包括<strong>常量折叠、循环展开、代码简化</strong>等。</p>
<p>目标代码生成（Target Code Generation）：编译器将优化后的中间代码转换为目标代码，目标代码是特定于目标平台的机器码。</p>
<p>链接（Linking）：如果有多个源文件或库，编译器将它们链接在一起，生成可执行文件或共享库。<strong>链接器负责解决符号引用、合并代码和数据、生成最终的可执行文件。</strong></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 <strong>JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢</strong>。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，<strong>而 JIT 属于运行时编译。</strong>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160348016.png" alt="image-20240423160348016"></p>
<p><strong>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png" alt="JDK、JRE、JVM、JIT 这四者的关系"></p>
<h3 id="4-为什么说-Java-语言“编译与解释并存”？"><a href="#4-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="4. 为什么说 Java 语言“编译与解释并存”？"></a>4. 为什么说 Java 语言“编译与解释并存”？</h3><p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><p><strong>编译型</strong>：<strong>编译型语言会通过[编译器]将源代码一次性翻译成可被该平台执行的机器码</strong>。</p>
<p>一般情况下，<strong>编译语言的执行速度比较快，开发效率比较低。</strong>常见的编译性语言有 C、C++、Go、Rust 等等。</p>
</li>
<li><p><strong>解释型</strong>：**[解释型语言]会通过[解释器]一句一句的将代码解释（interpret）为机器代码后再执行。**</p>
<p><strong>解释型语言开发效率比较快，执行速度比较慢</strong>。常见的解释性语言有 Python、JavaScript、PHP 等等。</p>
</li>
</ul>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160648790.png" alt="image-20240423160648790"></p>
<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>
<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。<strong>因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</strong></p>
<h3 id="5-AOT-有什么优点？为什么不全部使用-AOT-呢？"><a href="#5-AOT-有什么优点？为什么不全部使用-AOT-呢？" class="headerlink" title="5. AOT 有什么优点？为什么不全部使用 AOT 呢？"></a>5. AOT 有什么优点？为什么不全部使用 AOT 呢？</h3><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，<strong>这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译</strong>（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160325214.png" alt="image-20240423160325214"><br>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>
<p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p>
<p>我们前面也对比过 JIT 与 AOT，两者各有优点，<strong>只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好</strong>。除此之外，<strong>AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等</strong>。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>
<h3 id="6-Java-和-C-的区别"><a href="#6-Java-和-C-的区别" class="headerlink" title="6.  Java 和 C++ 的区别?"></a>6.  Java 和 C++ 的区别?</h3><p><strong>指针，继承，垃圾回收，重载</strong></p>
<p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p>
<ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全。:ledger: Java不提供指针来直接访问内存</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多实现（类似实现多继承功能）。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，<strong>但是 Java 只支持方法重载</strong>（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
</ul>
<h3 id="7-continue、break-和-return-的区别是什么？"><a href="#7-continue、break-和-return-的区别是什么？" class="headerlink" title="7. continue、break 和 return 的区别是什么？"></a>7. continue、break 和 return 的区别是什么？</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。<strong>但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</strong></p>
<ol>
<li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li>
<li><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：<ol>
<li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li>
</ol>
</li>
</ol>
<h3 id="8-Java-中的几种基本数据类型了解么？"><a href="#8-Java-中的几种基本数据类型了解么？" class="headerlink" title="8. Java 中的几种基本数据类型了解么？"></a>8. Java 中的几种基本数据类型了解么？</h3><p>8中基本类型：<strong>byte,short,int,long,char,float,double,boolean</strong></p>
<p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li><p>6 种数字类型： </p>
<ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li><p>1 种字符类型：<code>char</code></p>
</li>
<li><p>1 种布尔型：<code>boolean</code>。</p>
</li>
<li><table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 - 127</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-2^15 - 2^15 -2</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2^31 - 2^31-1</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>8</td>
<td>0</td>
<td>-2^63 - 2^63-1</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>2</td>
<td>‘uooo’</td>
<td>0 - 65535(2^16-1)</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td></td>
<td>false</td>
<td>true、false</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="9-基本类型和包装类型的区别？"><a href="#9-基本类型和包装类型的区别？" class="headerlink" title="9. 基本类型和包装类型的区别？"></a>9. 基本类型和包装类型的区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p>
<p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</p>
<p><strong>存储方式</strong>：<strong>基本数据类型的局部变量存放在 Java 虚拟机栈中的<font color="blue">局部变量表</font>中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中</strong>。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p>
<p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。— <strong>基本数据类型占空间少</strong></p>
<p><strong>默认值</strong>：成员变量<strong>包装类型不赋值就是 <code>null</code></strong> ，而**基本类型有默认值且不是 <code>null</code>**。</p>
<p><strong>比较方式</strong>：对于<strong>基本数据类型来说，<code>==</code> 比较的是值</strong>。对于<strong>包装数据类型来说，<code>==</code> 比较的是对象的内存地址</strong>。所有<strong>整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</strong></p>
<p><font color="blue"><strong>基本数据类型 — 局部变量:floppy_disk:栈中；成员变量:floppy_disk:堆中</strong></font>     <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是<strong>局部变量，那么它们会存放在栈中</strong>；如果它们是<strong>成员变量，那么它们会存放在堆中</strong>。    </p>
<h3 id="10-包装类型的缓存机制了解么？"><a href="#10-包装类型的缓存机制了解么？" class="headerlink" title="10. 包装类型的缓存机制了解么？"></a>10. 包装类型的缓存机制了解么？</h3><p>Java 基本数据类型的包装类型的大部分都<strong>用到了缓存机制来提升性能</strong>。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> <strong>这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据</strong>，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171140098.png" alt="image-20240423171140098"></p>
<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240729152818821.png" alt="image-20240729152818821"></p>
<h3 id="11-自动装箱与拆箱了解吗？原理是什么？"><a href="#11-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="11. 自动装箱与拆箱了解吗？原理是什么？"></a>11. 自动装箱与拆箱了解吗？原理是什么？</h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>原理：我们发现<strong>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法</strong>。<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h3 id="12-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#12-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="12. 为什么浮点数运算的时候会有精度丢失的风险？"></a>12. 为什么浮点数运算的时候会有精度丢失的风险？</h3><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171825236.png" alt="image-20240423171825236"></p>
<p>为什么会出现这个问题呢？</p>
<p>这个和计算机保存浮点数的机制有很大关系。<strong>我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</strong>这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<h3 id="13-如何解决浮点数运算的精度丢失问题？"><a href="#13-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="13.如何解决浮点数运算的精度丢失问题？"></a>13.如何解决浮点数运算的精度丢失问题？</h3><p>在java.math包下的BigDecimal类可以解决这个问题</p>
<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171924882.png" alt="image-20240423171924882"></p>
<h3 id="14-成员变量与局部变量的区别？"><a href="#14-成员变量与局部变量的区别？" class="headerlink" title="14. 成员变量与局部变量的区别？"></a>14. 成员变量与局部变量的区别？</h3><p><strong>语法形式</strong>：从语法形式上看，<strong>成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数</strong>；</p>
<p><strong>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰****；但是，</strong>成员变量和局部变量都能被 <code>final</code> 所修饰。**</p>
<p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，<strong>局部变量则存在于栈内存</strong>。</p>
<p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p>
<p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
<h3 id="15-字符型常量和字符串常量的区别"><a href="#15-字符型常量和字符串常量的区别" class="headerlink" title="15. 字符型常量和字符串常量的区别?"></a>15. 字符型常量和字符串常量的区别?</h3><p><strong>形式</strong> : <strong>字符常量是<code>单引号</code>引起的一个字符</strong>，<strong>字符串常量</strong>是**<code>双引号</code>**引起的 0 个或若干个字符。</p>
<p><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p>
<p><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
<p>字符型常量和字符串常量代码示例：</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423173544912.png" alt="image-20240423173544912"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423173552505.png" alt="image-20240423173552505"></p>
<h3 id="16-重载和重写有什么区别？"><a href="#16-重载和重写有什么区别？" class="headerlink" title="16. 重载和重写有什么区别？"></a>16. 重载和重写有什么区别？</h3><p><strong>重载</strong>就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p><strong>重写</strong>就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），<strong>方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同</strong>。</p>
<p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li><strong>构造方法无法被重写</strong></li>
</ol>
<p><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201407572.png" alt="image-20240423201407572"></p>
<p>方法的<strong>重写</strong>要遵循“<strong>两同两小一大</strong>”</p>
<p><strong>“两同”即方法名相同、形参列表相同；</strong></p>
<p>“两小”指的是<strong>子类方法返回值类型应比父类方法返回值类型更小或相等</strong>，子类方法声明<strong>抛出的异常类应比父类方法声明抛出的异常类更小或相等；</strong></p>
<p>“一大”指的是<strong>子类方法的访问权限应比父类方法的访问权限更大或相等。</strong></p>
<p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h3 id="17-什么是可变长参数？"><a href="#17-什么是可变长参数？" class="headerlink" title="17. 什么是可变长参数？"></a>17. 什么是可变长参数？</h3><p>从 Java5 开始，Java 支持定义可变长参数，所谓<strong>可变长参数就是允许在调用方法时传入不定长度的参数</strong>。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201852094.png" alt="image-20240423201852094"></p>
<p>另外，<strong>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201911042.png" alt="image-20240423201911042"></p>
<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p><strong>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</strong></p>
<p>我们通过下面这个例子来证明一下。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201942808.png" alt="image-20240423201942808"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201958820.png" alt="image-20240423201958820"></p>
<p>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423202027492.png" alt="image-20240423202027492"></p>
<h3 id="HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？"><a href="#HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？" class="headerlink" title="HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？"></a>HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</h3><h5 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h5><p><strong>数组+链表</strong>：HashMap 内部有一个数组，数组的每个元素是一个链表的头节点。当我们往HashMap中插入一个键值对时，会根据key的hashCode()方法计算出该键值对在数组中的位置，如果该位置上没有元素，就直接放在那里；如果有，则以链表形式存放，即在对应的链表节点上添加一个新节点。</p>
<p><strong>扩容：</strong> 当HashMap中的元素数量达到一定的阈值（容量*加载因子，默认加载因子是0.75），就会进行扩容操作，新的容量是旧容量的两倍，并且重新计算每个键值对的位置。</p>
<p><strong>resize()：</strong> 扩容操作会创建一个新的数组，并将旧数组中的所有元素重新插入到新数组中。</p>
<h5 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a>ConcurrentHashMap 的实现原理</h5><p>ConcurrentHashMap 的实现原理与HashMap类似，但是它是线程安全的，可以在多线程环境下使用。</p>
<p><strong>数组 + 链表 + 红黑树：</strong> ConcurrentHashMap 也是基于数组和链表来实现，但是为了减少哈希碰撞造成的性能影响，<strong>当链表的长度超过一定阈值（默认为8）时，链表会被转换为平衡树（红黑树）一般是8</strong>，这样即使在最坏的情况下查找的时间复杂度也可以从<code>O(n)</code>降低到<code>O(log n)</code>。</p>
<p><strong>如何保证线程安全</strong></p>
<ul>
<li><strong>分段锁：</strong> ConcurrentHashMap 采用分段锁技术来保证线程安全。<strong>它将数据分为若干段（Segment），每段独立锁，不同的线程可以并行地访问不同的段。对于大多数操作，只需要锁定一个段即可。</strong>这种设计减少了锁竞争，提高了并发性能。</li>
<li><strong>原子操作：</strong> ConcurrentHashMap<strong>通过原子操作来处理数据的插入、删除和修改，</strong>例如使用CAS(Compare And Swap)操作来保证更新操作的原子性。</li>
<li><strong>volatile和final：</strong> ConcurrentHashMap 中的<strong>变量基本都声明为volatile或final</strong>，以保证内存可见性和防止指令重排。</li>
<li><strong>失败-快速恢复机制：</strong> 在并发场景下，ConcurrentHashMap通过特征的失败-快速恢复算法来处理并发冲突，尽可能地减少系统地停顿时间</li>
</ul>
<h1 id="中"><a href="#中" class="headerlink" title="中"></a>中</h1><h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="2-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#2-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="2. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>2. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（<strong>对象实例在堆内存中</strong>），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li>
<li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>
</ul>
<h3 id="3-对象的相等和引用相等的区别"><a href="#3-对象的相等和引用相等的区别" class="headerlink" title="3. 对象的相等和引用相等的区别"></a>3. 对象的相等和引用相等的区别</h3><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203459479.png" alt="image-20240423203459479"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203520925.png" alt="image-20240423203520925"></p>
<h3 id="4-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#4-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="4. 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>4. 如果一个类没有声明构造方法，该程序能正确执行吗?</h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p>
<h3 id="5-构造方法有哪些特点？是否可被-override"><a href="#5-构造方法有哪些特点？是否可被-override" class="headerlink" title="5. 构造方法有哪些特点？是否可被 override?"></a>5. 构造方法有哪些特点？是否可被 override?</h3><p>构造方法特点如下：</p>
<ul>
<li>名字与类名相同。</li>
<li><strong>没有返回值，且不能用 void 声明构造函数。</strong></li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p><strong>构造方法不能被 override（重写）,但是可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="6-面向对象三大特征"><a href="#6-面向对象三大特征" class="headerlink" title="6. 面向对象三大特征"></a>6. 面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><strong>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</strong>但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），<strong>但是父类中的私有属性和方法子类是无法访问，只是拥有。</strong></li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>编译看左边，执行看右边</p>
<p>多态，顾名思义，表示一个对象具有多种的状态，**<code>具体表现为父类的引用指向子类的实例</code>**。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li><strong>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</strong></li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li><strong>多态不能调用“只在子类存在但在父类不存在”的方法；</strong></li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="7-接口和抽象类有什么共同点和区别？"><a href="#7-接口和抽象类有什么共同点和区别？" class="headerlink" title="7. 接口和抽象类有什么共同点和区别？"></a>7. 接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong>：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是<code>所属关系</code>。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li><strong>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值</strong>，而<strong>抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值.</strong></li>
</ul>
<h3 id="8-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#8-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="8.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>8.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：<strong>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</strong></li>
<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
<li><strong>引用拷贝（Reference Copy）</strong>：<ul>
<li>引用拷贝通常是指浅拷贝中对于引用类型的处理方式。</li>
<li>在浅拷贝中，当我们复制一个包含引用的对象时，我们实际上复制的是引用本身的值，而不是引用指向的对象。</li>
<li>这意味着，如果原始对象和复制对象都引用同一个对象，那么它们实际上共享这个对象的所有权。任何一方对引用的修改都会影响到另一方。</li>
</ul>
</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&amp;deep-copy.png"></p>
<h3 id="9-Object-类的常见方法有哪些？"><a href="#9-Object-类的常见方法有哪些？" class="headerlink" title="9. Object 类的常见方法有哪些？"></a>9. Object 类的常见方法有哪些？</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423215156605.png" alt="image-20240423215156605"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423215234839.png" alt="image-20240423215234839"></p>
<h3 id="10-和-equals-的区别"><a href="#10-和-equals-的区别" class="headerlink" title="10. == 和 equals() 的区别"></a>10. == 和 equals() 的区别</h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li><strong>对于基本数据类型来说，<code>==</code> 比较的是值。</strong></li>
<li><strong>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</strong></li>
</ul>
<p>因为 <strong>Java 只有值传递</strong>，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><strong>String类的equals()方法被重写过，用来比较的是对象的值</strong></p>
<h3 id="11-hashCode-有什么用？"><a href="#11-hashCode-有什么用？" class="headerlink" title="11. hashCode() 有什么用？"></a>11. hashCode() 有什么用？</h3><p><strong><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码</strong>。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png" alt="hashCode() 方法"></p>
<p>​                                                                hashCode() 方法</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<h3 id="12-为什么要有-hashCode？"><a href="#12-为什么要有-hashCode？" class="headerlink" title="12. 为什么要有 hashCode？"></a>12. 为什么要有 hashCode？</h3><p><strong>哈希表的索引–冲突解决–性能优化–快速比较–对象的识别</strong></p>
<p>在Java中，<code>hashCode()</code> 方法的作用是为了支持哈希表的数据结构，特别是当对象用于作为哈希表（例如，Java中的<code>HashMap</code>、<code>HashSet</code>等）的键时。以下是<code>hashCode()</code> 方法的几个关键作用：</p>
<ol>
<li><strong>哈希表的索引</strong>：哈希表是通过哈希函数来索引数据的。<strong>对象的<code>hashCode()</code> 方法为对象返回一个整数哈希码，这个哈希码用于计算对象在哈希表中的索引位置。</strong>如果两个对象的哈希码相同，它们可能会被存储在哈希表中的同一个位置，这可能导致冲突。</li>
<li><strong>冲突解决</strong>：当两个不同的对象具有相同的哈希码（或者在哈希表中计算出的索引位置相同）时，会发生哈希冲突。<strong>在这种情况下，哈希表需要一种方法来区分这些对象。这就是<code>equals()</code> 方法的作用，它用于判断两个对象是否相等。</strong>如果两个对象的哈希码不同，它们在哈希表中的位置也必须不同，这样就不会发生冲突。</li>
<li><strong>性能优化</strong>：在哈希表操作中，如添加、删除和查找，使用哈希码可以大大提高性能。不使用哈希码，每次操作都需要对表中所有元素进行线性搜索，这将导致性能急剧下降。</li>
<li><strong>快速比较</strong>：在某些情况下，可以使用哈希码来快速比较对象。例如，当哈希码不相同时，可以立即知道两个对象在哈希表中的位置不同，从而不需要进一步的<code>equals()</code> 比较。</li>
<li><strong>对象的识别</strong>：虽然<code>equals()</code> 方法用于判断对象内容的相等性，但在某些情况下，哈希码也可以用于识别对象。例如，在<code>IdentityHashMap</code>中，就使用了对象的引用而不是哈希码来存储对象。</li>
</ol>
<p>根据Java的规范，如果两个对象通过<code>equals()</code> 方法测试为相等，那么它们必须有相同的哈希码。然而，两个对象即使不相等，也有可能具有相同的哈希码。这就是为什么在处理哈希表时，需要同时考虑<code>hashCode()</code> 和 <code>equals()</code> 方法。</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（**<code>哈希碰撞</code>**）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="13-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#13-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="13. 为什么重写 equals() 时必须重写 hashCode() 方法？"></a>13. 为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p><strong>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</strong></p>
<p><strong>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</strong></p>
<p>在重写<code>equals()</code> 方法时，也应该相应地重写<code>hashCode()</code> 方法，以确保哈希表的行为符合预期。如果不重写<code>hashCode()</code>，Java会默认使用对象的内存地址作为哈希码，这在大多数情况下都不是预期的行为。</p>
<h3 id="14-String、StringBuffer、StringBuilder-的区别？"><a href="#14-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="14. String、StringBuffer、StringBuilder 的区别？"></a>14. String、StringBuffer、StringBuilder 的区别？</h3><p><strong>可变性</strong></p>
<p><strong><code>String</code> 是不可变的</strong>（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <strong><code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</strong></p>
<p><strong>线程安全性</strong></p>
<p><strong><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</strong><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。**<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。**</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
<h3 id="15-String-为什么是不可变的"><a href="#15-String-为什么是不可变的" class="headerlink" title="15. String 为什么是不可变的?"></a>15. String 为什么是不可变的?</h3><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</p>
<p>修正：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，<strong>并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</strong></li>
<li><strong><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</strong></li>
</ol>
<h3 id="16-字符串拼接用“-”-还是-StringBuilder"><a href="#16-字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="16. 字符串拼接用“+” 还是 StringBuilder?"></a>16. 字符串拼接用“+” 还是 StringBuilder?</h3><p>Java 语言本身并不支持运算符重载，<strong>“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符</strong>。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424091621680.png" alt="image-20240424091621680"></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png" alt="img"></p>
<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。</p>
<h3 id="17-String-equals-和-Object-equals-有何区别？"><a href="#17-String-equals-和-Object-equals-有何区别？" class="headerlink" title="17. String#equals() 和 Object#equals() 有何区别？"></a>17. String#equals() 和 Object#equals() 有何区别？</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <strong><code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</strong></p>
<h3 id="18-字符串常量池的作用了解吗？"><a href="#18-字符串常量池的作用了解吗？" class="headerlink" title="18. 字符串常量池的作用了解吗？"></a>18. 字符串常量池的作用了解吗？</h3><p><strong>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093100211.png" alt="image-20240424093100211"></p>
<h3 id="19-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#19-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="19. String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>19. String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p>会创建 1 或 2 个字符串对象。</p>
<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093227444.png" alt="image-20240424093227444"></p>
<p><strong><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</strong></p>
<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093310489.png" alt="image-20240424093310489"></p>
<h3 id="20-String-intern-方法有什么作用"><a href="#20-String-intern-方法有什么作用" class="headerlink" title="20.String.intern() 方法有什么作用?"></a>20.String.intern() 方法有什么作用?</h3><p><code>String.intern()</code> 是一个 native（本地）方法，<strong>其作用是将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果<strong>字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</strong></li>
</ul>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093529761.png" alt="image-20240424093529761"></p>
<h3 id="21-String-类型的变量和常量做“-”运算时发生了什么？"><a href="#21-String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="21.String 类型的变量和常量做“+”运算时发生了什么？"></a>21.String 类型的变量和常量做“+”运算时发生了什么？</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"str"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"ing"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">"str"</span> + <span class="string">"ing"</span>;   <span class="comment">// 发生常量折叠</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;  <span class="comment">// 调用StringBulid的append()方法，然后再调用同String()得到一个String对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中</strong>，这是 <strong>Javac 编译器会对源代码做的极少量优化措施之一</strong>(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = "str" + "ing";</code> 编译器会给你优化成 <code>String str3 = "string";</code></p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p><strong>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</strong></p>
<h3 id="22-包访问权限"><a href="#22-包访问权限" class="headerlink" title="22. 包访问权限"></a>22. 包访问权限</h3><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240516210828718.png" alt="image-20240516210828718"></p>
<p><strong>public –&gt; protected –&gt; 默认–&gt;private</strong></p>
<h1 id="下"><a href="#下" class="headerlink" title="下"></a>下</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>Java 异常类层次结构图概览</strong>：</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424151721592.png" alt="image-20240424151721592"></p>
<h3 id="1-Exception-和-Error-有什么区别？"><a href="#1-Exception-和-Error-有什么区别？" class="headerlink" title="1. Exception 和 Error 有什么区别？"></a>1. Exception 和 Error 有什么区别？</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <strong><code>Throwable</code></strong> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<p><strong><code>Exception</code></strong> :<strong>程序本身可以处理的异常</strong>，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p>
<p>**<code>Error</code>**：<code>Error</code> <strong>属于程序无法处理的错误</strong> ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
<h3 id="2-Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#2-Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="2. Checked Exception 和 Unchecked Exception 有什么区别？"></a>2. Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p>
<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
</ul>
<h3 id="3-Throwable-类常用方法有哪些？"><a href="#3-Throwable-类常用方法有哪些？" class="headerlink" title="3. Throwable 类常用方法有哪些？"></a>3. Throwable 类常用方法有哪些？</h3><p><code>String getMessage()</code>: 返回异常发生时的简要描述</p>
<p><code>String toString()</code>: 返回异常发生时的详细信息</p>
<p><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</p>
<p><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</p>
<h3 id="4-try-catch-finally-如何使用？"><a href="#4-try-catch-finally-如何使用？" class="headerlink" title="4. try-catch-finally 如何使用？"></a>4. try-catch-finally 如何使用？</h3><p><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p>
<p><code>catch</code>块：用于处理 try 捕获到的异常。</p>
<p><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424152640780.png" alt="image-20240424152640780"></p>
<p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<h3 id="5-finally-中的代码一定会执行吗？"><a href="#5-finally-中的代码一定会执行吗？" class="headerlink" title="5. finally 中的代码一定会执行吗？"></a>5. finally 中的代码一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p>
<p>就比如说 <strong>finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424152848442.png" alt="image-20240424152848442"></p>
<p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p>
<ol>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<h3 id="6-如何使用-try-with-resources-代替try-catch-finally？"><a href="#6-如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="6. 如何使用 try-with-resources 代替try-catch-finally？"></a>6. 如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者<code>java.io.Closeable</code> 的对象</p>
<p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。</p>
<p>**面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>**。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
<h3 id="7-异常使用有哪些需要注意的地方？"><a href="#7-异常使用有哪些需要注意的地方？" class="headerlink" title="7. 异常使用有哪些需要注意的地方？"></a>7. 异常使用有哪些需要注意的地方？</h3><ul>
<li><strong>不要把异常定义为静态变量</strong>，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要有意义。</li>
<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>
<li>避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="1-什么是泛型？有什么作用？"><a href="#1-什么是泛型？有什么作用？" class="headerlink" title="1. 什么是泛型？有什么作用？"></a>1. 什么是泛型？有什么作用？</h3><p>泛型指在类定义时不会设置类中的属性或方法参数的具体类型，而是在类使用时（创建对象）再进行类型的定义。会在编译期间检查类型是否错误。</p>
<p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，<strong>可以增强代码的可读性以及稳定性。</strong></p>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>
<h3 id="2-说说你对泛型的理解"><a href="#2-说说你对泛型的理解" class="headerlink" title="2. 说说你对泛型的理解"></a>2. 说说你对泛型的理解</h3><p><strong>泛型是Java中的一个特性，它允许我们在定义类、接口或方法时使用类型参数，以实现代码的通用性和安全性。</strong></p>
<p><strong>泛型的目的是在编译时进行类型检查，并提供编译期间的类型安全。</strong> 泛型的理解包括以下几个方面： </p>
<p>首先，<strong>泛型提供了代码重用和通用性。</strong>通过使用泛型，我们可以编写可重用的代码，可以在不同的数据类型上执行相同的操作。这样，我们可以避免重复编写类似的代码，提高了开发效率。 </p>
<p>其次，<strong>泛型强调类型安全。</strong>编译器可以在编译时进行类型检查，阻止不符合类型约束的操作。这样可以避免在运行时出现类型错误的可能，增加了程序的稳定性和可靠性。 </p>
<p>另外，<strong>使用泛型可以避免大量的类型转换和强制类型转换操作</strong>。在使用泛型集合类时，不需要进行强制类型转换，可以直接获取正确的数据类型，提高了代码的可读性和维护性。 </p>
<p>此外，<strong>泛型还可以在编译时进行类型检查，提前发现潜在的类型错误。</strong>这种类型检查是在编译时进行的，避免了一些常见的运行时类型异常，减少了错误的可能性。 </p>
<p>最后，<strong>泛型可以增加代码的可读性和可维护性。</strong>通过使用泛型，我们可以明确指定数据类型，并在代码中表达清晰，使得其他开发人员更容易理解代码的意图和功能。</p>
<h3 id="3-泛型的使用方式有哪几种？"><a href="#3-泛型的使用方式有哪几种？" class="headerlink" title="3. 泛型的使用方式有哪几种？"></a>3. 泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
<p><strong>1.泛型类</strong>：</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154532054.png" alt="image-20240424154532054"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154551300.png" alt="image-20240424154551300"></p>
<p><strong>2.泛型接口</strong>：</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154629140.png" alt="image-20240424154629140"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154653779.png" alt="image-20240424154653779"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154716668.png" alt="image-20240424154716668"></p>
<p><strong>3.泛型方法</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154819692.png" alt="image-20240424154819692"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154844326.png" alt="image-20240424154844326"></p>
<p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;<strong>在 java 中泛型只是一个占位符，必须在传递类型后才能使用。</strong> <strong>类在实例化时才能真正的传递类型参数</strong>，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，<strong>所以静态泛型方法是没有办法使用类上声明的泛型的</strong>。只能使用自己声明的 <code>&lt;E&gt;</code>.</p>
<p>静态泛型方法没有办法使用类上声明的泛型</p>
<h3 id="4-项目中哪里用到了泛型？"><a href="#4-项目中哪里用到了泛型？" class="headerlink" title="4. 项目中哪里用到了泛型？"></a>4. 项目中哪里用到了泛型？</h3><p>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</p>
<p>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</p>
<p>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="11-何谓反射？"><a href="#11-何谓反射？" class="headerlink" title="11. 何谓反射？"></a>11. 何谓反射？</h3><p>定义：<strong>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。</strong>在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p>
<p><strong>反射机制允许程序在运行时查询类、接口、字段和方法的信息，并且能够动态地创建和操作对象。</strong></p>
<p>以下是 Java 反射机制的一些关键点：</p>
<ol>
<li><strong>动态加载类</strong>：反射可以在运行时动态地加载类，而不必在使用类之前显式地加载它。</li>
<li><strong>访问私有成员</strong>：反射可以访问一个类的所有成员，包括私有字段和方法，这在正常情况下是无法做到的。</li>
<li><strong>修改字段值</strong>：反射机制可以用来读取和修改私有字段的值，这对于框架和库开发者来说非常有用，可以实现通用代码来处理不同类的数据。</li>
<li><strong>调用方法</strong>：反射机制可以让开发者调用任何对象的方法，即使这些方法在编译时是私有的。</li>
<li><strong>生成对象</strong>：反射还可以用于动态地生成对象，这在诸如框架和脚本语言中非常常见。</li>
<li><strong>注解处理</strong>：反射与注解（Annotations）结合使用，可以方便地处理注解信息，如自动装配、日志记录和代码生成等。</li>
<li><strong>动态代理</strong>：反射还可以用来创建动态代理，这是 Java 代理模式的基础，用于在不修改原始类代码的情况下，添加额外的功能。</li>
</ol>
<h3 id="12-反射的优缺点？"><a href="#12-反射的优缺点？" class="headerlink" title="12. 反射的优缺点？"></a>12. 反射的优缺点？</h3><p>优点：</p>
<ol>
<li><strong>动态性</strong>：反射机制允许程序在运行时动态地创建对象、调用方法、访问字段，提供了极大的灵活性和动态性。</li>
<li><strong>扩展性和可配置性</strong>：反射机制可以用于插件系统、框架开发等场景，使得程序可以动态地加载和配置组件，提高了系统的扩展性和可配置性。</li>
<li><strong>解耦</strong>：通过反射，可以减少代码之间的依赖关系，降低耦合度，使得程序更加模块化。</li>
<li><strong>工具和框架开发</strong>：许多Java工具和框架（如Spring、Hibernate等）都使用了反射机制，以提供强大的功能和简化开发。</li>
</ol>
<p>缺点：</p>
<ol>
<li><strong>性能开销</strong>：反射操作通常比直接的代码执行要慢，因为反射涉及到动态解析和类型检查，增加了性能开销。</li>
<li><strong>安全性问题</strong>：反射机制可以绕过Java的访问权限检查，访问私有字段和方法，这可能会破坏封装性，引入安全风险。</li>
<li><strong>复杂性</strong>：使用反射机制会使代码更加复杂和难以理解，因为它涉及到动态类型和元数据的操作。</li>
<li><strong>可读性和可维护性</strong>：过度使用反射机制会导致代码的可读性和可维护性降低，因为反射代码通常不如直接编写的代码直观。</li>
<li><strong>调试困难</strong>：由于反射操作在编译时无法被完全检查，因此可能会引入一些难以调试的问题。</li>
</ol>
<h3 id="13-反射的应用场景？"><a href="#13-反射的应用场景？" class="headerlink" title="13. 反射的应用场景？"></a>13. 反射的应用场景？</h3><p><strong>经典的反射应用场景–jdbc</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(com.mysql.jdbc.Driver.class); <span class="comment">//加载MySQL的驱动类</span></span><br></pre></td></tr></tbody></table></figure>

<p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。<strong>像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</strong></p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424155858229.png" alt="image-20240424155858229"></p>
<p>外，像 <strong>Java 中的一大利器 注解 的实现也用到了反射。</strong></p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h3 id="反射的实现方式"><a href="#反射的实现方式" class="headerlink" title="反射的实现方式"></a>反射的实现方式</h3><ol>
<li>获取class对象：Class.forName(“类的路径”)；类名.class；对象名.getClass()；基本类型的包装类</li>
<li>创建对象</li>
<li>调用方法</li>
<li>访问字段</li>
<li>修改访问权限</li>
<li>获取注解信息</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="1-何谓注解？"><a href="#1-何谓注解？" class="headerlink" title="1. 何谓注解？"></a>1. 何谓注解？</h3><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424160103501.png" alt="image-20240424160103501"></p>
<p>JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
<h3 id="2-注解的解析方法有哪几种？"><a href="#2-注解的解析方法有哪几种？" class="headerlink" title="2. 注解的解析方法有哪几种？"></a>2. 注解的解析方法有哪几种？</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<h3 id="3-谈谈自定义注解的场景及实现"><a href="#3-谈谈自定义注解的场景及实现" class="headerlink" title="3. 谈谈自定义注解的场景及实现"></a>3. 谈谈自定义注解的场景及实现</h3><p><strong>自定义注解是Java语言的一个强大特性，可以为代码添加元数据信息，提供额外配置或标记。</strong>它适用于<strong>多种场景</strong>。 </p>
<ol>
<li><strong>配置和扩展框架：</strong>通过自定义注解，可以为框架提供配置参数或进行扩展。例如，Spring框架中的@Autowired注解用于自动装配依赖项，@RequestMapping注解用于映射请求到控制器方法。 </li>
<li><strong>运行时检查：</strong>自定义注解可在运行时对代码进行检查，并进行相应处理。例如，JUnit框架的@Test注解标记测试方法，在运行测试时会自动识别并执行这些方法。 </li>
<li><strong>规范约束：</strong>自定义注解用于规范代码风格和约束。例如，Java代码规范检查工具Checkstyle可使用自定义注解标记违规行为。</li>
</ol>
<p>实现自定义注解的步骤如下： </p>
<ol>
<li>使用@interface关键字定义注解。 </li>
<li>可在注解中定义属性，并指定默认值。 </li>
<li>根据需求，可添加元注解来控制注解的使用方式。 </li>
<li>在代码中使用自定义注解。 </li>
<li>使用反射机制解析注解信息。</li>
</ol>
<p>通过合理运用自定义注解，可提高代码的可读性、可维护性和可扩展性。</p>
<h3 id="4-序列化和反序列化"><a href="#4-序列化和反序列化" class="headerlink" title="4. 序列化和反序列化"></a>4. 序列化和反序列化</h3><p>序列化：将数据结构或对象转换成二进制字节流的过程</p>
<p>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</p>
<p><strong>常见场景</strong></p>
<ul>
<li>对象在<strong>进行网络传输</strong>（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象<strong>存储到文件</strong>之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象<strong>存储到数据库</strong>（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象<strong>存储到内存</strong>之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
</ul>
<p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<p><strong>序列化协议对应TCP/IP 4层模型的哪一层 —-&gt; 应用层</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240711130609396.png" alt="image-20240711130609396"></p>
<p><strong>对于不想序列化的字段如何处理 —-&gt;使用<code>transient</code>关键字修饰</strong></p>
<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>使用<code>transient</code> 的注意点：</p>
<ul>
<li><code>transient</code> <strong>只能修饰变量，不能修饰类和方法</strong></li>
<li><code>transient</code> 修饰的变量，<strong>在反序列化后变量值将会被置成类型的默认值</strong>。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><strong><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</strong>    <code>static</code> 变量不会被序列化</li>
<li></li>
</ul>
<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h3 id="数组初始化必须指定初始化长度，否则报错"><a href="#数组初始化必须指定初始化长度，否则报错" class="headerlink" title="数组初始化必须指定初始化长度，否则报错"></a>数组初始化必须指定初始化长度，否则报错</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];<span class="comment">//推介使用int[] 这种方式初始化</span></span><br><span class="line"><span class="type">int</span> c[] = {<span class="number">23</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">78</span>};<span class="comment">//长度：4，索引范围：[0,3]</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a><code>ArrayList</code>和<code>LinkedList</code></h3><p><code>ArrayList</code>：<strong>可以看作是能够自动增长容量的数组</strong></p>
<p>Java 集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加 入数据达到一定程度后，会实行自动扩容，即扩大数组大小。</p>
<p><code>toArray方法</code>返回一个<strong>数组</strong></p>
<p><code>asList方法</code>返回一个<strong>列表</strong></p>
<p><code>LinkedList</code>是一个双链表，在添加和删除元素时具有比<code>ArrayList</code>更好的性能。</p>
<h3 id="向上转型and向下转型"><a href="#向上转型and向下转型" class="headerlink" title="向上转型and向下转型"></a>向上转型and向下转型</h3><p><code>向上转型</code>：向上转型是指将子类对象转型为它的父类类型。因为子类继承了父类的所有属性和方法，所以向上转型是安全的，不需要强制类型转换。</p>
<p><code>向下转型</code>：向下转型是指将父类对象转型为它的子类类型。这种转型可能是不安全的，因为如果你尝试将一个父类引用转型为子类类型，而这个父类引用实际上指向的是一个父类对象，那么在调用子类特有的方法时可能会抛出<code>ClassCastException</code>。</p>
<p>为了进行向下转型，你需要使用<code>cast</code>操作符，并确保转型是合法的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) a;</span><br><span class="line">    d.makeSound(); <span class="comment">// 安全转型</span></span><br><span class="line">} <span class="keyword">catch</span> (ClassCastException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"The object is not an instance of Dog"</span>, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="常见的5中运行时异常"><a href="#常见的5中运行时异常" class="headerlink" title="常见的5中运行时异常"></a>常见的5中运行时异常</h3><p><code>ClassCastException</code>:类转化异常</p>
<p><code>IndexOutOfBoundaryException</code>: 数组越界</p>
<p><code>NullPointerException</code>: 空指针异常</p>
<p><code>ArrayStoreException</code>：数据存储异常，操作数组时类型不一致</p>
<p><code>BufferOverflowException</code>:缓冲区溢出</p>
<h3 id="进程、程序、线程的基本概念及关系"><a href="#进程、程序、线程的基本概念及关系" class="headerlink" title="进程、程序、线程的基本概念及关系"></a>进程、程序、线程的基本概念及关系</h3><p>进程是程序的一次执行过程，是系统进行资源分配和调度的一个独立单元，每个进程都有自己的地址空间、数据栈以及其他用于跟踪执行的辅助数据。</p>
<p>程序是一系列指令的集合，通常以文件形式存储在磁盘上，是静态的代码，不占用系统资源。</p>
<p>线程是进程中的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能够独立运行的基本单位</p>
<ul>
<li><strong>程序与进程</strong>：程序是静态的代码，进程是程序的动态执行实例。一个程序可以对应多个进程，即同一程序的多份副本在内存中运行。</li>
<li><strong>进程与线程</strong>：线程是进程的组成部分，一个进程可以有多个线程，它们共享进程的资源，但每个线程有自己的执行堆栈和程序计数器等。</li>
<li><strong>程序与线程</strong>：线程是程序在执行过程中的一个路径，一个程序通过创建多个线程来实现多任务处理。</li>
</ul>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>分类：</p>
<ul>
<li>流向分类：输出流and输出流</li>
<li>操作单元：字节流and字符流</li>
<li>流的角色：节点流and处理流</li>
</ul>
<p>字节流：<code>InputStream/OutputStream</code></p>
<p>字符流：<code>Writer/Reader</code></p>
<h3 id="Object类的常用方法"><a href="#Object类的常用方法" class="headerlink" title="Object类的常用方法"></a>Object类的常用方法</h3><ul>
<li>clone():实现对象的浅拷贝，必须实现Cloneable接口才能调用此方法，否则抛出<code>CloneNotSupportException</code>异常</li>
<li>finalize():与垃圾收集器有关系，判断一个对象是否可以被回收的最后一部就是判断是否重写了此方法</li>
<li>equals():一般equals和==是不一样的，但是在Object中两者是一样的，子类一般都要重写这个方法。</li>
<li><code>hasCode()</code>:该方法用于哈希查找，重写了 equals 方法一般都要重写<code> hashCode</code> 方法，这个方法在一些具有哈希功能的 Collection 中用到</li>
<li>wait():配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。</li>
<li>notify()</li>
<li><code>notifyAll()</code></li>
</ul>
<h3 id="java创建对象有哪几种方式"><a href="#java创建对象有哪几种方式" class="headerlink" title="java创建对象有哪几种方式"></a>java创建对象有哪几种方式</h3><ul>
<li><strong>使用new关键字</strong></li>
<li><strong>使用反射方式创建对象</strong></li>
<li><strong>使用clone方法</strong></li>
<li><strong>使用反序列化创建对象</strong></li>
</ul>
<h3 id="获取一个类Class对象的方式有哪些"><a href="#获取一个类Class对象的方式有哪些" class="headerlink" title="获取一个类Class对象的方式有哪些"></a>获取一个类Class对象的方式有哪些</h3><p>在Java中，获取一个类（Class）对象的方式有多种，以下是一些常用的方法：</p>
<ol>
<li><p><strong>使用<code>Class.forName()</code>方法</strong>：<br>这是最常用的方式之一，特别是在动态加载类时。这个方法需要类的完全限定名（包括包名）作为参数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用<code>.class</code>属性</strong>：<br>这是一种静态方法，适用于已知类的类型的情况。这种方式不需要类的实例。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; clazz = String.class;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用<code>getClass()</code>方法</strong>：<br>如果已经有一个对象实例，可以通过调用该对象的<code>getClass()</code>方法来获取其<code>Class</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="comment">//clazz就是一个User的类对象</span></span><br><span class="line">Class&lt;?&gt; clazz=user.getClass();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用<code>ClassLoader</code>的<code>loadClass()</code>方法</strong>：<br>使用类的类加载器来加载类。这种方式更为灵活，因为它允许你使用特定的类加载器。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用<code>Class</code>的<code>getSuperclass()</code>方法</strong>：<br>如果已知一个类的子类，可以通过调用子类的<code>Class</code>对象的<code>getSuperclass()</code>方法来获取其父类的<code>Class</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; superClass = Integer.class.getSuperclass();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用<code>Primitive Type</code>的<code>.TYPE</code>字段</strong>：<br>对于基本数据类型，可以使用<code>.TYPE</code>字段获取其对应的<code>Class</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; clazz = Integer.TYPE;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用<code>Array</code>类的<code>newInstance()</code>方法</strong>：<br>如果你想获取一个数组的<code>Class</code>对象，可以使用<code>Array</code>类的<code>newInstance()</code>方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Array.newInstance(String.class, <span class="number">0</span>).getClass();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h3><p>Java集合框架中的<code>ArrayList</code>、<code>HashMap</code>等在迭代过程中，如果检测到集合结构被修改（不是通过迭代器自己的方法），就会立即抛出<code>ConcurrentModificationException</code>异常，这就是”fail-fast”行为。</p>
<p><strong>“fail-fast”机制有助于在早期阶段发现和防止并发问题，但它并不意味着绝对的安全。</strong></p>
<h3 id="Hashtable-与-HashMap的区别⭐⭐"><a href="#Hashtable-与-HashMap的区别⭐⭐" class="headerlink" title="Hashtable 与 HashMap的区别⭐⭐"></a><code>Hashtable</code> 与 <code>HashMap</code>的区别⭐⭐</h3><ol>
<li>出生的版本不一样，<code>Hashtable </code>出生于 Java 发布的第一版本 JDK 1.0，HashMap 出生于 JDK1.2</li>
<li>都实现了 Map、Cloneable、Serializable（当前 JDK 版本 1.8）。</li>
<li>HashMap 继承的是 <code>AbstractMap</code>，并且 <code>AbstractMap</code> 也实现了 Map 接口。<code>Hashtable</code> 继承Dictionary。</li>
<li><code>Hashtable </code>中大部分 public 修饰普通方法都是 synchronized 字段修饰的，是<strong>线程安全</strong>的，HashMap 是<strong>非线程安全的</strong>。</li>
<li><strong><code>Hashtable</code> 的 key 不能为 null，value 也不能为 null</strong>，这个可以从<code> Hashtable</code> 源码中的 put 方法看到，判断如果 value 为 null 就直接抛出空指针异常，在 put 方法中计算 key 的 hash 值之前并没有判断 key 为 null 的情况，那说明，这时候如果 key 为空，照样会抛出空指针异常。</li>
<li><strong>HashMap 的 key 和 value 都可以为 null。</strong>在计算 hash 值的时候，有判断，如果key==null ，则其 hash=0 ；至于 value 是否为 null，根本没有判断过。</li>
<li><code>Hashtable</code> 直接使用对象的 hash 值。hash 值是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</li>
<li><code>Hashtable</code>、HashMap 都使用了 Iterator。而由于历史原因，<code>Hashtable</code> 还使用了Enumeration 的方式。</li>
<li><strong>默认情况下，初始容量不同，Hashtable 的初始长度是 11，之后每次扩充容量变为之前的2n+1（n 为上一次的长度）;而 HashMap 的初始长度为 16，之后每次扩充变为原来的两倍。</strong></li>
</ol>
<p>[注] HashMap可以存null,但是HashTable和ConcurrentHashMap不可以插入为null的值</p>
<p><strong>Hashtable is synchronized. If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable . If a thread-safe highly concurrent implementation is desired, then it is recommended to use ConcurrentHashMap in place of Hashtable.</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240605195002821.png" alt="image-20240605195002821"></p>
<h3 id="HashMap的长度为什么是2的N次方呢"><a href="#HashMap的长度为什么是2的N次方呢" class="headerlink" title="HashMap的长度为什么是2的N次方呢"></a>HashMap的长度为什么是2的N次方呢</h3><p>为了能让HashMap存数据和取数据的效率高，尽可能地减少hash值的碰撞，也就是说尽量把数据能均匀分配，每个链表或者红黑树长度尽量相等。</p>
<p>我们首先可能会想到 % 取模的操作来实现。</p>
<p><strong><code>取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说hash % length == hash &amp;(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 &amp; ，相对于 % 能够提高运算效率。</code></strong></p>
<h3 id="HashMap与ConcurrentHashMap的异同"><a href="#HashMap与ConcurrentHashMap的异同" class="headerlink" title="HashMap与ConcurrentHashMap的异同"></a>HashMap与ConcurrentHashMap的异同</h3><ol>
<li>都是 key-value 形式的存储数据；</li>
<li>HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；</li>
<li>HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</li>
<li>HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩容；</li>
<li>ConcurrentHashMap 在 JDK 1.7 时使用的是<strong>数据加链表</strong>的形式实现的，其中数组分为两类：<strong>大数组 Segment 和小数组 HashEntry，而加锁是通过给 Segment 添加 ReentrantLock 锁来实现线程安全的</strong>。而 JDK 1.8 中 ConcurrentHashMap <strong>使用的是数组+链表/红黑树的方式实现的，它是通过 CAS 或 synchronized 来实现线程安全的，并且它的锁粒度更小，查询性能也更高</strong>。</li>
</ol>
<p>​			在 JDK 1.8 中，添加元素时首先会判断容器是否为空，如果为空则使用 volatile 加 CAS 来初始化。如果容器不为空则根据存储的元素计算该位置是否为空，如果为空则利用 CAS 设置该节点；如果不为空则使用 synchronize 加锁，遍历桶中的数据，替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。<strong>在 JDK 1.8 中，ConcurrentHashMap 是在头节点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。</strong>而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度</p>
<h3 id="红黑树有哪几个特征"><a href="#红黑树有哪几个特征" class="headerlink" title="红黑树有哪几个特征"></a>红黑树有哪几个特征</h3><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240428160154923.png" alt="image-20240428160154923"></p>
<h3 id="1-Comparator-与-Comparable-有什么区别"><a href="#1-Comparator-与-Comparable-有什么区别" class="headerlink" title="1. Comparator 与 Comparable 有什么区别"></a>1. Comparator 与 Comparable 有什么区别</h3><p>Comparator和Comparable都是Java中用于对象排序的接口，它们之间有一些关键的区别。 </p>
<p><strong>Comparable接口是在对象自身的类中实现的，</strong>它定义了对象的自然排序方式。一个类实现了Comparable接口后，可以使用compareTo方法来比较当前对象和其他对象的大小关系。这个接口只能在对象自身的类中实现，不需要额外的比较器。 </p>
<p><strong>Comparator接口是一个独立的比较器，它可以用于对不同类的对象进行排序。</strong>Comparator接口允许在对象类之外创建一个单独的比较器类或匿名类，并使用它来定义对象的排序规则。比较器通过实现compare方法来比较两个对象的大小关系。 </p>
<p>因此，主要区别如下： </p>
<p>● Comparable接口是在对象自身的类中实现，定义了对象的自然排序方式。 </p>
<p>● Comparator接口是一个单独的比较器，定义了用于排序的规则，可以用于不同类的对象排序。 </p>
<p>● Comparable是内部排序，对象的类必须实现Comparable接口才能进行排序。 </p>
<p>● Comparator是外部排序，可以独立定义排序规则，并与任何类的对象一起使用。 </p>
<p>在使用时，如果需要对对象的默认排序进行操作，可以实现Comparable接口。如果需要对不同类的对象进行排序，或者需要定义多种不同的排序规则，可以使用Comparator接口。</p>
<h3 id="2-说说你对Integer缓存的理解"><a href="#2-说说你对Integer缓存的理解" class="headerlink" title="2. 说说你对Integer缓存的理解"></a>2. 说说你对Integer缓存的理解</h3><p>缓存范围： <strong>-128-127</strong></p>
<p>好处：</p>
<p>第一 <strong>减少内存消耗</strong>：通过重用对象，减少频繁创建和销毁对象导致的内存占用</p>
<p>第二 <strong>提升性能</strong>：避免了重复的对象创建，从而提升了程序的运行效率</p>
<p>第三 <strong>自动管理</strong>： 开发者无需手动管理缓存，JVM会自动处理</p>
<p>另外，值得一提的是，这个缓存的大小是可配置的.在一些JAVA版本中，我们可以通过jvm参数来调整缓存的范围。<br>总的来说，<strong>Integer缓存是JAVA提供的一项优化措施，它通过自动重用一定范围内的整数对象，帮助我们减少内存消耗并提高性能。</strong></p>
<h3 id="5-如何实现线程的同步"><a href="#5-如何实现线程的同步" class="headerlink" title="5. 如何实现线程的同步"></a>5. 如何实现线程的同步</h3><p><strong>线程的同步是为了保证多个线程按照特定的顺序、协调地访问共享资源，避免数据不一致和竞争条件等问题。</strong></p>
<p>:blue_heart:<strong>使用synchronized关键字—使用ReentrantLock类— 使用wait()、notify()、notifyall()方法— 使用CountDownLatch和CyclicBarrier</strong></p>
<ol>
<li><strong>使用synchronized关键字：</strong>通过在方法或代码块前加上synchronized关键字，确保同一时间只有一个线程可以执行标记为同步的代码。这样可以避免多个线程同时访问共享资源造成的数据不一致问题。</li>
<li><strong>使用ReentrantLock类：</strong>它是一个可重入锁，通过调用lock()和unlock()方法获取和释放锁。与synchronized不同，ReentrantLock提供了更灵活的同步控制，例如可实现公平性和试锁等待时间。</li>
<li><strong>使用wait()、notify()和notifyAll()方法：</strong>这些方法是Object类的方法，允许线程间进行协作和通信。通过调用wait()方法使线程进入等待状态，然后其他线程可以通过notify()或notifyAll()方法唤醒等待的线程。</li>
<li><strong>使用CountDownLatch和CyclicBarrier：</strong>它们是并发工具类，用于线程之间的同步和等待。<strong>CountDownLatch可用于等待一组线程完成操作，而CyclicBarrier用于等待一组线程互相达到屏障位置。</strong></li>
</ol>
<h3 id="6-什么是守护线程？与普通线程的区别"><a href="#6-什么是守护线程？与普通线程的区别" class="headerlink" title="6.什么是守护线程？与普通线程的区别"></a>6.什么是守护线程？与普通线程的区别</h3><p><strong>setDaemon(true)</strong></p>
<p>守护线程是在程序运行时在后台提供一种支持性的线程。与普通线程相比，守护线程有以下几个区别：</p>
<ul>
<li><strong>终止条件：</strong>当所有用户线程结束时，守护线程会自动停止。换句话说，守护线程不会阻止程序的终止，即使它们还没有执行完任务。 </li>
<li><strong>生命周期：</strong>守护线程的生命周期与主线程或其他用户线程无关。当所有的非守护线程都结束时，JVM 将会退出并停止守护线程的执行。 </li>
<li><strong>线程优先级：</strong>守护线程的优先级默认与普通线程一样。优先级较高的守护线程也不能够保证在其他线程之前执行。 </li>
<li><strong>资源回收：</strong>守护线程通常被用于执行一些后台任务，例如垃圾回收、日志记录、定时任务等。当只剩下守护线程时，JVM 会自动退出并且不会等待守护线程执行完毕。</li>
</ul>
<p>需要注意的是，守护线程与普通线程在编写代码时没有太大的区别。<strong>可以通过将线程的setDaemon(true)方法设置为 true，将普通线程转换为守护线程。</strong></p>
<h3 id="7-Java中集合框架有哪些核心接口"><a href="#7-Java中集合框架有哪些核心接口" class="headerlink" title="7. Java中集合框架有哪些核心接口"></a>7. Java中集合框架有哪些核心接口</h3><p><strong>Collection接口 — List接口 — Set接口 — Queue接口 — Map接口</strong></p>
<p><strong>Collection接口：</strong>是集合框架中最通用的接口，用于表示一组对象。<strong>它是List、Set和Queue接口的父接口，定义了对集合进行基本操作的方法。</strong></p>
<p><strong>List接口：</strong> <strong>表示一个有序的、可重复的集合</strong>。List接口的实现类可以根据元素的插入顺序访问和操作集合中的元素。常见的List接口的实现类有ArrayList、LinkedList和Vector。</p>
<p><strong>Set接口：</strong>表示一个<strong>无序的、不可重复的集合</strong>。Set接口的实现类不能包含重复的元素。常见的Set接口的实现类有HashSet、TreeSet和LinkedHashSet。</p>
<p><strong>Map接口：</strong>表示一<strong>个键值对的映射集合</strong>。Map接口中的每个元素由一个键和一个值组成，<strong>并且每个键只能在Map中出现一次</strong>。常见的Map接口的实现类有HashMap、TreeMap和LinkedHashMap。</p>
<h3 id="8-ArrayList和LinkedList有什么区别"><a href="#8-ArrayList和LinkedList有什么区别" class="headerlink" title="8. ArrayList和LinkedList有什么区别"></a>8. ArrayList和LinkedList有什么区别</h3><p><strong>底层数据结构 — 随机访问性能 — 插入和删除性能 — 内存占用</strong></p>
<p>ArrayList和LinkedList是Java集合框架中List接口的两个常见实现类，它们在底层实现和性能特点上有以下几点区别： </p>
<ol>
<li>底层数据结构：ArrayList使用数组来存储元素，而LinkedList使用双向链表来存储元素。 </li>
<li>随机访问性能：ArrayList支持高效的随机访问（根据索引获取元素），因为它可以通过下标计算元素在数组中的位置。而LinkedList在随机访问方面性能较差，获取元素需要从头或尾部开始遍历链表找到对应位置。</li>
<li>插入和删除性能：ArrayList在尾部添加或删除元素的性能较好，因为它不涉及数组的移动。而在中间插入或删除元素时，ArrayList涉及到元素的移动，性能相对较低。LinkedList在任意位置进行插入和删除操作的性能较好，因为只需要调整链表中的指针即可。 </li>
<li>内存占用：ArrayList在每个元素都需要存储一个引用和一个额外的数组空间，因此内存占用比较高。而LinkedList由于需要存储前后节点的引用，相对于ArrayList占用的内存更多。</li>
</ol>
<p>综上所述，如果需要频繁进行随机访问操作或在尾部进行插入和删除操作，可以选择ArrayList。如果需要频繁进行中间位置的插入和删除操作，或者对内存占用有一定限制，可以选择LinkedList。</p>
<h3 id="10-什么是Java的序列化⭐⭐⭐"><a href="#10-什么是Java的序列化⭐⭐⭐" class="headerlink" title="10. 什么是Java的序列化⭐⭐⭐"></a>10. 什么是Java的序列化⭐⭐⭐</h3><p><strong>Java的序列化是指将Java对象转换为字节流的过程，可以将这些字节流保存到文件中或通过网络传输。</strong></p>
<p>反序列化则是指将字节流恢复成对象的过程。 </p>
<p>序列化的<strong>主要目的是实现对象的持久化存储和传输</strong>，让对象可以在不同的计算机或不同的时间点被重建和使用。</p>
<p>通过序列化，可以将对象的状态以字节的形式保存下来，并且在需要的时候进行恢复，从而实现了对象的跨平台传输和持久化存储。 </p>
<p>在Java中，要使一个类可序列化，需要满足以下条件： </p>
<ol>
<li><strong>实现java.io.Serializable接口</strong>，该接口是一个标记接口，没有任何方法。 </li>
<li><strong>所有的非静态、非瞬态的字段都可以被序列化</strong>。 —- 不能是静态的</li>
</ol>
<p>使用Java的序列化机制，可以通过ObjectOutputStream将对象转换为字节流并写入文件或网络流中。反之，通过ObjectInputStream可以从字节流中读取数据并还原为对象。 需要注意的是，在进行序列化和反序列化时，对象的类和字段的定义必须保持一致，否则可能会导致序列化版本不匹配或字段丢失的问题。</p>
<h3 id="11-说说你对内部类的理解⭐⭐⭐"><a href="#11-说说你对内部类的理解⭐⭐⭐" class="headerlink" title="11. 说说你对内部类的理解⭐⭐⭐"></a>11. 说说你对内部类的理解⭐⭐⭐</h3><p>内部类是Java中一种特殊的类，它定义在其他类或方法中，并且可以访问外部类的成员，包括私有成员。</p>
<p><strong>成员内部类 — 静态内部类 — 局部内部类 — 匿名内部类</strong></p>
<p><strong>成员内部类：</strong>定义在一个类的内部，并且不是静态的。<strong>成员内部类可以访问外部类的所有成员，包括私有成员</strong>。<strong>在创建内部类对象时，需要先创建外部类对象，然后通过外部类对象来创建内部类对象。</strong></p>
<p><strong>静态内部类：</strong>定义在一个类的内部，并且是静态的。<strong>与成员内部类不同，静态内部类不能访问外部类的非静态成员，但可以访问外部类的静态成员</strong>。<strong>在创建静态内部类对象时，不需要先创建外部类对象，可以直接通过类名来创建。</strong></p>
<p><strong>局部内部类：</strong> <strong>定义在一个方法或作用域块中的类</strong>，它的作用域被限定在方法或作用域块中。<strong>局部内部类可以访问外部方法或作用域块中的 final 变量和参数。</strong></p>
<p><strong>匿名内部类：</strong> <strong>没有定义名称的内部类</strong>，<strong>通常用于创建实现某个接口或继承某个类的对象</strong>。<strong>匿名内部类会在定义时立即创建对象</strong>，因此通常用于简单的情况，而不用于复杂的类结构。</p>
<p>内部类的<strong>主要作用是实现更加灵活和封装的设计</strong>。需要注意的是，过度使用内部类会增加代码的复杂性，降低可读性和可维护性。因此，在使用内部类时要考虑其是否真正有必要，并且仔细进行设计和命名。</p>
<h4 id="punch-静态内部类和非静态内部类的区别"><a href="#punch-静态内部类和非静态内部类的区别" class="headerlink" title=":punch: 静态内部类和非静态内部类的区别"></a>:punch: 静态内部类和非静态内部类的区别</h4><p>在Java中，静态内部类和非静态内部类都是一种嵌套在其他类中的内部类。它们之间有以下几点区别： </p>
<ol>
<li>实例化方式：<strong>静态内部类可以直接通过外部类名来实例化，而非静态内部类必须要通过外部类的实例来实例化。</strong> </li>
<li>对外部类的引用：静态内部类不持有对外部类实例的引用，而非静态内部类则会持有对外部类实例的引用。这意味着在<strong>静态内部类中不能直接访问外部类的非静态成员（方法或字段），而非静态内部类可以。</strong> </li>
<li>生命周期：<strong>静态内部类的生命周期与外部类相互独立，即使外部类实例被销毁，静态内部类仍然存在。非静态内部类的生命周期与外部类实例绑定，只有在外部类实例存在时才能创建非静态内部类的实例。</strong> </li>
<li>访问权限：静态内部类对外部类的访问权限与其他类一样，根据访问修饰符而定。<strong>非静态内部类可以访问外部类的所有成员，包括私有成员。</strong></li>
</ol>
<h3 id="12-说说你对lambda表达式的理解"><a href="#12-说说你对lambda表达式的理解" class="headerlink" title="12. 说说你对lambda表达式的理解"></a>12. 说说你对lambda表达式的理解</h3><p>Lambda表达式是Java 8引入的一种简洁的语法形式，用于表示匿名函数。<strong>它可以作为参数传递给方法或函数接口，并且可以在需要函数式编程特性的地方使用。</strong> </p>
<p>Lambda表达式的语法类似于**(参数列表) -&gt; 表达式或代码块**。参数列表描述了输入参数，可以省略类型，甚至括号。箭头符号将参数列表与表达式或代码块分隔开来。 </p>
<p>Lambda表达式具有以下<strong>特点</strong>： </p>
<p><strong>1 简洁：</strong>相较于传统的匿名内部类，Lambda表达式更加简洁，能用更少的代码实现相同功能。 </p>
<p><strong>2 函数式编程：</strong>支持函数作为一等公民进行传递和操作。 </p>
<p><strong>3 闭包：</strong>可以访问周围的变量和参数。 </p>
<p><strong>4 方法引用：</strong>可以通过引用已存在的方法进一步简化。 </p>
<p>Lambda表达式的<strong>应用场景</strong>包括： </p>
<p>● 集合操作：对集合元素进行筛选、映射、排序等操作，使代码简洁和可读。 </p>
<p>● 并行编程：利用Lambda表达式简化并发编程的复杂性。 </p>
<p>● 事件驱动模型：作为回调函数响应用户输入或系统事件。 </p>
<p>需要注意，<strong>Lambda表达式仅适用于函数式接口（只有一个抽象方法的接口），可直接实现该接口的实例，避免编写传统匿名内部类</strong>。Lambda表达式在Java编程中提供了更为灵活和简洁的语法，促进了函数式编程的应用。</p>
<h3 id="13-notify和notifyAll-有什么区别"><a href="#13-notify和notifyAll-有什么区别" class="headerlink" title="13. notify和notifyAll()有什么区别"></a>13. notify和notifyAll()有什么区别</h3><p>在Java中，notify()和notifyAll()都属于Object类的方法，用于实现线程间的通信。 </p>
<p>notify()方法用于<strong>唤醒在当前对象上等待的单个线程。</strong>如果有多个线程同时在某个对象上等待（通过调用该对象的wait()方法），则只会唤醒其中一个线程，并<strong>使其从等待状态变为可运行状态</strong>。具体是哪个线程被唤醒是不确定的，取决于线程调度器的实现。 </p>
<p>notifyAll()方法用于<strong>唤醒在当前对象上等待的所有线程</strong>。如果有多个线程在某个对象上等待，调用notifyAll()方法后，所有等待的线程都会被唤醒并竞争该对象的锁。其中一个线程获得锁后继续执行，其他线程则继续等待。 </p>
<p><strong>notify()和notifyAll()方法只能在同步代码块或同步方法内部调用，并且必须拥有与该对象关联的锁。否则会抛IllegalMonitorStateException异常。</strong></p>
<h3 id="14-JDK动态代理与CGLIB实现的区别"><a href="#14-JDK动态代理与CGLIB实现的区别" class="headerlink" title="14. JDK动态代理与CGLIB实现的区别"></a>14. JDK动态代理与CGLIB实现的区别</h3><p>JDK动态代理和CGLIB是Java中常用的两种代理技术，它们在实现原理和使用方式上有一些区别。 </p>
<p><strong>JDK动态代理：</strong></p>
<ol>
<li><strong>JDK动态代理是基于接口的代理技术，要求目标类必须实现一个或多个接口。</strong></li>
<li>它使用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来生成代理类和处理代理方法的调用。</li>
<li>在运行时，JDK动态代理会动态生成一个代理类，该代理类实现了目标接口，并在方法调用前后插入额外的代码（即代理逻辑）。</li>
<li>然而，<strong>JDK动态代理只能代理接口，无法代理普通的类。</strong></li>
</ol>
<p><strong>CGLIB：</strong></p>
<ol>
<li>C<strong>GLIB是基于继承的代理技术，可以代理普通的类，不需要目标类实现接口。</strong></li>
<li>它使用字节码生成库，在运行时通过生成目标类的子类来实现代理。</li>
<li><strong>CGLIB通过继承目标类创建一个子类，并重写目标方法，以在方法调用前后插入额外的代码（即代理逻辑）。</strong></li>
<li><strong>但是，由于继承关系，CGLIB无法代理被标记为final的方法。</strong></li>
</ol>
<p>总的来说，<strong>JDK动态代理适用于基于接口的代理需求，而CGLIB适用于代理普通类的需求。</strong>选择使用哪种代理方式取决于具体的需求。如果目标类已经实现了接口且需要基于接口进行代理，可以选择JDK动态代理。而如果目标类没有实现接口，或者需要代理普通类的方法，可以选择CGLIB。</p>
<h3 id="17-构造器是否可以被重写⭐⭐⭐"><a href="#17-构造器是否可以被重写⭐⭐⭐" class="headerlink" title="17. 构造器是否可以被重写⭐⭐⭐"></a>17. 构造器是否可以被重写⭐⭐⭐</h3><p><strong>构造器在Java中是一种特殊的方法，用于创建和初始化对象。</strong>与其他普通方法不同，构造器的名称必须与类名一致，并且<strong>没有返回类型</strong>。 </p>
<p>在Java中，<strong>构造器不能被直接重写</strong>。子类无法定义与父类相同名称和参数的构造器。这是因为构造器是用于创建对象并初始化其状态的特殊方法，它与类的实例化密切相关。如果允许子类重写构造器，那么可能会导致对象的创建和初始化过程出现混乱，破坏了类的结构和设计原则。 </p>
<p>然而，<strong>子类可以通过调用父类的构造器来完成对继承的父类的初始化操作。</strong> <strong>在子类的构造器中可以使用关键字super来调用父类的构造器，并传递相应的参数。</strong>这样可以确保父类的构造器得到正确地执行，从而完成对父类属性的初始化。 </p>
<p>总结起来，<strong>构造器本身不能被重写，但子类可以通过调用父类的构造器来实现对父类的初始化操作。</strong></p>
<h3 id="18-如何实现对象克隆⭐⭐⭐"><a href="#18-如何实现对象克隆⭐⭐⭐" class="headerlink" title="18. 如何实现对象克隆⭐⭐⭐"></a>18. 如何实现对象克隆⭐⭐⭐</h3><p>在Java中，实现对象的克隆有两种方式: 浅拷贝和深拷贝。 </p>
<ol>
<li>浅拷贝：通过创建一个新对象，并将原对象的非静态字段值复制给新对象实现。新对象和原对象共享引用数据。在Java中，可以使用clone()方法实现浅拷贝。要实现一个类的克隆操作，需要满足以下条件： <ol>
<li><strong>实现Cloneable接口。</strong> </li>
<li>重写Object类的clone()方法，声明为public访问权限。 </li>
<li>在clone()方法中调用super.clone()，并处理引用类型字段。</li>
</ol>
</li>
<li>深拷贝：<strong>通过创建一个新对象，并将原对象的所有字段值复制给新对象，包括引用类型数据。</strong>新对象和原对象拥有独立的引用数据。实现深拷贝有以下方式:<ol>
<li>使用序列化和反序列化实现深拷贝，要求对象及其引用类型字段实现Serializable接口。 </li>
<li>自定义拷贝方法，<strong>递归拷贝引用类型字段</strong>。</li>
</ol>
</li>
</ol>
<h3 id="19-synchronized关键字⭐⭐⭐"><a href="#19-synchronized关键字⭐⭐⭐" class="headerlink" title="19. synchronized关键字⭐⭐⭐"></a>19. synchronized关键字⭐⭐⭐</h3><p>synchronized关键字<strong>解决的是多个线程之间访问资源的同步性</strong>，synchronized关键字可以<strong>保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</p>
<p><strong>用法：</strong></p>
<p><strong>同步方法</strong>：当一个方法被声明为<code>synchronized</code>时，它会在同一个对象上创建一个监视器锁。当一个线程进入这个方法时，它会获取这个锁，而其他线程则会被阻塞，直到锁被释放。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>同步代码块</strong>：同步代码块可以更灵活地指定需要同步的代码块，以及使用的监视器对象.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object) {</span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>同步静态方法</strong>：当一个静态方法被声明为<code>synchronized</code>时，它会在类的Class对象上创建一个监视器锁。这意味着同一时刻，只有一个线程可以执行这个类的任何<code>synchronized</code>静态方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 同步静态代码块</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>同步静态代码块</strong>：同步静态代码块可以在类加载时同步，通常用于初始化类的静态成员。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (MyClass.class) {</span><br><span class="line">        <span class="comment">// 同步静态代码块</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h4><p><strong>synchronized是Java语言中最基本的线程同步机制，它通过<font color="red">互斥锁</font>来控制线程对共享变量的访问。</strong> 具体实现原理如下： </p>
<ul>
<li>synchronized的实现基础是<strong>对象内部的锁（也称为监视器锁或管程），每个锁关联着一个对象实例</strong>。 </li>
<li>当<strong>synchronized作用于某个对象时，它就会尝试获取这个对象的锁，如果锁没有被其他线程占用，则当前线程获取到锁，并可以执行同步代码块；如果锁已经被其他线程占用，那么当前线程就会阻塞在同步块之外，直到获取到锁才能进入同步块</strong>。  — 尝试获取锁</li>
<li><strong>synchronized还支持作用于类上，此时它锁住的是整个类，而不是类的某个实例</strong>。在这种情况下，由于只有一个锁存在，所以所有使用该类的线程都需要等待锁的释放。 </li>
<li>在JVM内部，每个Java对象都有头信息，其中包含了对象的一些元信息和状态标志。<strong>synchronized通过修改头信息的状态标志来实现锁的获取和释放。</strong> </li>
<li>synchronized还<strong>支持可重入性，即在同一个线程中可以多次获取同一个锁，这样可以避免死锁问题。</strong> </li>
<li>Java虚拟机会<strong>通过锁升级的方式来提升synchronized的效率，比如偏向锁、轻量级锁和重量级锁等机制，使得在竞争不激烈的情况下，synchronized的性能可以达到与非同步代码相当的水平。</strong></li>
</ul>
<h4 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h4><p>synchronized还有一种重要的优化方式，即锁的优化技术。在Java 6及以上版本中，JVM引入了偏向锁、轻量级锁和重量级锁的概念来提高锁的性能。这些优化方式的原理如下：</p>
<ol>
<li><strong>偏向锁：</strong>偏向锁是指<strong>当一个线程获取到锁之后，会在对象头中记录下该线程的标识，下次再进入同步块时，无需进行额外的加锁操作，从而提高性能。</strong> </li>
<li><strong>轻量级锁：</strong>当多个线程对同一个锁进行争夺时，JVM会使用轻量级锁来避免传统的重量级锁带来的性能消耗。它采用自旋的方式，即不放弃CPU的执行时间，尝试快速获取锁，避免线程阻塞和上下文切换的开销。 </li>
<li><strong>重量级锁：</strong>当多个线程对同一个锁进行强烈争夺时，JVM会升级为重量级锁，此时线程会进入阻塞状态，等待锁的释放。这种方式适用于竞争激烈的情况，但会带来较大的性能开销。</li>
</ol>
<p>锁优化技术是为了提高synchronized的并发性能，根据锁的竞争程度和持有时间的长短选择相应的锁状态，使得多个线程能够更高效地共享资源。</p>
<p>[注] synchronized 关键字<strong>加到static静态方法和synchronized(calss)代码块上都是给类上锁</strong>，synchronized关键字<strong>加到实例方法上和synchronized(this)都是给实例对象枷锁</strong>。<strong>静态 synchronized 方法和非静态 synchronized 方法之间的调用不互斥</strong>。因为访问<strong>静态 synchronized 方法占用的锁是当前类的锁</strong>，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</p>
<h3 id="20-谈谈你对ThreadLocal的理解-star-star-star-—-多线程"><a href="#20-谈谈你对ThreadLocal的理解-star-star-star-—-多线程" class="headerlink" title="20. 谈谈你对ThreadLocal的理解 :star::star::star: — 多线程"></a>20. 谈谈你对ThreadLocal的理解 :star::star::star: — 多线程</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在多线程环境下，我们经常需要处理共享资源的访问问题。通常，我们会通过加锁来保证资源的一致性，但这会增加性能开销。 而<span class="strong">**ThreadLocal提出了一个新颖的解决方案——“空间换时间”。 它为每个线程创建了一个独立的存储空间，也就是 ThreadLocalMap，用来存放线程私有的变量副本。**</span> </span><br></pre></td></tr></tbody></table></figure>

<p><strong>ThreadLocal是一种巧妙的多线程隔离机制。</strong> ThreadLocal是Java中的一个类，<strong>用于在多线程环境下实现线程局部变量存储</strong>。</p>
<p>在多线程编程中，<strong>共享变量的访问往往需要考虑线程安全性和数据隔离问题</strong>。<strong>ThreadLocal通过为每个线程创建独立的变量副本来解决这些问题。</strong>每个线程可以独立地对自己的变量副本进行操作，而不会影响其他线程的副本，从而避免了多线程之间相互干扰和竞争的问题。  </p>
<p>【原理】：<strong>每 个 Thread 中都具备一个ThreadLocalMap，而 ThreadLocalMap 可以存储以 Thread对象为 key，Object 对象为 value的键值对。</strong></p>
<p>ThreadLocal的<strong>核心思想是以”线程”为作用域，在每个线程内部维护一个变量副本。</strong> <strong>它使用Thread对象作为Key，在内部的数据结构中查找对应的变量副本。</strong> <strong>当通过ThreadLocal的get()方法获取变量时，实际上是根据当前线程获取其对应的变量副本；当通过set()方法设置变量时，实际上是将该值与当前线程关联，并存储在内部的数据结构中。</strong> </p>
<p>使用ThreadLocal时需要注意以下几点： </p>
<ol>
<li><strong>内存泄漏：</strong>在使用完ThreadLocal后，<strong>应及时调用remove()方法清理与当前线程相关的变量副本，避免长时间持有引用导致内存泄漏。</strong></li>
<li><strong>线程安全性：</strong>ThreadLocal本身并不解决多线程并发访问共享变量的问题，需要额外的同步机制来保证线程安全性。 </li>
<li><strong>数据隔离：</strong>ThreadLocal适用于多线程环境下需要保持变量独立性的场景，可以避免使用传统的同步方式对共享变量进行操作，提高并发性能。</li>
</ol>
<p><strong>ThreadLocal常见的应用场景包括线程池、Web开发中的请求上下文信息管理、数据库连接管理和日志记录等。</strong>通过合理使用ThreadLocal，可以简化多线程编程，并提高程序的性能和可维护性。</p>
<h4 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h4><p>ThreadLocal是Java中的一个类，它提供了一种在多线程环境下实现线程局部变量存储的机制。 它的应用场景包括<strong>线程池、Web开发中的请求上下文信息管理、数据库连接管理和日志记录等等。</strong> </p>
<p><strong>在线程池中，可以使用ThreadLocal为每个线程维护独立的上下文信息，避免线程间互相干扰。</strong> </p>
<p><strong>在Web开发中，可以使用ThreadLocal存储当前请求的上下文信息，避免参数传递的复杂性。</strong> </p>
<p><strong>在数据库连接管理中，ThreadLocal可以为每个线程保持独立的数据库连接，提高并发性能。</strong> </p>
<p><strong>事务管理</strong>，在复杂的事务处理场景中，<strong>ThreadLocal可以帮助我们存储和管理事务状态，确保每个线程可以独立控制自己的事务流程。</strong> </p>
<p>在日志记录中，ThreadLocal可以将日志记录与当前线程关联起来，方便追踪和排查问题。 </p>
<p>此外，<strong>ThreadLocal还可以用于在线程之间传递全局的上下文信息。</strong> </p>
<p>在使用ThreadLocal时需要注意内存泄漏问题和线程安全性，及时清理不再需要的变量副本，并采取适当的同步措施保证线程安全。通过合理使用ThreadLocal，可以简化多线程编程，提高程序的性能和可维护性。</p>
<h4 id="ThreadLocal如何防止内存泄漏"><a href="#ThreadLocal如何防止内存泄漏" class="headerlink" title="ThreadLocal如何防止内存泄漏"></a>ThreadLocal如何防止内存泄漏</h4><p>ThreadLocal 变量的内存泄漏问题主要是由于 ThreadLocalMap 中的 Entry 没有被及时清理导致的。ThreadLocalMap 是 ThreadLocal 的底层数据结构，它用于存储每个线程独立的变量副本。 要防止 ThreadLocal 内存泄漏，可以考虑以下方法：</p>
<ul>
<li><strong>使用完 ThreadLocal 后及时调用 remove() 方法</strong>：在不再需要使用 ThreadLocal 存储的数据时，手动调用 ThreadLocal.remove() 方法将该数据从当前线程的 ThreadLocalMap 中清除。这样可以确保 ThreadLocalMap 不会持有对对象的引用，从而帮助垃圾回收器正常回收不再需要的对象。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line">threadLocal.set(someData);</span><br><span class="line"><span class="comment">// 使用完毕后清除</span></span><br><span class="line">threadLocal.remove();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>使用 try-with-resources 或 try-finally 块</strong>：如果你的 ThreadLocal 变量在需要清理的资源管理上下文中使用，可以使用 try-with-resources（自动清理）或 try-finally（手动清理）块来确保及时清理。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line"><span class="title function_">try</span> <span class="params">(ThreadLocalResource resource = new ThreadLocalResource()</span>) {</span><br><span class="line">    <span class="comment">// 使用 ThreadLocalResource</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 或者使用 try-finally</span></span><br><span class="line"><span class="type">ThreadLocalResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalResource</span>();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 使用 ThreadLocalResource</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    resource.close(); <span class="comment">// 在 close 方法中清理 ThreadLocal 变量</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>使用 InheritableThreadLocal：</strong>如果需要在子线程中访问父线程的 ThreadLocal 变量，并且确保在子线程中正确清理，可以考虑使用 InheritableThreadLocal。这个类允许子线程继承父线程的 ThreadLocal 变量，并在子线程完成后自动清理。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">threadLocal.set(<span class="string">"Hello, Parent Thread"</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">childTask</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 子线程可以访问父线程的 ThreadLocal 变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">};</span><br><span class="line"><span class="type">Thread</span> <span class="variable">childThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(childTask);</span><br><span class="line">childThread.start();</span><br></pre></td></tr></tbody></table></figure>

<p>通过采取这些预防措施，可以有效避免 ThreadLocal 变量的内存泄漏问题，确保不再需要的对象能够被及时回收。</p>
<h3 id="21-谈谈你对CountDownLatch的理解"><a href="#21-谈谈你对CountDownLatch的理解" class="headerlink" title="21. 谈谈你对CountDownLatch的理解"></a>21. 谈谈你对CountDownLatch的理解</h3><p>CountDownLatch是Java中用于多线程协作的辅助类，<strong>它可以让一个或多个线程等待其他线程完成某个任务后再继续执行。</strong> </p>
<p><strong>CountDownLatch通过一个计数器来实现，计数器的初始值可以设置为等待的线程数量</strong>。每个线程在完成任务后都会调用countDown()方法来减少计数器的值。当计数器的值减至0时，等待在CountDownLatch上的线程就会被唤醒，可以继续执行后续的操作。 </p>
<p>CountDownLatch的<strong>主要作用是协调多个线程的执行顺序，使得某个线程（或多个线程）必须等待其他线程完成后才能继续执行。</strong>它常用于以下场景： </p>
<ol>
<li>主线程等待多个子线程完成任务：主线程可以使用await()方法等待所有子线程完成，然后进行结果的汇总或其他操作。 </li>
<li>多个线程等待外部事件的发生：多个线程可以同时等待某个共同的事件发生，比如等待某个资源准备就绪或者等待某个信号的触发。 </li>
<li>控制并发任务的同时开始：在某些并发场景中，需要等待所有线程都准备就绪后才能同时开始执行任务，CountDownLatch提供了一种便捷的方式来实现这一需求。</li>
</ol>
<p>需要注意的是，<strong>CountDownLatch的计数器是不能被重置的，也就是说它是一次性的。</strong>一旦计数器减至0，它将无法再次使用。如果需要多次使用可重置的计数器，则可以考虑使用CyclicBarrier。</p>
<h3 id="22-谈谈你对CyclicBarrier的理解"><a href="#22-谈谈你对CyclicBarrier的理解" class="headerlink" title="22. 谈谈你对CyclicBarrier的理解"></a>22. 谈谈你对CyclicBarrier的理解</h3><p><strong>CyclicBarrier是Java中的一个多线程协作工具，它可以让多个线程在一个屏障点等待，并在所有线程都到达后一起继续执行。</strong> 与CountDownLatch不同，CyclicBarrier可以重复使用，并且可以指定屏障点后执行的额外动作。 </p>
<p>CyclicBarrier的主要特点有三个：</p>
<ol>
<li>首先，<strong>它可以重复使用，这意味着当所有线程都到达屏障点后，屏障会自动重置，可以用来处理多次需要等待的任务。</strong> </li>
<li>其次，<strong>CyclicBarrier可以协调多个线程同时开始执行，这在分阶段任务和并发游戏等场景中非常有用。</strong> </li>
<li>最后，CyclicBarrier还提供了可选的动作，在所有线程到达屏障点时执行，可以实现额外的逻辑。</li>
</ol>
<p>需要注意的是，在创建CyclicBarrier时需要指定参与线程的数量。一旦所有参与线程都到达屏障点后，CyclicBarrier解除阻塞，所有线程可以继续执行后续操作。</p>
<h1 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h1><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240428194221441.png" alt="image-20240428194221441"></p>
<h3 id="1-JVM内存模型"><a href="#1-JVM内存模型" class="headerlink" title="1. JVM内存模型"></a>1. JVM内存模型</h3><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240429125336432.png" alt="image-20240429125336432"></p>
<p><strong>JVM 内存结构</strong>指的就是上文提交到<strong>运行时数据区</strong>，其中<em>堆</em>、<em>方法区</em>被<strong>线程共享</strong>，<em>程序计数器</em>、<em>栈</em>、<em>运行时常量池</em>被<strong>线程独享</strong>。</p>
<h4 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1. 运行时数据区"></a>1. 运行时数据区</h4><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p>
<p>包括<strong>堆，方法区，虚拟机栈，本地方法栈，程序计数器</strong></p>
<p>线程独占：<strong>虚拟机栈、本地方法栈、程序计数器；</strong></p>
<p>线程共享：<strong>堆、方法区</strong> </p>
<p>jdk1.7–&gt;jdk1.8: 方法区由堆中转移到本地内存，改名为元空间</p>
<h4 id="2-虚拟机栈：线程私有"><a href="#2-虚拟机栈：线程私有" class="headerlink" title="2. 虚拟机栈：线程私有"></a>2. 虚拟机栈：线程私有</h4><p><strong>方法栈</strong>，线程私有，用来存储<strong>局部变量表，操作数栈，动态链接方法，返回值、返回地址</strong>等信息；调用方法时执行入栈，方法返回时执行出栈。</p>
<h5 id="2-1-栈帧有哪些组成"><a href="#2-1-栈帧有哪些组成" class="headerlink" title="2.1. 栈帧有哪些组成"></a>2.1. 栈帧有哪些组成</h5><p>栈帧（Stack Frame）是虚拟机栈（Java Virtual Machine Stacks）中的一个单位，用于存储方法的执行状态。每个栈帧对应一个方法执行的实例，它包含了方法执行所需的信息。栈帧的组成部分通常包括以下几个关键部分：</p>
<ol>
<li><strong>局部变量表（Local Variable Table）</strong>：<ul>
<li>局部变量表<strong>用于存储方法声明中的局部变量</strong>，包括<strong>基本数据类型</strong>（如int、float、double、byte、short、char、boolean）和<strong>对象引用</strong>（指向对象实例的引用）。</li>
<li>局部变量表中的每个槽位（slot）对应一个局部变量，其中槽位可以被重用，这意味着不同的方法可以共享同一个槽位。</li>
</ul>
</li>
<li><strong>操作数栈（Operand Stack）</strong>：<ul>
<li>操作数栈<strong>用于存储计算过程中的中间结果</strong>，以及进行方法调用的参数和返回值。</li>
<li>操作数栈的大小可以动态调整，以适应方法执行的需要。</li>
</ul>
</li>
<li><strong>动态链接（Dynamic Linking）</strong>：<ul>
<li>动态链接用于<strong>支持方法调用过程中的符号引用（如类名、方法名和字段名）到直接引用的转换。</strong></li>
<li>每个栈帧都包含了对运行时常量池的引用，以便在执行过程中进行动态链接。</li>
</ul>
</li>
<li><strong>方法返回地址（Return Address）</strong>：<ul>
<li>方法返回地址<strong>用于存储方法调用结束后应该返回的指令地址。</strong></li>
<li>方法返回时，栈帧会将方法返回地址压入调用栈，以便返回到调用者的控制流。</li>
</ul>
</li>
<li><strong>附加信息（Additional Information）</strong>：<ul>
<li>栈帧可能包含其他附加信息，如<strong>异常处理表、调试信息</strong>等。</li>
</ul>
</li>
</ol>
<p><strong>每个栈帧都是线程私有的，当一个方法开始执行时，会创建一个新的栈帧并将其压入虚拟机栈。方法执行完毕后，对应的栈帧会被销毁，释放内存。</strong></p>
<h4 id="3-本地方法栈：线程私有"><a href="#3-本地方法栈：线程私有" class="headerlink" title="3. 本地方法栈：线程私有"></a>3. 本地方法栈：线程私有</h4><p>与栈类似,也是用来保存执行方法的信息.执行Java方法是使用虚拟机栈,执行Native方法时使用本地方法栈.</p>
<h4 id="4-程序计数器：线程私有"><a href="#4-程序计数器：线程私有" class="headerlink" title="4. 程序计数器：线程私有"></a>4. 程序计数器：线程私有</h4><p><strong>保存着当前线程执行的字节码位置</strong>，<strong>每个线程工作时都有独立的计数器</strong>，只为执行Java方法服务，执行Native方法时，程序计数器为空。</p>
<p>当同时进行的线程数超过CPU数或其内核数，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。</p>
<h4 id="5-堆：线程共享"><a href="#5-堆：线程共享" class="headerlink" title="5. 堆：线程共享"></a>5. 堆：线程共享</h4><p>JVM内存管理最大的一块,对被线程共享,目的是<strong>存放对象的实例</strong>和<strong>数组</strong>，几乎所有的对象实例都会放在这里。当堆没有可用空间时,会抛出OOM（<code>OutOfMemoryError</code>）异常。根据对象的存活周期不同,JVM把对象进行<strong>分代管理</strong>,由垃圾回收器进行垃圾的回收管理。</p>
<h4 id="6-方法区：线程共享"><a href="#6-方法区：线程共享" class="headerlink" title="6. 方法区：线程共享"></a>6. 方法区：线程共享</h4><p>用于<strong>存储已被虚拟机加载的类信息，常量池，静态变量，即时编译器优化后的代码等数据</strong>。被元空间取代，元空间使用本地内存而不是JVM堆内存。这个改变是为了减少JVM堆内存的压力，尤其是对于大型应用程序和长期运行的JVM实例。 1.7的永久代和1.8的元空间都是方法区的一种实现。</p>
<h3 id="2-Java内存模型-JMM"><a href="#2-Java内存模型-JMM" class="headerlink" title="2. Java内存模型 JMM"></a>2. Java内存模型 JMM</h3><p>JMM（Java Memory Model）,它是Java虚拟机规范的一部分，用于描述Java程序中各种变量的读取和写入如何在主内存（Main Memory）和线程工作内存（Thread Local Memory）之间交互的规则。</p>
<p>:star:JMM的主要目的是<strong>解决并发编程中的一些问题，如数据一致性、可见性和原子性</strong>。它<strong>确保了即使在多线程环境下，Java程序中的变量也能正确地被访问和修改。</strong></p>
<p>JMM定义了以下几个关键概念：</p>
<ol>
<li><strong>主内存（Main Memory）</strong>：<strong>主内存是共享内存区域，其中包含了Java程序的静态变量、实例变量和数组元素。所有线程都可以访问主内存。</strong> <strong>方法区</strong>、<strong>堆</strong></li>
<li><strong>工作内存（Thread Local Memory）</strong>：工作内存是每个线程私有的内存区域，包含了该线程使用到的变量的副本拷贝。每个线程只能访问自己的工作内存，不能直接访问其他线程的工作内存。<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong></li>
<li><strong>原子性（Atomicity）</strong>： <strong>JMM确保对主内存的读取和写入操作都是原子性的，即不会被中断</strong>。</li>
<li><strong>可见性（Visibility）</strong>：当一个线程修改了主内存中的变量时，JMM确保其他线程能够立即看到这些修改。</li>
<li><strong>有序性（Ordering）</strong>：JMM确保所有的操作都按照程序的顺序来执行，但是JMM允许特定的优化，如指令重排，只要结果对其他线程是可见的。</li>
</ol>
<p>JMM通过一系列规则和机制来实现上述概念，包括<strong>volatile关键字、synchronized关键字、happens-before原则、锁（Lock）和内存屏障（Memory Barrier）</strong>等。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240428200833104.png" alt="image-20240428200833104"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240428200918405.png" alt="image-20240428200918405"></p>
<h3 id="3-类的加载与卸载"><a href="#3-类的加载与卸载" class="headerlink" title="3. 类的加载与卸载"></a>3. 类的加载与卸载</h3><p><strong>加载过程</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240509164842051.png" alt="image-20240509164842051"></p>
<p><strong>加载</strong>：通过类的全限定名，查找此类字节码文件，利用字节码文件常见Class对象</p>
<p><strong>验证</strong>：验证是链接操作的第一步，它的目的是<strong>保证</strong>加载的字节码是<strong>合法</strong>、<strong>合理</strong>并<strong>符合规范</strong>的。验证的内容则涵盖了类数据信息的<strong>格式验证</strong>、<strong>语义检查</strong>、<strong>字节码验证</strong>，以及<strong>符号引用验证</strong>等。</p>
<p><strong>准备</strong>：进行内存分配，<strong>为static修饰的类变量分配内存</strong>,并<strong>设置初始值</strong>(0或null).不包含final修饰的静态变量,因为<strong>final变量在编译时分配</strong>。</p>
<p><strong>解析</strong>：将常量池中的<strong>符号引用替换为直接引用</strong>的过程. <strong>直接引用为直接指向目标的指针或者相对偏移量</strong>等。</p>
<p><strong>初始化</strong>：主要<strong>完成静态块执行及静态变量的赋值</strong>，<strong>先初始化父类，再初始化当前类</strong>。只有对类主动使用时才会初始化。</p>
<p>触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用<code>Class.forName</code>反射类的时候,或者某个子类初始化的时候.</p>
<p><strong>Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸。</strong></p>
<h3 id="4-类的加载机制-—-双亲委派模式-—-tomcat类加载"><a href="#4-类的加载机制-—-双亲委派模式-—-tomcat类加载" class="headerlink" title="4. 类的加载机制 —- 双亲委派模式 — tomcat类加载"></a>4. 类的加载机制 —- 双亲委派模式 — tomcat类加载</h3><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240809195521280" style="zoom:80%;">



<p>双亲委派模型是Java实现类隔离和安全性的一种机制，它保证了Java程序的稳定性和安全性。</p>
<p>双亲委派模型（Parent Delegation Model）是Java类加载器（<code>ClassLoader</code>）体系的一个重要特征，它<strong>描述了类加载器之间的层次关系和类加载的顺序</strong>。</p>
<p>在Java中，类加载器分为几种类型，包括</p>
<ul>
<li><strong>启动类加载器（<code>Bootstrap ClassLoader</code>）</strong>：这是Java虚拟机的一部分，<strong>负责加载JRE的核心类库</strong>，如<code>java.lang</code>包下的类。</li>
<li><strong>扩展类加载器(<code>Extension ClassLoader</code>)<strong>：这个类加载器由Java虚拟机实现，</strong>负责加载JRE扩展目录中类库</strong>，以及java.ext.dirs系统属性指定的路径中的类库。</li>
<li><strong>应用程序类加载器（<code>Application ClassLoader</code>）</strong>：这个类加载器由Java应用启动时自动创建，<strong>负责加载用户类路径（class path）上指定的类库</strong>。</li>
<li><strong>自定义类加载器（<code>Custom ClassLoader</code>）</strong>:这是由开发者自定义的类加载器，用于加载特定路径下的类库。</li>
</ul>
<p>双亲委派模型的<strong>核心思想</strong> —- <strong>当一个类加载器需要加载一个类时，它首先将这个请求委派给父类加载器去完成，只有当父类加载器无法加载该类时，才尝试自己去加载</strong>。这样可以【<strong>避免类重复加载，保证类的唯一性；保护程序安全，防止核心库被修改；</strong>】</p>
<p>双亲委派模型的<strong>大致流程</strong> === 当<code>AppClassLoader</code>加载一个class时，<strong>它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成</strong>，当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。如果BootStrapClassLoader 加载失败（例如在$JAVA_HOME/jre/lib 里未查找到该class）会使用ExtClassLoader来尝试加载，若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常。</p>
<p><strong>双亲委派模型规定了类加载的顺序，即从父类加载器开始，逐步向子类加载器委派。</strong></p>
<p><strong>优点：</strong>避免类重复加载，<strong>保证类的唯一性</strong>；保护程序安全，<strong>防止核心库被修改</strong>；</p>
<p><strong>缺点：</strong> <strong>顶层的ClassLoader无法访问底层的ClassLoader</strong>。 父类和子类是包含关系，父类作为一个参数传递给子类</p>
<p>【注】当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
<h4 id="双亲委派机制可以打破吗？如何打破？"><a href="#双亲委派机制可以打破吗？如何打破？" class="headerlink" title="双亲委派机制可以打破吗？如何打破？"></a>双亲委派机制可以打破吗？如何打破？</h4><p>双亲委派并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<ol>
<li>**不用loadClass(), 重写findClass()  — **设计者在 java.lang.<strong>ClassLoader</strong> <strong>中</strong>添加一个新的 <strong>protected</strong> <strong>方法</strong> <strong>findClass()<strong>，并引导用户编写的类加载逻辑时尽可能去</strong>重写这个方法</strong>，而不是在loadClass()中编写代码。（双亲委派的具体逻辑就实现在 loadClass()方法里面，按照 loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的 findClass()方法完成加载）</li>
<li><strong>线程上下文类加载器 —</strong> 这类加载器默认是应用程序加载器，通过java.lang.Thread类的setContextClassLoader()方法进行设置。这是一种<strong>父类加载器去请求子类加载器完成类加载的行为</strong>，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器。</li>
<li><strong>代码热替换、模块热部署 —</strong> 每一个程序模块(OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</li>
</ol>
<h4 id="Tomcat类加载机制"><a href="#Tomcat类加载机制" class="headerlink" title="Tomcat类加载机制"></a>Tomcat类加载机制</h4><p>Tomcat的类加载机制是违反双亲委派原则的，对于一些<strong>未加载的非基础类</strong>，<strong>各个web应用自己的类加载器(WebAppClassLoader)会优先查看自己的仓库</strong>加载，<strong>加载不到时</strong>再交给commonClassLoader<strong>走双亲委派</strong>。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240731112045650.png" alt="image-20240731112045650"></p>
<p> tomcat 启动时，会创建几种类加载器：<br>1）Bootstrap 引导类加载器：<strong>加载 JVM 启动所需的类</strong>，以及标准扩展类（位于 jre/lib/ext 下）<br>2）System 系统类加载器：<strong>加载 tomcat 启动的类</strong>，比如 bootstrap.jar，通常在 catalina.bat 或者 catalina.sh 中指定。位于CATALINA_HOME/bin 下。<br>3）CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和 WebappClassLoader这些是 Tomcat 自己定义的类加载器，它们分别加载 **/common/*、/server/*、/shared/***（在tomcat 6 之后已经合并到根目录下的 lib 目录下）和/WebApp/WEB-INF/*中的 Java 类库。</p>
<p>其中 WebApp 类加载器和 Jsp 类加载器通常会存在多个实例，每一个 Web 应用程序对应一个 WebApp 类加载器，每一个 JSP 文件对应一个 Jsp 类加载器。<br>从图中的委派关系中可以看出：<br>1）<strong>CommonClassLoader 能加载的类都可以被Catalina ClassLoader 和 SharedClassLoader 使用，从而实现了公有类库的共用</strong>，<strong>而CatalinaClassLoader 和 Shared ClassLoader 自己能加载的类则与对方相互隔离</strong>。</p>
<p>2）<strong>WebAppClassLoader 用 SharedClassLoader加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。</strong><br>3）而 JasperLoader 的加载范围仅仅是这个JSP 文件所编译出来的那一个.class 文件，它出现的目的就是为了被丢弃：当 Web 容器检测到 JSP 文件被修改时，会替换掉目前的JasperLoader 的实例，并通过再建立一个新的 Jsp 类加载器来实现 JSP 文件的 HotSwap功能。</p>
<p>当应用需要到某个类时，则会按照下面的顺序进行类加载：</p>
<ol>
<li><p>使用 bootstrap 引导类加载器加载；</p>
</li>
<li><p>使用 system 系统类加载器加载；</p>
</li>
<li><p>使用应用类加载器在 WEB-INF/classes 中加载；</p>
</li>
<li><p>使用应用类加载器在 WEB-INF/lib 中加载；</p>
</li>
<li><p>使 用 common 类加载器 在CATALINA_HOME/lib 中加载。</p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240731112840211" style="zoom: 50%;"></li>
</ol>
<p>【总结】tomcat 为了实现隔离性，没有遵守这个约定，<strong>每个 webappClassLoader 加载自己的目录下的 class 文件，不会传递给父类加载器。</strong></p>
<h4 id="tomcat为什么要自定义类加载器"><a href="#tomcat为什么要自定义类加载器" class="headerlink" title="tomcat为什么要自定义类加载器"></a>tomcat为什么要自定义类加载器</h4><p>tomcat是个web容器，一个web容器可能要部署多个应用程序，不同的应用程序之间可能会依赖同一个第三方库的不同版本，不能要求同一个类库在同一个服务器只有一份，所以tomcat要具有<strong>隔离性</strong>，每个服务都是独立的。同一个web容器的多个应用程序的同一个第三方库的版本可能相同，但是不能要求同一版本的类库在每个服务器都有一份，所以tomcat要具有<strong>共享性</strong>。web容器也有自己依赖的类库，不能与应用程序的类库混淆，出于安全性能考虑，应该让容器的类库和程序的类库隔离开来。</p>
<h3 id="10-分代回收"><a href="#10-分代回收" class="headerlink" title="10. 分代回收"></a>10. 分代回收</h3><p>分代回收基于<strong>两个事实</strong>：大部分对象很快就不使用了，还有一部分不会立即无用，但也不会持续很长时间</p>
<p><strong>年轻代-&gt;标记-复制 老年代-&gt;标记-清除</strong></p>
<h3 id="11-垃圾回收"><a href="#11-垃圾回收" class="headerlink" title="11. 垃圾回收"></a>11. 垃圾回收</h3><p><strong>定义</strong>： <strong>垃圾</strong>是指在<strong>运行程序中没有任何指针指向的对象</strong>。不及时进行垃圾清理会导致垃圾对象所占的内存空间一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至<strong>可能导致内存溢出</strong>。<strong>废弃常量</strong> 指<strong>没有任何String对象引用该字符串常量</strong>。</p>
<p><strong>判断一个类是无用的类：</strong>满足三个条件—&gt;1. 该类的<strong>所有实例都已经被回收</strong>；2. 加载该类的<strong>ClassLoader已经被回收</strong>；3.该类对应的java.lang.Class对象没有任何地方被引用，<strong>无法在任何地方通过反射访问该类的方法</strong>。</p>
<p><strong>垃圾判断算法： 1. 引用计数算法；2. 可达性分析算法</strong></p>
<p>引用计数算法存在循环引用的问题</p>
<p><strong>可以作为GCRoot的对象</strong>：<strong>虚拟机栈中引用的对象；</strong> <strong>本地方法栈</strong>内 JNI(本地方法)引用的对象；<strong>类静态属性引用的对象</strong>；<strong>方法区</strong>中常量引用的对象；所有<strong>被同步锁 synchronized 持有的对象</strong>；<strong>Java 虚拟机内部的引用</strong>；反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</p>
<h4 id="1-垃圾收集算法"><a href="#1-垃圾收集算法" class="headerlink" title="1. 垃圾收集算法"></a>1. 垃圾收集算法</h4><p>当涉及到Java虚拟机的垃圾回收时，通常会使用以下几种垃圾收集算法：</p>
<ol>
<li><strong>标记-清除算法（Mark-Sweep）</strong>：这是最基本的垃圾收集算法之一。首先，它会标记所有可达对象，然后清除所有未被标记的对象。这种算法的主要问题是<strong>会产生内存碎片，影响内存的连续分配</strong>。</li>
<li><strong>标记-复制算法（Mark-Copy）</strong>：这种算法将堆空间划分为两个区域：一个用于存活对象，另一个用于新对象分配。垃圾收集器首先标记所有存活对象，然后将它们复制到另一个区域中，并且在复制过程中会进行内存整理。这种算法的优点是避免了内存碎片问题，但是需要额外的空间来存储复制后的对象。</li>
<li><strong>标记-整理算法（Mark-Sweep-Compact）</strong>：这种算法结合了标记-清除和标记-复制的思想。首先，它会标记所有存活对象，然后清除未被标记的对象，并将存活对象向一端移动，以便整理内存空间，消除内存碎片。</li>
<li><strong>分代收集算法（Generational Collection）</strong>：这种算法将堆空间划分为几个不同的代（Generation），一般是年轻代和老年代。大部分对象都是在年轻代中被分配，而老年代主要存放长期存活的对象。分代收集算法利用了对象的生命周期分布，对不同代使用不同的垃圾收集算法，以提高垃圾收集效率。一般来说，年轻代使用标记-复制算法，而老年代使用标记-清除或标记-整理算法。</li>
<li><strong>增量式垃圾收集算法（Incremental Garbage Collection）</strong>：这种算法将整个垃圾收集过程分成多个阶段，在每个阶段中只处理一小部分的对象，然后让程序继续执行。增量式垃圾收集可以降低垃圾收集过程对应用程序的停顿时间，但也会增加垃圾收集器的复杂性和开销。</li>
</ol>
<p>Java虚拟机提供了多种垃圾回收器，每种回收器都有其特点和适用场景。例如，<strong>Serial GC是串行收集器，适合单线程环境；Parallel GC是并行收集器，适合多核处理器环境；CMS（Concurrent Mark Sweep）收集器适合低延迟的垃圾回收；G1（Garbage-First）收集器适合大型堆和多核处理器环境；ZGC（Z Garbage Collector）收集器旨在为高吞吐量应用程序提供低延迟的垃圾回收</strong>。</p>
<h4 id="2-常见垃圾收集器"><a href="#2-常见垃圾收集器" class="headerlink" title="2. 常见垃圾收集器"></a>2. 常见垃圾收集器</h4><p>:blue_heart:<strong>CMS收集器（两次停顿）</strong></p>
<ul>
<li><p>CMS 收集器是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。它非常符合在注重用户体验的应用上使用。</p>
</li>
<li><p>CMS 收集器是 HotSpot 虚拟机第一款真正意义上的<strong>并发收集器</strong>，它第一次<strong>实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。</p>
</li>
<li><p>CMS 收集器是“标记-清除”算法实现：</p>
<ul>
<li><strong>初始标记：</strong> <strong>暂停所有的其他线程（STW 时间非常短）</strong>，标记与 GC Roots 直接关联的对象；（注意，后面引用的对象不管）、</li>
<li><strong>并发标记：</strong>从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记：</strong>为了<strong>修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>（主要关注不可达变可达的对象），这个阶段的<strong>停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</strong></li>
<li><strong>并发清除：</strong>开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p>【注】: 标记清理会出现碎片，为啥不用压缩？当并发清理的时候，<strong>如果压缩整理内存的话，用户线程原来使用的内存资源无法访问使用。</strong></p>
</li>
</ul>
<p>CMS 优点：并发收集、低延迟；</p>
<p>CMS 缺点：1&gt;<strong>产生内存碎片</strong>；2&gt;对 <strong>CPU 资源非常敏感</strong>，总吞吐量降低；3&gt;无法处理浮动垃圾，<strong>并发标记阶段可能产生新的垃圾对象无法被标记到</strong>（可达变不可达），不能被清理。</p>
<p>:blue_heart:<strong>G1垃圾回收器（Garbage-First）</strong></p>
<p>G1（Garbage-First）垃圾回收器是Java 7引入的一种垃圾回收算法，它是面向服务端应用的垃圾回收器，特别适合于多处理器和大容量内存环境。G1回收器将堆内存划分为多个独立的区域（Region），并为每个区域分配一个优先级，垃圾回收器优先回收优先级最高的区域。</p>
<p>G1垃圾收集器的运行过程大致可划分为四个步骤：</p>
<ul>
<li><strong>初始标记(initial mark)<strong>：</strong>标记了从GC Root开始直接关联可达的对象</strong>（存活对象）。STW（Stop The World）执行</li>
<li>**并发标记(concurrent marking)**：和用户线程并发执行，从GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。</li>
<li>**最终标记(Remark)**：STW, 标记在并发标记过程中产生的垃圾</li>
<li><strong>筛选回收(Live Data Counting And Evacuation)</strong>: 制定回收计划，选择多个Region构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧Regionn的全部空间。需要STW.</li>
</ul>
<p>G1垃圾回收器的特点如下：</p>
<ol>
<li><strong>并发与并行</strong>：G1垃圾回收器可以在应用程序运行时进行垃圾回收，减少应用程序的停顿时间。它将垃圾回收分为两个阶段：<strong>并发标记阶段和并行清除阶段</strong>。并发标记阶段与应用程序线程并行运行，而并行清除阶段则由垃圾回收线程单独运行。</li>
<li><strong>分代收集</strong>：G1垃圾回收器虽然不是严格意义上的分代收集器，但它通过区域的概念实现了分代收集的某些特性。<strong>它将堆内存分为新生代和老年代区域，并使用不同的策略来回收这些区域。</strong></li>
<li><strong>内存预分配</strong>：G1垃圾回收器在启动时预先分配内存区域，这些区域的大小可以根据应用程序的需求进行调整。这有助于减少垃圾回收时因为内存分配导致的停顿。</li>
<li><strong>停顿时间预测</strong>：G1垃圾回收器能够预测未来几次垃圾回收的平均停顿时间，并允许用户根据自己的需求调整垃圾回收策略，以达到特定的停顿时间目标。</li>
<li><strong>堆内存碎片整理</strong>：G1垃圾回收器在垃圾回收过程中会尽量减少内存碎片，它通过合并相邻的存活区域来减少碎片。</li>
</ol>
<p><strong>G1垃圾回收器的设计目标是在保持低停顿时间的同时，提高垃圾回收的吞吐量。</strong>它适用于对响应性要求较高的应用程序，如大型企业应用和Web应用服务器。</p>
<p>:blue_heart:<strong>Sererial收集器</strong></p>
<ul>
<li>Sererial收集器是一个<strong>单线程收集器</strong>。它只会使用<strong>一条垃圾收集线程</strong>去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（STW），直到它收集结束。</li>
<li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></li>
<li>简单而高效，没有线程交互的开销。</li>
<li>适合 <strong>Client</strong> <strong>模式下</strong>的虚拟机。</li>
</ul>
<p> 【补充】Serial Old 收集器：**Serial 收集器的老年代版本，单线程收集器。两个用途：1）与 <strong>Parallel Scavenge 收集器搭配使用；</strong>2）作为 **CMS 收集器的后备方案。</p>
<p>:blue_heart:<strong>ParNew收集器</strong></p>
<ul>
<li><strong>Serial 收集器的多线程版本</strong>，在多核CPU 环境下有着比 Serial 更好的表现。</li>
<li>新生代采用标记-复制算法，老年代采用标记-整理算法。</li>
</ul>
<p>:blue_heart:<strong>Parallel Scavenge收集器</strong></p>
<ul>
<li>并行收集器，<strong>追求高吞吐量</strong>，高效利用 CPU。适合后台应用对交互相应要求不高的场景</li>
<li>新生代采用标记-复制算法，老年代采用标记-整理算法。</li>
<li>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。</li>
</ul>
<p>【补充】Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源的场合，可以优先考虑 Parallel Scavenge 收集器和 Parallel Old收集器。</p>
<p>:blue_heart:<strong>ZGC垃圾回收器</strong></p>
<p>ZGC（Z Garbage Collector）是Java 11引入的一种垃圾回收器，<strong>它旨在为高吞吐量应用程序提供低延迟的垃圾回收。</strong>ZGC（Z Garbage Collector）的“Z”代表“Zero”，因为它承诺在应用程序正常运行时实现零停顿时间。ZGC算法的主要特点包括：</p>
<ol>
<li><strong>并行和并发</strong>：ZGC垃圾回收器在应用程序运行时进行垃圾回收，尽可能减少应用程序的停顿时间。它使用多线程并行执行垃圾回收，同时与应用程序线程并发运行。</li>
<li><strong>分代收集</strong>：ZGC垃圾回收器将堆内存分为新生代和老年代，并使用不同的策略来回收这些区域。</li>
<li><strong>内存压缩</strong>：ZGC垃圾回收器使用内存压缩技术，将存活的对象压缩到内存的一端，从而减少内存碎片。</li>
<li><strong>适应性内存分配</strong>：ZGC垃圾回收器能够根据应用程序的需求动态调整内存分配，以提高垃圾回收的效率。</li>
<li><strong>低停顿时间</strong>：ZGC垃圾回收器承诺在应用程序正常运行时实现零停顿时间，这是其设计的核心目标。</li>
</ol>
<p>ZGC垃圾回收器的设计目标是提供高吞吐量的同时，实现低延迟的垃圾回收。它适用于对响应性要求较高的应用程序，如大型企业应用和Web应用服务器。</p>
<p>需要注意的是，ZGC垃圾回收器目前还处于实验阶段，可能存在性能波动和不稳定性的问题。因此，在生产环境中使用ZGC之前，建议进行充分的测试和性能评估。</p>
<h4 id="3-什么时候会触发FullGC"><a href="#3-什么时候会触发FullGC" class="headerlink" title="3. 什么时候会触发FullGC"></a>3. 什么时候会触发<code>FullGC</code></h4><p>在Java中，Full GC（Full Garbage Collection）是一种彻底的垃圾回收，它会对堆内存中的所有对象进行回收，包括年轻代和老年代。Full GC通常比其他类型的垃圾回收（如Minor GC或Major GC）更耗时，因为它需要处理更多的对象和更复杂的内存结构。</p>
<p>触发Full GC的情况包括：</p>
<ol>
<li><strong>内存不足</strong>：<strong>当堆内存不足时，JVM会触发Full GC</strong>。这通常发生在堆内存耗尽时，没有足够的内存来创建新对象或扩展堆内存。</li>
<li><strong>老年代空间不足</strong>：<strong>老年代空间不足时，即使年轻代还有足够的空间，JVM也会触发Full GC</strong>。这是因为老年代空间不足意味着某些对象已经存活了足够长的时间，可能需要进行彻底的回收。</li>
<li><strong>空间分配担保</strong>：在某些垃圾回收器（如CMS）中，当老年代空间不足时，为了给新生代空间分配担保，JVM会触发Full GC。</li>
<li><strong>系统调用或用户请求</strong>：在某些情况下，用户可以通过JVM参数或系统调用手动触发Full GC。<strong>System.gc()</strong></li>
<li><strong>内存压缩或大对象分配</strong>：在某些垃圾回收器（如G1）中，为了进行内存压缩或为大对象分配空间，JVM可能会触发Full GC。</li>
<li><strong>长期没有Minor GC</strong>：如果长时间没有进行Minor GC，可能会导致老年代空间不足，从而触发Full GC。</li>
<li><strong>JVM参数配置</strong>：JVM参数（如<code>-XX:+UseConcMarkSweepGC</code>）可能会导致更频繁的Full GC。</li>
</ol>
<p><strong>[注] 新生代内存不够时触发Minor GC,  <code>JVM</code>内存不足时触发Full GC.</strong></p>
<h3 id="12-多线程环境下，时间片轮询是如何工作的？"><a href="#12-多线程环境下，时间片轮询是如何工作的？" class="headerlink" title="12.多线程环境下，时间片轮询是如何工作的？"></a>12.多线程环境下，时间片轮询是如何工作的？</h3><p>多线程环境下，时间片轮询（Time-sharing）是一种操作系统调度策略，用于分派CPU的时间资源给多个线程。这种策略通常应用于分时系统，它将CPU的时间分割成小的时间片段，称为时间片，并按照线程的优先级或调度策略分配这些时间片段给不同的线程。</p>
<p>在多线程环境下，时间片轮询的工作流程大致如下：</p>
<ol>
<li><strong>线程调度</strong>：操作系统负责调度线程，决定哪个线程将在下一个时间片内执行。</li>
<li><strong>时间片分配</strong>：操作系统为每个线程分配一个时间片，线程在时间片内执行。</li>
<li><strong>时间片耗尽</strong>：当线程的时间片用完时，操作系统会暂停该线程的执行，并将其状态保存到线程调度队列中。</li>
<li><strong>线程切换</strong>：操作系统选择另一个线程并恢复其状态，然后该线程开始执行。</li>
<li><strong>循环执行</strong>：上述过程会不断循环，每个线程都有机会执行，直到所有的线程都执行完毕或等待其他事件的发生。</li>
</ol>
<p>时间片轮询的主要优点是公平地分配CPU时间，使得每个线程都能得到执行的机会。然而，如果线程切换过于频繁，可能会导致性能下降，因为线程切换本身需要一定的开销。</p>
<h3 id="13-堆和栈的区别"><a href="#13-堆和栈的区别" class="headerlink" title="13. 堆和栈的区别"></a>13. 堆和栈的区别</h3><p>栈是运行时单元，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中的基本数据类型、引用和引用对象），所在区域不连续，会有碎片。</p>
<ol>
<li><strong>功能不同</strong>：<strong>栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。</strong>无论是成员变量，局部变量，还是类变量，他们指向的对象都存储在堆内存中。</li>
<li><strong>共享性不同</strong>：栈内存是线程私有的，堆内存是所有线程共享的。</li>
<li><strong>异常错误不同</strong>：栈空间不足抛出<code>java.long.StackOverFlowError</code>,堆空间不足抛出<code>java.lang.OutOfMemoryError</code></li>
<li><strong>空间大小不同</strong>：栈空间远远小于堆。</li>
</ol>
<h3 id="15-什么是java虚拟机？为什么Java被称为是“平台无关的编程语言”"><a href="#15-什么是java虚拟机？为什么Java被称为是“平台无关的编程语言”" class="headerlink" title="15. 什么是java虚拟机？为什么Java被称为是“平台无关的编程语言”"></a>15. 什么是java虚拟机？为什么Java被称为是“平台无关的编程语言”</h3><p>Java虚拟机（Java Virtual Machine，JVM）是一个抽象的计算机，它实现了Java语言规范中的所有字节码指令。当编写Java程序时，源代码（.java文件）会被编译器转换成字节码（.class文件），这些字节码可以在任何支持Java虚拟机的平台上运行。</p>
<p>Java虚拟机的主要功能包括：</p>
<ol>
<li><strong>字节码解释</strong>：JVM负责解释并执行Java字节码。</li>
<li><strong>内存管理</strong>：JVM管理Java应用程序使用的内存，包括垃圾回收。</li>
<li><strong>类加载器</strong>：JVM负责加载Java类，并创建类的Class对象。</li>
<li><strong>安全性</strong>：JVM提供了安全性检查，如验证字节码和访问控制。</li>
</ol>
<p>为什么Java被称为是“平台无关的编程语言”：</p>
<ol>
<li><strong>编译一次，到处运行</strong>：Java源代码被编译成字节码后，可以在任何支持JVM的平台上运行，无需重新编译。这意味着开发者可以在一个平台上编写和测试Java代码，然后将其部署到其他平台上，而无需进行任何修改。</li>
<li><strong>独立于硬件和操作系统</strong>：Java虚拟机与底层硬件和操作系统无关，它提供了一个抽象层，使得Java应用程序可以在不同的硬件和操作系统上运行。</li>
<li><strong>自动内存管理</strong>：JVM提供了自动内存管理，包括垃圾回收，这简化了内存管理，提高了程序的可靠性和可维护性。</li>
<li><strong>安全性</strong>：JVM提供了安全性检查，如验证字节码和访问控制，这有助于防止恶意代码的执行。</li>
</ol>
<p>因此，Java的“平台无关性”是由其虚拟机实现的，它允许Java应用程序在不同的环境中运行，而不需要进行修改。</p>
<h3 id="16-对象分配规则"><a href="#16-对象分配规则" class="headerlink" title="16.对象分配规则"></a>16.对象分配规则</h3><ul>
<li>对象<strong>优先分配在Eden区</strong>，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC</li>
<li><strong>大对象直接进入老年代</strong>（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）</li>
<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</li>
<li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>
<li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查<code>HandlePromotionFailure</code>设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>
</ul>
<h3 id="17-描述一下JVM加载Class文件的原理机制"><a href="#17-描述一下JVM加载Class文件的原理机制" class="headerlink" title="17. 描述一下JVM加载Class文件的原理机制"></a>17. 描述一下JVM加载Class文件的原理机制</h3><p>JVM中类的装载是由类加载器（<code>ClassLoader</code>）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<h3 id="18-java对象创建过程"><a href="#18-java对象创建过程" class="headerlink" title="18. java对象创建过程"></a>18. java对象创建过程</h3><p>在Java中，对象的创建过程可以概括为以下几个步骤：</p>
<ol>
<li><strong>类加载</strong>：<ul>
<li>当程序中使用到某个类时，Java虚拟机（JVM）会检查该类是否已加载。</li>
<li>如果没有加载，则JVM会根据类的全限定名（包括包名）在类路径下查找相应的.class文件，并加载到内存中。</li>
</ul>
</li>
<li><strong>类的加载过程</strong>：<ul>
<li>加载：将类的.class文件加载到内存中。</li>
<li>验证：<strong>确保加载的.class文件符合Java语言规范，并且不包含安全漏洞。</strong></li>
<li>准备：<strong>为类的静态变量分配内存，并设置默认初始值。</strong></li>
<li>解析：将类、接口、方法、字段等<strong>符号引用解析为直接引用。</strong></li>
</ul>
</li>
<li><strong>对象分配内存</strong>：<ul>
<li>当通过关键字 <code>new</code> 创建一个对象时，JVM会在堆内存中为该对象分配内存空间。</li>
<li>JVM根据对象的大小确定在堆中的分配位置。</li>
</ul>
</li>
<li><strong>初始化对象</strong>：<ul>
<li>在分配内存后，JVM会对对象进行初始化，其中会对对象的成员变量进行初始化，包括赋予默认值（对于基本类型）或者null（对于引用类型）。</li>
</ul>
</li>
<li><strong>调用构造方法</strong>：<ul>
<li>JVM会调用对象的构造方法来完成对象的初始化过程。</li>
<li>构造方法负责对对象进行自定义的初始化操作，可以为成员变量赋值，调用其他方法等。</li>
</ul>
</li>
<li><strong>返回对象引用</strong>：<ul>
<li>当对象初始化完成后，<code>new</code> 表达式将返回对象的引用，可以将该引用赋给变量，从而可以操作该对象。</li>
</ul>
</li>
</ol>
<h3 id="19-java的对象结构"><a href="#19-java的对象结构" class="headerlink" title="19. java的对象结构"></a>19. java的对象结构</h3><p>在Java中，对象是类的实例，它包含了该类的数据和方法。对象的结构可以分为以下几个方面：</p>
<ol>
<li><strong>对象头（Object Header）</strong>：<ul>
<li>Java对象在内存中的第一个部分是对象头，它包含了一些元数据，如哈希码、锁信息、GC分代年龄等。对象头的结构在不同的JVM实现中可能会有所不同。</li>
</ul>
</li>
<li><strong>实例变量（Instance Variables）</strong>：<ul>
<li>实例变量是对象的状态，它们描述了对象的属性和特征。这些变量的值可以在对象的生命周期内改变。</li>
</ul>
</li>
<li><strong>方法区指针（Method Area Pointer）</strong>：<ul>
<li>每个对象都包含一个指向方法区的指针，该指针指向对象所属类的方法区（也称为永久代或元空间），用于访问对象的类信息，如方法和静态变量等。</li>
</ul>
</li>
<li><strong>对齐填充（Alignment Padding）</strong>：<ul>
<li>对齐填充是为了满足JVM对内存对齐的要求，以提高访问效率。它通常被添加到对象的末尾，使得对象的大小是某个特定大小的倍数</li>
</ul>
</li>
</ol>
<h3 id="22-java调优的常见工具和命令"><a href="#22-java调优的常见工具和命令" class="headerlink" title="22. java调优的常见工具和命令"></a>22. java调优的常见工具和命令</h3><ol>
<li>**<code>jps</code>**：Java进程状态工具，用于列出正在运行的Java进程的进程ID。</li>
<li><code>**jstat**</code>：Java统计监视工具，用于监视Java虚拟机的各种统计信息，如垃圾回收统计、类装载统计等。</li>
<li>**<code>jstack</code>**：Java堆栈跟踪工具，用于生成Java进程的线程转储，用于诊断线程死锁和其它线程相关的问题。</li>
<li><code>**jmap**</code>：Java内存映像工具，用于生成Java堆内存快照，可以用来查看对象分布、内存泄漏等问题。</li>
<li>**<code>jhat</code>**：Java堆分析工具，用于分析<code>jmap</code>生成的堆内存快照，提供基于Web的图形化界面。</li>
<li><code>**jconsole**</code>：Java监视与管理控制台，提供了一个基于图形界面的监视工具，可以实时监视Java应用程序的运行状态。</li>
<li><code>**VisualVM**</code>：<code>VisualVM</code>是一个多合一的Java虚拟机监视、分析和调试工具，可以通过插件支持各种Java应用程序性能分析。</li>
<li>**Java Flight Recorder (JFR)**：Java飞行记录器，用于记录Java应用程序运行时的各种事件和性能数据，可用于性能分析和故障诊断。</li>
<li>**Java Mission Control (JMC)**：Java任务控制器，配合Java飞行记录器使用，提供了一组强大的工具用于监视、管理和优化Java应用程序。</li>
<li><strong>GC日志参数</strong>：通过设置Java虚拟机启动参数，可以启用GC日志输出，如 <code>-verbose:gc</code>、<code>-Xlog:gc</code> 等，用于分析垃圾回收行为和性能。</li>
</ol>
<h3 id="23-逃逸分析"><a href="#23-逃逸分析" class="headerlink" title="23. 逃逸分析"></a>23. 逃逸分析</h3><p>不，对象并不一定分配在堆中。在Java中，对象可以在堆上分配，也可以在栈上分配。</p>
<ol>
<li><strong>堆分配</strong>：大多数Java对象都是在堆上分配的。堆是Java虚拟机管理的运行时数据区，用于存储对象实例和数组对象。</li>
<li><strong>栈分配</strong>：局部变量和方法参数等基本数据类型和对象引用通常存储在栈上。<strong>如果一个对象的引用只在一个方法内部使用，并且不会被返回到调用方，那么这个对象可能会被分配在栈上而不是堆上</strong>。这种方式的分配通常会更加高效，因为对象的生命周期与方法的生命周期相同，不需要额外的垃圾回收操作。</li>
</ol>
<p>逃逸分析是Java虚拟机的一项优化技术，用于分析对象的引用是否会逃逸到方法之外。如果虚拟机可以确定对象的引用不会逃逸到方法之外，那么就可以将这个对象分配在栈上而不是堆上，从而提高内存分配和访问的效率。逃逸分析还可以帮助虚拟机做更多的优化，如锁消除、标量替换等。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240510205924543.png" alt="image-20240510205924543"></p>
<h3 id="24-什么是指针碰撞"><a href="#24-什么是指针碰撞" class="headerlink" title="24. 什么是指针碰撞"></a>24. 什么是指针碰撞</h3><p>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。<strong>如果Java堆中内存是绝对规整的</strong>，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是 指针碰撞。</p>
<h3 id="25-什么是空闲列表"><a href="#25-什么是空闲列表" class="headerlink" title="25. 什么是空闲列表"></a>25. 什么是空闲列表</h3><p><strong>如果Java堆内存中的内存并不是规整的</strong>，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞啦，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</p>
<h3 id="26-什么是TLAB"><a href="#26-什么是TLAB" class="headerlink" title="26. 什么是TLAB"></a>26. 什么是TLAB</h3><p>可以把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是TLAB（Thread Local Allocation Buffer，本地线程分配缓存） 。虚拟机通过<code>-XX:UseTLAB</code> 设定它的</p>
<h3 id="27-Class文件的结构属性"><a href="#27-Class文件的结构属性" class="headerlink" title="27. Class文件的结构属性"></a>27. Class文件的结构属性</h3><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240613172954058.png" alt="image-20240613172954058"></p>
<h3 id="28-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"><a href="#28-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代" class="headerlink" title="28.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"></a>28.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代</h3><ol>
<li><strong>新生代GC（Minor GC）</strong><ol>
<li>触发条件： Eden区满时触发</li>
<li>过程<ol>
<li>停止所有应用线程（SWT，Stop The World）</li>
<li>检查Eden区和Survivor区的存活对象。</li>
<li>将Eden区和一个Survivor区（假设是S0）中的存活对象复制到另一个Survivor区（S1）</li>
<li>更新存活对象的年龄（Age）</li>
<li>清空Eden区和被复制的Survivor区（S0）</li>
</ol>
</li>
</ol>
</li>
<li><strong>老年代GC（Major GC或Full GC）</strong>：<ol>
<li>触发条件：老年代满或其他特定条件（如System.gc()调用）</li>
<li>过程<ol>
<li>停止所有应用线程（STW）。</li>
<li>检查老年代中的对象，回收不再使用的对象。</li>
<li>如果是Full GC，还会对新生代进行垃圾回收。</li>
</ol>
</li>
</ol>
</li>
<li><strong>对象如何晋升到老年代</strong><ol>
<li><strong>对象年龄达到阈值</strong>：<ul>
<li>新生代中的对象在每次Minor GC后年龄增加，达到某个阈值（默认是15，可以通过<code>-XX:MaxTenuringThreshold</code>参数设置）后晋升到老年代。</li>
</ul>
</li>
<li><strong>Survivor区无法容纳</strong>：<ul>
<li>如果在Minor GC时，Survivor区无法容纳存活的对象，则这些对象会直接晋升到老年代。</li>
</ul>
</li>
<li><strong>大对象</strong>：<ul>
<li>大对象（如大数组、大字符串）如果无法在Eden区分配，可能会直接分配到老年代。可以通过<code>-XX:PretenureSizeThreshold</code>参数设置大对象的阈值。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="29-JVM的主要参数"><a href="#29-JVM的主要参数" class="headerlink" title="29.JVM的主要参数"></a>29.JVM的主要参数</h3><p><strong>内存设置</strong>：</p>
<ul>
<li><code>-Xms</code>：设置JVM初始化堆大小。</li>
<li><code>-Xmx</code>：设置JVM最大堆大小。</li>
<li><code>-Xmn</code>：设置新生代大小。</li>
</ul>
<p><strong>垃圾回收器</strong>：</p>
<ul>
<li><code>-XX:+UseSerialGC</code>：使用串行垃圾回收器。</li>
<li><code>-XX:+UseParallelGC</code>：使用并行垃圾回收器（也称为吞吐量垃圾回收器）。</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：使用CMS（Concurrent Mark-Sweep）垃圾回收器。</li>
<li><code>-XX:+UseG1GC</code>：使用G1（Garbage First）垃圾回收器。</li>
</ul>
<p><strong>新生代和老年代比例</strong>：</p>
<ul>
<li><code>-XX:NewRatio</code>：设置老年代和新生代的比例。例如，<code>-XX:NewRatio=2</code>表示老年代与新生代的比例为2:1。</li>
<li><code>-XX:SurvivorRatio</code>：设置Eden区与一个Survivor区的比例。例如，<code>-XX:SurvivorRatio=8</code>表示Eden区与一个Survivor区的比例为8:1。</li>
</ul>
<p><strong>晋升和回收参数</strong>：</p>
<ul>
<li><code>-XX:MaxTenuringThreshold</code>：设置对象晋升到老年代的年龄阈值。</li>
<li><code>-XX:PretenureSizeThreshold</code>：设置大对象直接分配到老年代的大小阈值。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置老年代占用率达到多少时触发Full GC（G1垃圾回收器使用）。</li>
</ul>
<p><strong>日志和调试参数</strong>：</p>
<ul>
<li><code>-XX:+PrintGCDetails</code>：打印GC详细信息。</li>
<li><code>-XX:+PrintGCDateStamps</code>：打印GC时间戳。</li>
<li><code>-Xloggc:&lt;file&gt;</code>：将GC日志输出到指定文件。</li>
</ul>
<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="I-O基础知识总结"><a href="#I-O基础知识总结" class="headerlink" title="I/O基础知识总结"></a>I/O基础知识总结</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/io/io-basis.html">https://javaguide.cn/java/io/io-basis.html</a></p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p><strong>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</strong>数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="2-字节流"><a href="#2-字节流" class="headerlink" title="2. 字节流"></a>2. 字节流</h3><p><strong>InputStream(字节输入流)</strong></p>
<p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>
<p><strong>常见用法</strong></p>
<ul>
<li>read(): 返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
<li><code>available()</code>：返回输入流中可以读取的字节数。</li>
<li><code>close()</code>：关闭输入流释放相关的系统资源。</li>
<li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<p><strong>OutputStream(字节输出流)</strong></p>
<p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>
<p><strong>常见用法</strong></p>
<ul>
<li><code>write(int b)</code>：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code>：关闭输出流释放相关的系统资源。</li>
</ul>
<h3 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3. 字节流"></a>3. 字节流</h3><p><strong>I/O流为什么要分字节流和字符流</strong></p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li>
<li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li>
</ul>
<p>​	<strong>如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</strong></p>
<p><strong>Reader(字符输入流)</strong></p>
<p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>
<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>
<p><code>Reader</code> 常用方法：</p>
<ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>
<li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
<p><strong>Writer(字符输出流)</strong></p>
<p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>
<p><code>Writer</code> 常用方法：</p>
<ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
<h3 id="4-字节缓冲流"><a href="#4-字节缓冲流" class="headerlink" title="4. 字节缓冲流"></a>4. 字节缓冲流</h3><p><strong>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</strong></p>
<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>
<h4 id="4-1-BufferedInputStream-字节缓冲输入流"><a href="#4-1-BufferedInputStream-字节缓冲输入流" class="headerlink" title="4.1 BufferedInputStream(字节缓冲输入流)"></a>4.1 BufferedInputStream(字节缓冲输入流)</h4><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p>
<p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组。</p>
<h4 id="4-2-BufferOutputStream-字节缓冲输出流"><a href="#4-2-BufferOutputStream-字节缓冲输出流" class="headerlink" title="4.2 BufferOutputStream(字节缓冲输出流)"></a>4.2 BufferOutputStream(字节缓冲输出流)</h4><p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p>
<h3 id="5-字符缓冲流"><a href="#5-字符缓冲流" class="headerlink" title="5. 字符缓冲流"></a>5. 字符缓冲流</h3><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>
<h3 id="6-打印流"><a href="#6-打印流" class="headerlink" title="6. 打印流"></a>6. 打印流</h3><h3 id="7-随机访问流"><a href="#7-随机访问流" class="headerlink" title="7. 随机访问流"></a>7. 随机访问流</h3><h3 id="1-JAVA-IO中的设计模型有哪些"><a href="#1-JAVA-IO中的设计模型有哪些" class="headerlink" title="1. JAVA IO中的设计模型有哪些"></a>1. JAVA IO中的设计模型有哪些</h3><p><strong><a target="_blank" rel="noopener" href="https://javaguide.cn/java/io/io-design-patterns.html">https://javaguide.cn/java/io/io-design-patterns.html</a></strong></p>
<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p>
<p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p><strong>适配器（Adapter Pattern）模式</strong> 主要用于接口互不兼容的类的协调工作。</p>
<p>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为<strong>对象适配器和类适配器</strong>。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p>
<p><strong>适配器模式和装饰器模式的区别</strong></p>
<p><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p>
<p><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）、 <code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）、<code>ZipFileSystem</code> 类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>NIO 中的文件目录监听服务使用到了观察者模式。</p>
<p>NIO 中的文件目录监听服务基于 <code>WatchService</code> 接口和 <code>Watchable</code> 接口。<code>WatchService</code> 属于观察者，<code>Watchable</code> 属于被观察者。</p>
<h2 id="Java-IO模型详解"><a href="#Java-IO模型详解" class="headerlink" title="Java IO模型详解"></a>Java IO模型详解</h2><p>常见的I/O模型：UNIX 系统下， IO 模型一共有 5 种：<strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p>
<h3 id="Java中3种常见的IO模型"><a href="#Java中3种常见的IO模型" class="headerlink" title="Java中3种常见的IO模型"></a>Java中3种常见的IO模型</h3><h4 id="BIO（Blocking-I-O）"><a href="#BIO（Blocking-I-O）" class="headerlink" title="BIO（Blocking I/O）"></a><strong>BIO（Blocking I/O）</strong></h4><p>同步阻塞IO模型。在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240711144554893.png" alt="image-20240711144554893"></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240711144854950.png" alt="image-20240711144854950"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>从而引出多路复用I/O:arrow_down:</p>
<h4 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="**NIO(Non-blocking/New I/O) **"></a>**NIO(Non-blocking/New I/O) **</h4><p>I/O多路复用模型</p>
<p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240711145307437.png" alt="image-20240711145307437"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</span><br><span class="line">select 调用：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</span><br><span class="line">epoll 调用：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240711145534715.png" alt="image-20240711145534715"></p>
<h4 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO(Asynchronous I/O)"></a>AIO(Asynchronous I/O)</h4><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是<strong>基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240711145825673.png" alt="image-20240711145825673"></p>
<h3 id="Java-NIO-核心知识总结"><a href="#Java-NIO-核心知识总结" class="headerlink" title="Java NIO 核心知识总结"></a>Java NIO 核心知识总结</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/io/nio-basis.html">https://javaguide.cn/java/io/nio-basis.html</a></p>
<p><strong>NIO 主要包括以下三个核心组件：</strong></p>
<ul>
<li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li>
<li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li>
<li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li>
</ul>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a><strong>Buffer</strong></h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> {</span><br><span class="line">    <span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这四个成员变量的具体含义如下：</p>
<ol>
<li>容量（<code>capacity</code>）：<code>Buffer</code>可以存储的最大数据量，<code>Buffer</code>创建时设置且不可改变；</li>
<li>界限（<code>limit</code>）：<code>Buffer</code> 中可以读/写数据的边界。写模式下，<code>limit</code> 代表最多能写入的数据，一般等于 <code>capacity</code>（可以通过<code>limit(int newLimit)</code>方法设置）；读模式下，<code>limit</code> 等于 Buffer 中实际写入的数据大小。</li>
<li>位置（<code>position</code>）：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</li>
<li>标记（<code>mark</code>）：<code>Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li>
</ol>
<p>Buffer 有读模式和写模式这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。Buffer 被创建之后默认是写模式，调用 <code>flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code>clear()</code> 或者 <code>compact()</code> 方法。</p>
<p><code>Buffer</code> 对象不能通过 <code>new</code> 调用构造方法创建对象 ，只能通过静态方法实例化 <code>Buffer</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配堆内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span>;</span><br><span class="line"><span class="comment">// 分配直接内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>Buffer 最核心的两个方法：</p>
<ol>
<li><code>get</code> : 读取缓冲区的数据</li>
<li><code>put</code> ：向缓冲区写入数据</li>
</ol>
<p>除上述两个方法之外，其他的重要方法：</p>
<ul>
<li><code>flip</code> ：将缓冲区从写模式切换到读模式，它会将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</li>
<li><code>clear</code>: 清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharBufferDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 分配一个容量为8的CharBuffer</span></span><br><span class="line">        <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">"初始状态："</span>);</span><br><span class="line">        printState(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向buffer写入3个字符</span></span><br><span class="line">        buffer.put(<span class="string">'a'</span>).put(<span class="string">'b'</span>).put(<span class="string">'c'</span>);</span><br><span class="line">        System.out.println(<span class="string">"写入3个字符后的状态："</span>);</span><br><span class="line">        printState(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用flip()方法，准备读取buffer中的数据，将 position 置 0,limit 的置 3</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">"调用flip()方法后的状态："</span>);</span><br><span class="line">        printState(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取字符</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) {</span><br><span class="line">            System.out.print(buffer.get());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用clear()方法，清空缓冲区，将 position 的值置为 0，将 limit 的值置为 capacity 的值</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        System.out.println(<span class="string">"调用clear()方法后的状态："</span>);</span><br><span class="line">        printState(buffer);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印buffer的capacity、limit、position、mark的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printState</span><span class="params">(CharBuffer buffer)</span> {</span><br><span class="line">        System.out.print(<span class="string">"capacity: "</span> + buffer.capacity());</span><br><span class="line">        System.out.print(<span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line">        System.out.print(<span class="string">", position: "</span> + buffer.position());</span><br><span class="line">        System.out.print(<span class="string">", mark 开始读取的字符: "</span> + buffer.mark());</span><br><span class="line">        System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">    初始状态：</span><br><span class="line">capacity: <span class="number">8</span>, limit: <span class="number">8</span>, position: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">写入<span class="number">3</span>个字符后的状态：</span><br><span class="line">capacity: <span class="number">8</span>, limit: <span class="number">8</span>, position: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">准备读取buffer中的数据！</span><br><span class="line"></span><br><span class="line">调用flip()方法后的状态：</span><br><span class="line">capacity: <span class="number">8</span>, limit: <span class="number">3</span>, position: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">读取到的数据：abc</span><br><span class="line"></span><br><span class="line">调用clear()方法后的状态：</span><br><span class="line">capacity: <span class="number">8</span>, limit: <span class="number">8</span>, position: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以利用它来读取和写入数据，就像打开了一条自来水管，让数据在 Channel 中自由流动。</p>
<p>BIO 中的流是单向的，分为各种 <code>InputStream</code>（输入流）和 <code>OutputStream</code>（输出流），数据只是在一个方向上传输。<strong>通道与流的不同之处在于通道是双向的，它可以用于读、写或者同时用于读写。</strong></p>
<p>Channel 与前面介绍的 Buffer 打交道，<strong>读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中</strong>。</p>
<p>常用Channal类型</p>
<ul>
<li><code>FileChannel</code>：文件访问通道；</li>
<li><code>SocketChannel</code>、<code>ServerSocketChannel</code>：TCP 通信通道；</li>
<li><code>DatagramChannel</code>：UDP 通信通道；</li>
</ul>
<p><strong>Channel 最核心的两个方法：</strong></p>
<ol>
<li><strong><code>read</code> ：读取数据并写入到 Buffer 中。</strong></li>
<li><strong><code>write</code> ：将 Buffer 中的数据写入到 Channel 中。</strong></li>
</ol>
<h4 id="Select-选择器"><a href="#Select-选择器" class="headerlink" title="Select(选择器)"></a>Select(选择器)</h4><p><strong>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。</strong>Selector 是基于事件驱动的 I/O 多路复用模型，<strong>主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。</strong>当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I/O 操作。</p>
<p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code>epoll()</code> 代替传统的 <code>select</code> 实现，所以它并没有最大连接句柄 <code>1024/2048</code> 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p>
<p>Selector 可以监听以下四种事件类型：</p>
<ol>
<li><code>SelectionKey.OP_ACCEPT</code>：表示通道接受连接的事件，这通常用于 <code>ServerSocketChannel</code>。</li>
<li><code>SelectionKey.OP_CONNECT</code>：表示通道完成连接的事件，这通常用于 <code>SocketChannel</code>。</li>
<li><code>SelectionKey.OP_READ</code>：表示通道准备好进行读取的事件，即有数据可读。</li>
<li><code>SelectionKey.OP_WRITE</code>：表示通道准备好进行写入的事件，即可以写入数据。</li>
</ol>
<p><code>Selector</code>是抽象类，可以通过调用此类的 <code>open()</code> 静态方法来创建 Selector 实例。Selector 可以同时监控多个 <code>SelectableChannel</code> 的 <code>IO</code> 状况，是非阻塞 <code>IO</code> 的核心。</p>
<h3 id="NIO零拷贝"><a href="#NIO零拷贝" class="headerlink" title="NIO零拷贝"></a>NIO零拷贝</h3><p><strong>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。</strong>也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： <code>mmap+write</code>、<code>sendfile</code>和 <code>sendfile + DMA gather copy</code> 。</p>
<h1 id="Java并发常见面试题总结"><a href="#Java并发常见面试题总结" class="headerlink" title="Java并发常见面试题总结"></a>Java并发常见面试题总结</h1><p>方法区在jdk1.8以后改为元空间</p>
<h3 id="1-请简要描述线程与进程的关系-区别及优缺点"><a href="#1-请简要描述线程与进程的关系-区别及优缺点" class="headerlink" title="1.请简要描述线程与进程的关系,区别及优缺点"></a>1.请简要描述线程与进程的关系,区别及优缺点</h3><p>一个进程可以有多个线程，多个线程共享进程的堆和方法区（JDK1.8之后的元空间）资源，但是每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<p><strong>总结</strong>：<strong>线程是进程划分的更小的运行单位。线程和进程最大的不同在于基本上各个进程是独立的，而个线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；进程执行开销大，但是有利于资源的管理和保护</strong></p>
<h3 id="2-程序计数器为什么是私有的"><a href="#2-程序计数器为什么是私有的" class="headerlink" title="2.程序计数器为什么是私有的?"></a>2.程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p>
<p>1.<strong>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</strong>，如：顺序执行，选择，循环，异常处理。</p>
<p>2.<strong>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</strong></p>
<p>需要注意的是，如果执行的是native方法，那么程序计数器记录的是undefined地址，只有执行的是java代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="3-虚拟机栈和本地方法栈为什么是私有的"><a href="#3-虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="3.虚拟机栈和本地方法栈为什么是私有的?"></a>3.虚拟机栈和本地方法栈为什么是私有的?</h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="4-简单介绍一下堆和方法区"><a href="#4-简单介绍一下堆和方法区" class="headerlink" title="4. 简单介绍一下堆和方法区"></a>4. 简单介绍一下堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="5-并发和并行的区别"><a href="#5-并发和并行的区别" class="headerlink" title="5. 并发和并行的区别"></a>5. 并发和并行的区别</h3><p><strong>并发</strong>：两个及以上的作业在同一<strong>时间段</strong>内执行。</p>
<p><strong>并行</strong>：两个及以上的作业在同一<strong>时刻</strong>执行。</p>
<h3 id="6-同步和异步的区别"><a href="#6-同步和异步的区别" class="headerlink" title="6. 同步和异步的区别"></a>6. 同步和异步的区别</h3><p><strong>同步</strong>：发出一个调用之后，在没有得到结果之间，该调用就不可以返回，一直等待。</p>
<p><strong>异步</strong>：调用在发出后，不用等待返回结果，该调用直接返回。</p>
<h3 id="7-为什么要使用多线程"><a href="#7-为什么要使用多线程" class="headerlink" title="7. 为什么要使用多线程"></a>7. 为什么要使用多线程</h3><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li>
</ul>
<h3 id="8-使用多线程可能会带来什么问题？"><a href="#8-使用多线程可能会带来什么问题？" class="headerlink" title="8. 使用多线程可能会带来什么问题？"></a>8. 使用多线程可能会带来什么问题？</h3><p>并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>
<h3 id="9-单核CPU上运行多个线程效率一定会高吗？"><a href="#9-单核CPU上运行多个线程效率一定会高吗？" class="headerlink" title="9. 单核CPU上运行多个线程效率一定会高吗？"></a>9. 单核CPU上运行多个线程效率一定会高吗？</h3><p>单核 CPU 同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。一般来说，有两种类型的线程：CPU 密集型和 IO 密集型。CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。</p>
<p>在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配。如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p>
<p>因此，对于单核 CPU 来说，如果任务是 CPU 密集型的，那么开很多线程会影响效率；如果任务是 IO 密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p>
<h3 id="10-如何创建线程"><a href="#10-如何创建线程" class="headerlink" title="10. 如何创建线程"></a>10. 如何创建线程</h3><p><strong>继承Thread类、 实现Runnable接口、 实现Callable接口、使用线程池、使用<code>CompletableFuture</code>类等等。</strong></p>
<p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。</p>
<p>严格来说，<strong>Java 就只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。</strong>不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p>
<p><strong>继承Thread类</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Thread is running"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现Runnable</strong>接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Thread is running"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现Callable接口</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用线程池</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用<code>CompletableFuture</code> 类</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Thread is running"</span>);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="11-说说线程的生命周期和状态？"><a href="#11-说说线程的生命周期和状态？" class="headerlink" title="11. 说说线程的生命周期和状态？"></a>11. 说说线程的生命周期和状态？</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>
<ul>
<li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li>
<li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li>
<li>BLOCKED：阻塞状态，需要等待锁释放。</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕。</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<p>调用两次线程的start会怎么样：抛出<code>IllegalThreadStateException</code>异常</p>
<h3 id="12-什么是线程上下文切换？"><a href="#12-什么是线程上下文切换？" class="headerlink" title="12. 什么是线程上下文切换？"></a>12. 什么是线程上下文切换？</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h3 id="13-什么是线程死锁？"><a href="#13-什么是线程死锁？" class="headerlink" title="13. 什么是线程死锁？"></a>13. 什么是线程死锁？</h3><p><strong>认识线程死锁</strong></p>
<p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p><strong>产生死锁的四个必要条件</strong></p>
<p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</p>
<h3 id="14-如何预防和避免线程死锁"><a href="#14-如何预防和避免线程死锁" class="headerlink" title="14.如何预防和避免线程死锁"></a>14.如何预防和避免线程死锁</h3><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<blockquote>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p>
</blockquote>
<hr>
<h3 id="15-sleep-方法和wait-方法对比"><a href="#15-sleep-方法和wait-方法对比" class="headerlink" title="15. sleep()方法和wait()方法对比"></a>15. sleep()方法和wait()方法对比</h3><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到</li>
</ul>
<h3 id="16-为什么wait-方法不定义在Thread中？"><a href="#16-为什么wait-方法不定义在Thread中？" class="headerlink" title="16. 为什么wait()方法不定义在Thread中？"></a>16. 为什么wait()方法不定义在Thread中？</h3><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<h3 id="17-可以直接调用Thread类的run方法嘛？"><a href="#17-可以直接调用Thread类的run方法嘛？" class="headerlink" title="17. 可以直接调用Thread类的run方法嘛？"></a>17. 可以直接调用Thread类的run方法嘛？</h3><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="1-为什么需要多线程"><a href="#1-为什么需要多线程" class="headerlink" title="1.为什么需要多线程"></a>1.为什么需要多线程</h3><ul>
<li>CPU增加了缓存，以均衡与内存的速度差异；  // 导致<em>可见性</em>问题</li>
<li>操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异； // 导致<em>原子性</em>问题</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。 // 导致<em>有序性</em>问题</li>
</ul>
<h3 id="2-并发出现问题的根源：并发三要素"><a href="#2-并发出现问题的根源：并发三要素" class="headerlink" title="2.并发出现问题的根源：并发三要素"></a>2.并发出现问题的根源：并发三要素</h3><h4 id="可见性：CPU缓存引起"><a href="#可见性：CPU缓存引起" class="headerlink" title="可见性：CPU缓存引起"></a>可见性：CPU缓存引起</h4><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到</p>
<h4 id="原子性：分时复用引起"><a href="#原子性：分时复用引起" class="headerlink" title="原子性：分时复用引起"></a>原子性：分时复用引起</h4><p>原子性：即一个操作后者多个操作，要么全部执行并且执行的过程不会被任何因素打算，要么就都不执行</p>
<h4 id="有序性-重排序引起"><a href="#有序性-重排序引起" class="headerlink" title="有序性:重排序引起"></a>有序性:重排序引起</h4><p>有序性：即程序执行的顺序按照代码的先后顺序执行</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240301095756084.png" alt="image-20240301095756084"></p>
<h3 id="4-关键字：volatile、synchronized、final"><a href="#4-关键字：volatile、synchronized、final" class="headerlink" title="4.关键字：volatile、synchronized、final"></a>4.关键字：volatile、synchronized、final</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html">https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html</a> volatile 详解</p>
<h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>缓存时分段（line)的，一个段对应一块存储空间，称之为缓存行，它是CPU缓存中可分配的最小存储单元，大小32字节、64字节、128字节不等，这与CPU架构有关，通常来说是64字节。</p>
<h4 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h4><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2183017">https://cloud.tencent.com/developer/article/2183017</a></p>
<p>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ 嗅探(snooping)” 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p>
<p>MESI 是指4种状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
<th>监听任务</th>
</tr>
</thead>
<tbody><tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
<td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
<td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该Cache line无效。</td>
<td>无</td>
</tr>
</tbody></table>
<p><strong>对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的</strong>。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p>
<h4 id="volatile有序性实现"><a href="#volatile有序性实现" class="headerlink" title="volatile有序性实现"></a>volatile有序性实现</h4><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a> synchronized详解</p>
<h5 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h5><p>在应用Synchronized关键字时需要把握如下注意点：</p>
<ul>
<li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li>
<li>每个实例都对应有自己的一把锁（this),不同实例额之间互相不影响；</li>
<li>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。</li>
</ul>
<h5 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h5><p>包括方法锁（默认锁对象为this，当前对象实例）和同步代码块锁（自己指定锁对象）</p>
<h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h5><p>指synchronized修饰静态的方法或指定锁对象为Class对象</p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-final.html">https://pdai.tech/md/java/thread/java-thread-x-key-final.html</a> final详解</p>
<h3 id="5-进程和线程的区别"><a href="#5-进程和线程的区别" class="headerlink" title="5. 进程和线程的区别"></a>5. 进程和线程的区别</h3><p>进程被认为是操作系统分配资源的最小单元，每个进程都拥有独立的内存空间和系统资源。操作系统通常使用进程来表示独立的应用程序实例。</p>
<p>线程被视为操作系统调度的最小单元，他们共享相同的进程内存空间和系统资源。在一个进程之中，多个线程可以协同工作，执行不同的任务，共享数据。</p>
<h3 id="6-启动线程为何调用start而不是run方法"><a href="#6-启动线程为何调用start而不是run方法" class="headerlink" title="6. 启动线程为何调用start而不是run方法"></a>6. 启动线程为何调用start而不是run方法</h3><p><strong>调用 start() 方法会告诉jvm创建一个新的线程</strong>，并在这个新线程中执行与 run() 方法相关联的代码块。这个过程允许多个线程同时运行，每个线程都拥有独立的执行上下文，这意味着它们可以在不互相干扰的情况下执行任务。 与此不同，<strong>如果直接调用 run() 方法，它仅仅是一个普通的方法调用，不会创建新的线程。</strong>相反，它会在当前线程的上下文中执行 run() 方法中的代码。这将导致代码的顺序执行，没有并行性可言，因为它们都在同一个线程内执行。 这种区别非常重要，因为多线程编程的一个主要目标是实现并行性，从而提高程序的性能和响应能力。<strong>通过调用 start() 方法，可以利用多核处理器的优势，同时执行多个线程，以更有效地完成任务。而直接调用 run() 方法只是按照一般的方法顺序执行代码，无法发挥多线程的潜力。因此，使用 start() 方法来启动线程是实现并行性的关键。</strong></p>
<h3 id="7-Java线程之间是如何通信的"><a href="#7-Java线程之间是如何通信的" class="headerlink" title="7. Java线程之间是如何通信的"></a>7. Java线程之间是如何通信的</h3><p>在Java的多线程世界里，线程间的沟通至关重要。<strong>它们通过共享变量和内置的同步机制来交流信息</strong>。 </p>
<p>首先，<strong>共享变量</strong>是线程间通信的基础。一个线程对变量的修改可以被其他线程观察到，从而实现信息传递。</p>
<p><strong>接着是同步机制，Java的synchronized关键字可以确保方法或代码块一次只被一个线程执行，这样不仅保护了共享资源，也为线程间通信提供了保障</strong>。 </p>
<p><strong>Java还提供了等待/通知机制</strong>，通过wait()、notify()和notifyAll()方法，线程可以等待条件满足或被其他线程唤醒。</p>
<p>此外，<strong>线程池和阻塞队列也是线程通信的重要方式</strong>。 线程池如ExecutorService可以调度任务执行，而阻塞队列如BlockingQueue则允许线程以线程安全的方式交换数据。</p>
<p> 还有<strong>原子变量，如AtomicInteger</strong>，它们<strong>通过原子操作确保变量的线程安全，支持无锁的线程间通信</strong>。 </p>
<p>除了刚刚讲的这些以外，还有<strong>一个常用的关键字 volatile, 它可以确保变量的更改对所有线程立即可见，这是实现线程间通信的一种简单而有效的方式。</strong> 总的来说，Java提供了一整套丰富的工具来支持线程间的通信。</p>
<h3 id="8-Java中用到的线程调度算法是什么"><a href="#8-Java中用到的线程调度算法是什么" class="headerlink" title="8. Java中用到的线程调度算法是什么"></a>8. Java中用到的线程调度算法是什么</h3><p><strong>在Java中，线程调度采用的是一种抢占式调度模型。</strong>这就像在一个抢夺战中，有较高优先级的线程将首先占用CPU资源。如果线程具有相同的优先级，那么Java虚拟机会随机选择一个线程来执行，以保持公平竞争的原则。一旦一个线程获得了CPU，它将一直运行，直到自愿放弃CPU资源，或者由于某些情况（比如等待I/O操作、等待锁等）被迫放弃CPU，从而让其他线程有机会执行。</p>
<p> 这种抢占式调度模型的目标是确保具有较高优先级的线程在争夺CPU资源时具有优势，但仍然让较低优先级的线程有机会执行，以避免它们被永远地忽略。Java的多线程调度机制有助于平衡线程之间的竞争和公平性，从而提高了多线程程序的响应速度和效率。</p>
<h3 id="9-死锁与活锁，死锁与饥饿的区别"><a href="#9-死锁与活锁，死锁与饥饿的区别" class="headerlink" title="9. 死锁与活锁，死锁与饥饿的区别"></a>9. 死锁与活锁，死锁与饥饿的区别</h3><p><strong>死锁是指多个线程相互等待对方释放资源，导致它们都无法继续执行下去。</strong>这是<strong>一种静止状态</strong>，这种情况会导致所有线程都被永久性地阻塞，没有一个线程能够继续执行。就像交通堵塞一样，没有车辆能够前进。 </p>
<p><strong>活锁是指多个线程不断地改变自己的状态以回应对方，但最终无法取得进展，导致线程不断重试相同的操作，却无法成功。</strong>这是<strong>一种运行时状态</strong>，线程在持续地执行，但任务不会向前推进。活锁通常发生在线程在避免冲突时不断改变状态，但却没有成功，就像两个人在狭窄的道路上不断让对方走，却无法通过一样。 </p>
<p><strong>饥饿是指一个或多个线程或进程由于某种原因无法获得所需的资源或执行机会，因此无法适时地执行</strong>。这是<strong>一种动态问题</strong>，通常由资源分配不合理或线程优先级设置不当等原因导致。在饥饿中，线程不一定被永久性地阻塞，但是它们可能长时间无法获得所需的资源。就像一个人在繁忙的自助餐厅排队等待很长时间，但一直无法获得食物一样。</p>
<h3 id="10-如何避免死锁"><a href="#10-如何避免死锁" class="headerlink" title="10. 如何避免死锁"></a>10. 如何避免死锁</h3><p>死锁产生的四个必要条件：</p>
<p>（1） <strong>互斥条件：</strong>一个资源每次只能被一个进程使用。</p>
<p>（2） <strong>请求与保持条件：</strong>一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>（3） <strong>不剥夺条件：</strong> 进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>（4） <strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>死锁是多线程编程中的一种常见问题，它发生在两个或多个线程相互等待对方释放资源的情况下，导致程序无法继续执行。为了避免死锁，我们可以采用以下策略： </p>
<p>1 锁顺序： <strong>定义一个固定的锁获取顺序，并要求所有线程都按照相同的顺序获取锁。</strong>这可以减少不同线程之间资源争夺的可能性。（破坏互斥条件）</p>
<p>2 超时机制： <strong>在获取锁时，设置一个超时时间。如果超过指定时间仍然无法获取锁，线程应该释放已经持有的锁并重试，或者采取其他适当的措施。</strong>这有助于避免线程无限期地等待锁。（破坏循环等待）</p>
<p>3 避免嵌套锁： <strong>尽量避免在一个锁的持有期间再次尝试获取其他锁。</strong>如果确实需要获取多个锁，请确保获取的顺序是固定的，以减少死锁风险。（破坏保持和请求）</p>
<p>4 使用锁机制： 比如Java中的ReentrantLock，它<strong>支持可中断的锁获取和条件等待，有助于避免死锁</strong>。（破坏不剥夺条件）</p>
<h3 id="11-什么情况线程会进入WAITING状态"><a href="#11-什么情况线程会进入WAITING状态" class="headerlink" title="11. 什么情况线程会进入WAITING状态"></a>11. 什么情况线程会进入WAITING状态</h3><p>线程进入WAITING状态有以下几种情况：</p>
<p>1 <strong>调用Object.wait()方法，该方法会使得当前线程进入等待状态，等待其他线程调用同一个对象的notify()或notifyAll()方法唤醒该线程。</strong></p>
<p>2 <strong>调用Thread.join()方法，该方法会使得当前线程等待指定线程的结束，当指定线程结束时，当前线程将被唤醒。</strong> </p>
<p>3 <strong>调用LockSupport.park()方法，该方法会使得当前线程等待，直到获取LockSupport指定的许可或者线程被中断、调度。</strong></p>
<p><strong>4 在获取锁时，如果当前线程没有获取到锁，就会进入等待状态，等待其他线程释放锁。</strong></p>
<p>5 等待I/O操作：<strong>当线程在执行期间遇到了需要等待I/O操作完成的情况，它会进入WAITING状态，直到I/O操作完成。</strong></p>
<p><strong>需要注意的是，当线程进入WAITING状态时，会释放所有的锁，并且不会占用CPU资源。</strong>如果线程长时间处于等待状态，可能会造成CPU的空闲，因此需要注意避免出现不必要的等待。</p>
<h3 id="12-说说synchronized与ReentrantLock的区别"><a href="#12-说说synchronized与ReentrantLock的区别" class="headerlink" title="12. 说说synchronized与ReentrantLock的区别"></a>12. 说说synchronized与ReentrantLock的区别</h3><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是Java中用于实现同步的机制，它们都提供了<strong>线程安全的锁机制</strong>，但是存在一些关键的区别：</p>
<p>● 用法不同：<strong>synchronized 可以用于修饰普通方法、静态方法以及代码块，而 ReentrantLock 仅适用于代码块。</strong></p>
<p>● 获取锁和释放锁方式不同：<strong>Synchronized 是隐式锁</strong>，可以自动加锁和释放锁，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。<strong>ReentrantLock 是显式锁，需要手动加锁和释放锁</strong>， <strong>在使用之前需要先创建 ReentrantLock 对象</strong>，然后使用 lock 方法进行加锁，使用完之后再调用 unlock 方法释放锁。</p>
<p>● 锁类型：<strong>默认情况下，synchronized 是非公平锁，而 ReentrantLock 也是非公平锁，但可以手动将 ReentrantLock 配置为公平锁，允许线程按照它们请求锁的顺序获取锁。</strong></p>
<p> ● 中断响应： <strong>synchronized 无法直接响应中断，可能导致线程在锁上无限期地等待。ReentrantLock 具有响应中断的能力，可以在等待锁的过程中响应线程的中断请求，从而避免潜在的死锁情况。</strong> </p>
<p>● 底层实现：<strong>synchronized 是一个关键字，是在JVM层面通过监视器实现的，而 ReentrantLock 是基于AQS实现的</strong>。</p>
<h3 id="ReentrantLock的理解"><a href="#ReentrantLock的理解" class="headerlink" title="ReentrantLock的理解"></a>ReentrantLock的理解</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cxuanBlog/p/12155746.html">https://www.cnblogs.com/cxuanBlog/p/12155746.html</a></p>
<p>ReentrantLock 是<strong>一把<code>可重入锁</code>和<code>互斥锁</code><strong>，它具有与 synchronized 关键字相同的含有隐式监视器锁（monitor）的基本行为和语义，但是它比 synchronized 具有更多的方法和功能。</strong>实现了Lock接口和Serializable接口。</strong></p>
<h4 id="ReentrantLock基本方法"><a href="#ReentrantLock基本方法" class="headerlink" title="ReentrantLock基本方法"></a>ReentrantLock基本方法</h4><p><strong>两个构造函数：</strong>一个是默认的构造函数，不带任何参数；一个是带有 fair 参数的构造函数，通过fair参数判断是否为公平锁。new FairSync() 和new NonFairSync()</p>
<h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p><strong>公平锁：</strong>公平锁的特点是按照请求锁的顺序来分配锁，即先到先得。公平锁的底层实现使用了一个FIFO队列（First-In-First-Out），即等待队列。当一个线程请求锁时，如果锁已经被其他线程持有，请求线程会被放入等待队列的末尾，按照请求的顺序等待锁的释放。当锁被释放时，等待队列中的第一个线程会被唤醒并获得锁。</p>
<p><strong>非公平锁：</strong>非公平锁不考虑请求锁的顺序，它允许新的请求线程插队并尝试立即获取锁，而不管其他线程是否在等待。在ReentrantLock中，<strong>默认</strong>情况下创建的是非公平锁。非公平锁的底层实现中，有一个等待队列，但它不会严格按照请求的顺序来分配锁，而是根据线程竞争锁的情况来判断是否立即分配给新的请求线程。</p>
<p>底层实现中，无论是公平锁还是非公平锁，<strong>都使用了类似的同步器（Sync）来管理锁的状态和线程的竞争。</strong>不同之处在于如何处理等待队列中的线程，以及是否按照请求的顺序来分配锁。 需要注意的是，<strong>公平锁</strong>虽然遵循公平性原则，但在<strong>高并发情况下可能会引入较大的性能开销</strong>，因为每次都要维护一个有序的等待队列。而<strong>非公平锁则更加灵活</strong>，但<strong>可能导致某些线程一直获取不到锁</strong>。</p>
<h4 id="公平锁的加锁流程"><a href="#公平锁的加锁流程" class="headerlink" title="公平锁的加锁流程"></a>公平锁的加锁流程</h4><p>首先会取得当前线程，然后去读取当前锁的同步状态，同步状态为0表示无锁；如果是无锁（也就是没有加锁），说明是第一次上锁，首先会先判断一下队列中是否有比当前线程等待时间更长的线程（hasQueuedPredecessors）；然后通过 <code>CAS</code> 方法原子性的更新锁的状态，CAS 方法更新的要求涉及三个变量，<code>currentValue(当前线程的值)，expectedValue(期望更新的值)，updateValue(更新的值)</code>。如果读取的同步状态是1，说明已经线程获取到了锁，那么就先判断当前线程是不是获取锁的线程，如果是的话，记录一下获取锁的次数 + 1，也就是说，只有同步状态为 0 的时候是无锁状态。如果当前线程不是获取锁的线程，直接返回 false。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240805114745452.png" alt="image-20240805114745452"></p>
<h4 id="非公平锁的加锁流程"><a href="#非公平锁的加锁流程" class="headerlink" title="非公平锁的加锁流程"></a>非公平锁的加锁流程</h4><p>非公平锁的加锁步骤和公平锁的步骤只有两处不同，一处是非公平锁在加锁前会直接使用 CAS 操作设置同步状态，如果设置成功，就会把当前线程设置为偏向锁的线程；一处是 CAS 操作失败执行 <code>tryAcquire</code> 方法，读取线程同步状态，如果未加锁会使用 CAS 再次进行加锁，不会等待 <code>hasQueuedPredecessors</code> 方法的执行，达到只要线程释放锁就会加锁的目的。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240805135140025.png" alt="image-20240805135140025"></p>
<h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p><strong>AQS，全称 <a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/aqs.html">AbstractQueuedSynchronizer</a>，是Java并发编程中的基石。</strong> 作为一个抽象类，它为构建锁和其他同步器提供了一个高效、灵活的框架。</p>
<p>AQS通过两种主要的锁机制——<strong>排他锁和共享锁</strong>——来控制线程对共享资源的访问。</p>
<p><strong>排他锁，又称为独占锁，确保在多个线程竞争同一资源时，只有一个线程能够访问该资源。</strong> AQS内部使用<strong>同步状态</strong>来管理这一过程：<strong>状态为0表示锁空闲，大于0表示锁被占用，小于0 就表示有线程在等待。</strong> </p>
<p><strong>而共享锁则允许多个线程同时访问资源，但控制权只能由一个线程持有。</strong> AQS实现共享锁的方式与排他锁相似，同样依赖于同步状态。</p>
<p><strong>AQS还采用了FIFO等待队列来管理线程，确保它们有序地等待和获取锁资源。</strong>当锁被释放时，等待队列中的下一个线程才会获得锁然后继续执行。 <strong>要使用AQS，需要继承该类并实现关键的抽象方法，这些方法定义了锁的获取、释放、阻塞和唤醒逻辑。</strong> 总的来说，AQS是Java并发编程中不可或缺的组件，它为线程同步提供了强大的支持。</p>
<h3 id="13-常见同步工具类"><a href="#13-常见同步工具类" class="headerlink" title="13. 常见同步工具类"></a>13. 常见同步工具类</h3><h4 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/aqs.html#semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><strong>Semaphore（信号量）</strong></a></h4><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p><code>Semaphore</code> 的使用简单，我们这里假设有 <code>N(N&gt;5)</code> 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></tbody></table></figure>

<p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p>
<p><code>Semaphore</code> 有两种模式：</p>
<ul>
<li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li><strong>非公平模式：</strong> 抢占式的;</li>
</ul>
<p><code>Semaphore</code> 对应的两个构造方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> {</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> {</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>
<p><code>Semaphore</code> 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。</p>
<p><strong>原理</strong></p>
<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>
<p>以无参 <code>acquire</code> 方法为例，调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt; 0</code> 的话，则表示可以获取成功，如果 <code>state &lt;= 0</code> 的话，则表示许可证数量不足，获取失败。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取1个许可证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个或者多个许可证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">permits</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="keyword">permits</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>acquireSharedInterruptibly</code>方法是 <code>AbstractQueuedSynchronizer</code> 中的默认实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享模式下获取许可证，获取成功则返回，失败则加入等待队列，挂起线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 尝试获取许可证，arg为获取许可证个数，当获取失败时,则创建一个节点加入等待队列，挂起当前线程。</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch(倒计时器)"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/aqs.html#countdownlatch-%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8">CountDownLatch(倒计时器)</a></h4><p><strong>介绍</strong></p>
<p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>
<p><strong>原理</strong></p>
<p><code>CountDownLatch</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。这个我们通过 <code>CountDownLatch</code> 的构造方法即可看出。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> {</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> {</span><br><span class="line">    Sync(<span class="type">int</span> count) {</span><br><span class="line">        setState(count);</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当线程调用 <code>countDown()</code> 时，其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>，直至 <code>state</code> 为 0 。当 <code>state</code> 为 0 时，表示所有的线程都调用了 <code>countDown</code> 方法，那么在 <code>CountDownLatch</code> 上等待的线程就会被唤醒并继续执行.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// Sync 是 CountDownLatch 的内部类 , 继承了 AbstractQueuedSynchronizer</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h4><p><strong>介绍</strong></p>
<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p>
<p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p>
<p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。<strong>它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</strong></p>
<p><strong>原理</strong></p>
<p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次拦截的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"><span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="14-悲观锁与乐观锁"><a href="#14-悲观锁与乐观锁" class="headerlink" title="14. 悲观锁与乐观锁"></a>14. 悲观锁与乐观锁</h3><p><strong>什么是悲观锁</strong></p>
<p><strong>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。</strong>也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</p>
<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performSynchronisedTask</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">        <span class="comment">// 需要同步的操作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">   <span class="comment">// 需要同步的操作</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p>
<p><strong>什么是乐观锁</strong></p>
<p><strong>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</strong></p>
<p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试（悲观锁的开销是固定的），这样同样会非常影响性能，导致 CPU 飙升。</p>
<p><strong>如何实现乐观锁</strong></p>
<p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p>
<ul>
<li>版本号机制</li>
</ul>
<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<ul>
<li>CSA算法</li>
</ul>
<p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。<strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>
<p>CAS 涉及到三个操作数：<strong>V</strong>：要更新的变量值(Var)；<strong>E</strong>：预期值(Expected)；<strong>N</strong>：拟写入的新值(New)</p>
<p><strong>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</strong></p>
<p><strong>CSA算法中的ABA问题</strong></p>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p>
<p><strong>解决思路：在变量前面追加版本号或者时间戳</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</li>
<li>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</li>
<li>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</li>
<li>CAS 算法的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。</li>
</ul>
<h3 id="17-为什么wait和notify方法要在同步块中调用"><a href="#17-为什么wait和notify方法要在同步块中调用" class="headerlink" title="17. 为什么wait和notify方法要在同步块中调用"></a>17. 为什么wait和notify方法要在同步块中调用</h3><p>当使用 wait() 和 notify() 方法时，需要将它们放在同步块内，这是因为：</p>
<p><strong>1 互斥性： 多线程环境下，我们希望在同一时刻只有一个线程能够执行 wait()、notify() 或 notifyAll() 方法。</strong>使用同步块（synchronized）提供了这种互斥性，避免多线程并发修改的问题。 </p>
<p><strong>2 上下文切换： 当一个线程调用 wait() 时，它会暂时放弃执行权并释放对象的锁。</strong>如果不在同步块内调用 wait()，线程可能在不合适的时机被唤醒，导致混乱。同步块内的 wait() 确保线程在正确的上下文中被唤醒，可以继续执行并获取锁。 </p>
<p><strong>3 安全性： 如果不在同步块内使用 wait()、notify() 或 notifyAll()，多个线程可能同时访问和修改同一个共享对象的状态，可能引发竞态条件，导致程序行为不确定。</strong>同步块（synchronized）可以确保对这些方法的访问是原子的，避免了潜在的并发问题。 </p>
<p><strong>简而言之，将 wait() 和 notify() 方法包裹在同步块内，有助于确保线程间的协同和同步工作正确，避免了多线程问题，提高了程序的可靠性和安全性。</strong></p>
<h3 id="18-有三个线程T1-T2-T3，如何保证顺序执行"><a href="#18-有三个线程T1-T2-T3，如何保证顺序执行" class="headerlink" title="18. 有三个线程T1,T2,T3，如何保证顺序执行"></a>18. 有三个线程T1,T2,T3，如何保证顺序执行</h3><h4 id="1-使用join-方法"><a href="#1-使用join-方法" class="headerlink" title="1. 使用join()方法"></a>1. 使用join()方法</h4><p><strong>可以在每个线程内部使用 join() 方法来等待前一个线程执行完成。具体操作是在线程 T2 的 run() 方法中调用 T1.join()，在线程 T3 的 run() 方法中调用 T2.join()。这样可以确保 T1 在 T2 之前执行，T2 在 T3 之前执行。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="comment">// 线程 T1 的任务</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        T1.join(); <span class="comment">// 等待 T1 执行完成</span></span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 线程 T2 的任务</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">T3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        T2.join(); <span class="comment">// 等待 T2 执行完成</span></span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 线程 T3 的任务</span></span><br><span class="line">});</span><br><span class="line">T1.start();</span><br><span class="line">T2.start();</span><br><span class="line">T3.start();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-使用-CountDownLatch"><a href="#2-使用-CountDownLatch" class="headerlink" title="2. 使用 CountDownLatch"></a>2. 使用 CountDownLatch</h4><p><strong>可以使用 CountDownLatch 来控制线程的执行顺序。创建一个 CountDownLatch 对象，设置初始计数为 2，分别在 T1 和 T2 的线程内等待计数器减少到 0，然后释放 T3 线程。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"T1 running."</span>);</span><br><span class="line">    latch1.countDown(); <span class="comment">// T1 执行完后释放 latch1</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        latch1.await(); <span class="comment">// 等待 latch1 的释放</span></span><br><span class="line">      	System.out.println(<span class="string">"T2 running."</span>);</span><br><span class="line">        latch2.countDown(); <span class="comment">// T2 执行完后释放 latch2</span></span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        latch2.await(); <span class="comment">// 等待 latch2 的释放</span></span><br><span class="line">      	System.out.println(<span class="string">"T3 running."</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-使用-LockSupport"><a href="#3-使用-LockSupport" class="headerlink" title="3. 使用 LockSupport"></a>3. 使用 LockSupport</h4><p><strong>可以使用LockSupport的park和unpark来控制线程的执行顺序。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"T1 is running."</span>);</span><br><span class="line">            LockSupport.unpark(t2); <span class="comment">// 唤醒线程T2</span></span><br><span class="line">        });</span><br><span class="line"><span class="comment">//unpark() 方法可以提前授予一个许可，而 park() 方法会消耗这个许可。如果一个线程在被 unpark() 后还没有调用 park()，那么这个许可会被保留，直到线程调用 park()</span></span><br><span class="line">        t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞线程T2</span></span><br><span class="line">            System.out.println(<span class="string">"T2 is running."</span>);</span><br><span class="line">            LockSupport.unpark(t3); <span class="comment">// 唤醒线程T3</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞线程T3</span></span><br><span class="line">            System.out.println(<span class="string">"T3 is running."</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="20-如何确保线程安全"><a href="#20-如何确保线程安全" class="headerlink" title="20. 如何确保线程安全"></a>20. 如何确保线程安全</h3><p>确保线程安全可以通过多种方法和技术来实现。以下是一些常用的方法： </p>
<p><strong>1 使用synchronized关键字</strong>：synchronized关键字可以确保同一时刻只有一个线程可以执行某个代码块，从而避免了多个线程同时访问和修改共享资源的问题。 </p>
<p><strong>2 使用Atomic类：</strong>Java提供了多个原子类，如AtomicInteger、AtomicLong等，它们可以保证对基本数据类型的原子性操作，避免了使用synchronized关键字和volatile关键字的限制。 </p>
<p><strong>3 使用ReentrantLock类：</strong>ReentrantLock类是Java提供的一种可重入锁，与synchronized关键字类似，但它提供了更多的灵活性和功能。 </p>
<p><strong>4 使用线程安全的数据结构：</strong>Java提供了多种线程安全的数据结构，如<strong>ConcurrentHashMap、CopyOnWriteArrayList</strong>等，这些数据结构内部已经实现了线程安全，可以直接使用。 </p>
<p><strong>5 使用线程池：</strong>线程池可以避免创建和销毁线程的开销，并且可以有效地控制并发量，保证线程安全。 </p>
<p><strong>6 避免共享状态：</strong> 如果可能，尽量避免多个线程共享状态。将数据封装在线程内部，减少共享数据的需求。 </p>
<p><strong>7 使用线程安全的设计模式</strong>： 了解并应用线程安全的设计模式，如单例模式中的双重检查锁定等。 在实现线程安全时，还需要考虑其他问题，如避免死锁、合理地控制并发量等。同时，应该避免使用非线程安全的数据结构和方法，避免使用可能会引起竞态条件和数据不一致的操作。</p>
<h3 id="21-什么是可重入锁"><a href="#21-什么是可重入锁" class="headerlink" title="21. 什么是可重入锁"></a>21. 什么是可重入锁</h3><p>可重入锁可以简单理解为一个可以重复获取的锁，就像拿钥匙开锁一样，你可以反复用同一把钥匙开锁。<strong>这种锁在同一线程内是安全的，因为它可以被同一线程多次获取，而不会产生不一致的状态。</strong> </p>
<p>举个例子，假设有一个线程A在执行一个方法，同时这个方法内部又调用另一个方法，那么线程A可以重复获取同一个锁，而不会出现死锁的情况。因为同一线程可以多次获取同一个锁，所以这种锁机制避免了死锁的发生。 <strong>但是需要注意，在使用可重入锁时，必须保证在释放锁之前已经获取了该锁，否则会导致死锁。同时还需要保证在获取锁的时候没有嵌套地获取其他锁，否则也会导致死锁。</strong>另外，还必须保证在获取锁的时候没有阻塞其他线程，否则同样会导致死锁。 总之，可重入锁是一种安全的锁机制，可以避免死锁的发生。但是在使用时需要注意以上几点，以确保程序的正确性和安全性。</p>
<h3 id="22-锁的优化机制"><a href="#22-锁的优化机制" class="headerlink" title="22. 锁的优化机制"></a>22. 锁的优化机制</h3><p>是的，锁的优化机制是Java等编程语言中常见的一种提高并发性能的方法。锁的优化旨在减少锁的竞争，从而提高程序的性能。以下是一些常见的锁优化机制： </p>
<p><strong>1 偏向锁（Biased Locking）：</strong>偏向锁是一种针对无竞争情况的锁优化机制。它通过消除无谓的获取锁和释放锁的操作，提高了程序的性能。<strong>偏向锁会记录哪个线程正在访问某个对象，并且后续的访问请求如果是同一个线程，就可以直接访问，而不需要加锁。</strong> </p>
<p><strong>2 轻量级锁（Lightweight Locking）：</strong>轻量级锁是一种针对单线程访问的情况的锁优化机制。<strong>它通过使用标记位或者CAS操作来对共享资源进行加锁和解锁，避免了使用重量级锁时的上下文切换和内核态切换等开销。</strong> </p>
<p>**3 自旋锁（Spin Lock）： ** <strong>自旋锁是一种非阻塞的锁机制，当线程无法立即获取锁时，它会持续检查锁是否被释放，直到获取到锁为止</strong>。自旋锁可以减少线程的上下文切换开销，但在锁持有时间较长的情况下，会浪费CPU资源。</p>
<p><strong>4 适应性自旋锁（Adaptive Spin Lock）：</strong> <strong>适应性自旋锁是一种结合了自旋锁和阻塞锁的锁机制</strong>。在刚开始时，线程会采用自旋的方式来等待锁的释放，但随着时间的推移，如果锁仍然没有被释放，线程会逐渐切换到阻塞状态，从而减少CPU资源的浪费。 </p>
<p><strong>5 分段锁（Segmented Locking）：</strong>分段锁是一种针对共享资源过多的情况下的锁优化机制。<strong>它将共享资源分成多个段，每个线程只需要对其中一部分进行加锁和解锁操作，从而减少了锁的竞争和开销。</strong> </p>
<p><strong>6 乐观锁（Optimistic Locking）：</strong>乐观锁是一种基于冲突检测的锁机制。它假设多个线程同时访问和修改同一个数据的概率较小，因此在读取数据时不会加锁，而是在提交修改时检测是否存在冲突。如果存在冲突，则进行回滚或重试操作。<strong>乐观锁适用于读操作较多的场景。</strong> </p>
<p><strong>7 锁粗化（Lock Coarsening）：</strong>锁粗化是一种针对长时间持有锁的场景的优化策略。<strong>如果一个线程在短时间内需要连续多次加锁和解锁，那么可以将这些加锁和解锁操作合并成一个较大的加锁和解锁操作，从而减少了加锁和解锁的次数，提高了效率。</strong> </p>
<p>这些锁的优化机制都有各自的适用场景和优缺点，需要根据具体的业务需求和性能要求来选择合适的锁机制。</p>
<h3 id="23-什么是不可变对象，对写并发有什么帮助"><a href="#23-什么是不可变对象，对写并发有什么帮助" class="headerlink" title="23. 什么是不可变对象，对写并发有什么帮助"></a>23. 什么是不可变对象，对写并发有什么帮助</h3><p>不可变对象（Immutable object）是一种一旦创建后其状态就不能被修改的对象。在Java中，不可变对象包括String、基本类型的包装类（如Integer、Double等）等。</p>
<p>不可变对象对写并发有如下帮助： </p>
<p><strong>1 线程安全：不可变对象是线程安全的，因为它们不会被其他线程修改。</strong>因此，多个线程可以同时使用不可变对象，无需额外的同步措施。 </p>
<p><strong>2 减少锁竞争：由于不可变对象的状态不能被修改，因此不需要使用锁来保护对它的访问。</strong>这减少了锁竞争的可能性，从而提高了程序的性能。 </p>
<p><strong>3 缓存优化：由于不可变对象一旦创建后其状态就不能被修改，因此可以将它们用作缓存项。</strong>这是因为缓存项的值不会在缓存和使用之间发生改变，从而避免了因缓存项状态被修改而导致的缓存失效问题。 </p>
<p>需要注意的是，虽然不可变对象有以上优点，但它们也有一些缺点。例如，<strong>创建新的不可变对象比创建可变对象需要更多的内存，因为每次状态改变都需要创建新的对象。</strong>因此，在设计并发应用时，应根据具体需求和性能要求来决定是否使用不可变对象</p>
<h3 id="1-实现多线程的方法"><a href="#1-实现多线程的方法" class="headerlink" title="1. 实现多线程的方法"></a>1. 实现多线程的方法</h3><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p><strong>创建一个新的类，该类继承自<code>Thread</code>类，并重写<code>run()</code>方法。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Thread is running."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p><strong>创建一个新的类，实现<code>Runnable</code>接口，并实现<code>run()</code>方法。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Thread is running."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="使用Callable和Future"><a href="#使用Callable和Future" class="headerlink" title="使用Callable和Future"></a>使用<code>Callable</code>和<code>Future</code></h4><p><strong><code>Callable</code>与<code>Runnable</code>类似，但它可以返回一个结果或抛出一个异常。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"Result: "</span> + result);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-notify-and-notifyAll"><a href="#2-notify-and-notifyAll" class="headerlink" title="2. notify() and notifyAll()"></a>2. <code>notify()</code> and <code>notifyAll()</code></h3><p><strong><code>notify()</code></strong></p>
<ul>
<li><code>notify()</code>方法用于随机<strong>唤醒一个</strong>正在等待该对象锁的线程。</li>
<li>这个方法会<strong>唤醒单个线程</strong>，至于具体是哪一个线程，那是由JVM决定的。</li>
<li>被唤醒的线程将以通常的方式进行竞争，即重新尝试获取该对象的锁，并在成功获取后从等待状态恢复到可运行状态。</li>
<li>如果没有任何线程正在等待该对象锁，那么<code>notify()</code>方法调用没有任何效果。</li>
</ul>
<p><strong><code>notifyAll()</code></strong></p>
<ul>
<li><code>notifyAll()</code>方法用于<strong>唤醒所有</strong>正在等待该对象锁的线程。</li>
<li>这个方法会唤醒所有等待线程，让它们竞争对象的锁。</li>
<li>与<code>notify()</code>类似，被唤醒的线程也会尝试获取对象的锁，并在成功获取后恢复执行。</li>
<li>如果没有任何线程正在等待该对象锁，那么<code>notifyAll()</code>方法调用也没有任何效果。</li>
</ul>
<p><strong>区别总结</strong></p>
<ul>
<li><code>notify()</code>只随机<strong>唤醒一个线程</strong>，而<code>notifyAll()</code><strong>唤醒所有等待线程</strong>。</li>
<li><code>notify()</code><strong>可能会导致某些线程永远不会被唤醒</strong>（特别是当线程优先级不同时），而<code>notifyAll()</code>确保所有等待线程都有机会被唤醒。</li>
<li>使用<code>notify()</code>时，必须确保程序的每个部分都能被正确地唤醒，这可能会导致复杂和难以维护的代码。而<code>notifyAll()</code>则简单得多，尽管它在性能上可能不如<code>notify()</code>（因为所有线程都会竞争锁）。</li>
</ul>
<p>【指定线程唤醒】</p>
<h3 id="3-sleep-和-wait-有什么区别"><a href="#3-sleep-和-wait-有什么区别" class="headerlink" title="3. sleep() 和 wait() 有什么区别"></a>3. sleep() 和 wait() 有什么区别</h3><p>对于sleep()方法，我们首先要知道该方法是<strong>属于Thread类</strong>中的。而wait()方法，则是属于<strong>Object类</strong>中的。</p>
<p>sleep()方法导致了程序暂停执行指定的时间，让出CPU给其他线程，但是他的监控状态依然保持者，当<strong>指定的时间到了又会自动恢复运行状态</strong>。在调用sleep()方法的过程中，<strong>线程不会释放对象锁。</strong></p>
<p>当调用wait()方法的时候，<strong>线程会放弃对象锁，进入等待此对象的等待锁定池</strong>，只有针对此对象<strong>调用notify()方法后本线程才进入对象锁定池准备</strong>，获取对象锁进入运行状态。</p>
<p>【注】为什么 wait()方法不定义在Thread 中？为什么 sleep()方法定义在 Thread 中？</p>
<p>wait()是让<strong>获得对象锁的线程实现等待</strong>，会<strong>自动释放</strong>当前线程<strong>占有的对象锁</strong>。每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，<strong>自然是要操作对应的对象</strong>（Object）而非当前的线程（Thread）。因为 sleep()是让<strong>当前线程暂停执行</strong>，<strong>不涉及到对象类</strong>，也不需要获得对象锁。</p>
<h3 id="4-volatile是什么？可以保证有序性嘛？"><a href="#4-volatile是什么？可以保证有序性嘛？" class="headerlink" title="4. volatile是什么？可以保证有序性嘛？"></a>4. volatile是什么？可以保证有序性嘛？</h3><p><code>volatile</code>是Java中的一个关键字，用于修饰变量。当一个变量被声明为<code>volatile</code>时，它可以确保该变量的读写操作对所有线程立即可见，并且每次访问变量时都是直接从主内存中进行，而不是从线程的本地缓存中读取。</p>
<p><code>volatile</code>的主要作用是提供可见性保证，但它并不能保证操作的原子性。也就是说，<code>volatile</code>可以保证一个线程对<code>volatile</code>变量的修改，其他线程可以立即看到这个修改后的值，但它不能保证复合操作（如自增、自减或检查后再执行逻辑）的原子性。</p>
<p>关于有序性，<code>volatile</code>可以提供一定的有序性保证。Java内存模型（JMM）规定了<code>volatile</code>变量的特性：</p>
<ol>
<li><strong>重排序规则</strong>：为了确保<code>volatile</code>变量的可见性，JMM会禁止编译器和处理器对<code>volatile</code>变量周围的操作进行重排序。具体来说，<code>volatile</code>变量的写操作会先行发生于读操作，这意味着在一个线程写入<code>volatile</code>变量后，任何后续的读操作都会看到这个写入的值。</li>
<li><strong>内存屏障</strong>：在<code>volatile</code>变量的写操作前面会插入一个写屏障，在读操作后面会插入一个读屏障。这些内存屏障可以防止指令重排序，确保<code>volatile</code>变量操作的顺序性。</li>
</ol>
<p>然而，<code>volatile</code>并不能保证所有操作的有序性，它只保证<code>volatile</code>变量本身的读写操作不会被重排序到其它的操作之后。如果涉及到非<code>volatile</code>变量的操作，那么<code>volatile</code>并不能阻止这些操作的重排序。</p>
<p>总之，<code>volatile</code>可以保证：</p>
<ul>
<li>可见性：对<code>volatile</code>变量的修改对其他线程立即可见。</li>
<li>有序性：禁止对<code>volatile</code>变量操作的重排序。</li>
</ul>
<p>但它不保证：</p>
<ul>
<li>原子性：对<code>volatile</code>变量的复合操作不是原子的。</li>
<li>非volatile变量操作的有序性：<code>volatile</code>不能保证非<code>volatile</code>变量操作的有序性。</li>
</ul>
<h3 id="5-Thread类中的-start-和-run-有什么区别"><a href="#5-Thread类中的-start-和-run-有什么区别" class="headerlink" title="5. Thread类中的 start() 和 run() 有什么区别"></a>5. Thread类中的 start() 和 run() 有什么区别</h3><p><code>Thread</code>类中的<code>start()</code>和<code>run()</code>方法是多线程编程中非常关键的两个方法，它们之间的区别主要体现在以下几个方面：</p>
<ol>
<li><strong>调用效果</strong>：<ul>
<li><code>start()</code>：启动一个新线程，并执行该线程的<code>run()</code>方法。每个线程只能启动一次，如果重复调用<code>start()</code>，会抛出<code>IllegalThreadStateException</code>。</li>
<li><code>run()</code>：只是在当前线程中调用<code>run()</code>方法中的代码，并不启动新线程。<code>run()</code>可以被重复调用。</li>
</ul>
</li>
<li><strong>线程状态</strong>：<ul>
<li><code>start()</code>：调用<code>start()</code>方法后，线程进入<code>RUNNABLE</code>状态，等待CPU分配时间片执行。</li>
<li><code>run()</code>：调用<code>run()</code>方法后，线程继续在当前状态执行<code>run()</code>中的代码，不会改变线程状态。</li>
</ul>
</li>
<li><strong>执行上下文</strong>：<ul>
<li><code>start()</code>：会在新的线程上下文中执行<code>run()</code>方法。</li>
<li><code>run()</code>：在调用<code>run()</code>的线程上下文中执行，不会创建新的执行线程。</li>
</ul>
</li>
<li><strong>继承与实现</strong>：<ul>
<li><code>start()</code>：是<code>Thread</code>类的方法，用于启动线程。</li>
<li><code>run()</code>：是<code>Runnable</code>接口的方法，<code>Thread</code>类实现了<code>Runnable</code>接口，因此也有<code>run()</code>方法。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><code>start()</code>：当你需要启动一个新的线程并执行任务时使用。</li>
<li><code>run()</code>：当你需要在当前线程中执行任务，而不需要创建新线程时使用。</li>
</ul>
</li>
</ol>
<h3 id="6-为什么wait-notify-和-notifyAll-这些方法不在Thread类中"><a href="#6-为什么wait-notify-和-notifyAll-这些方法不在Thread类中" class="headerlink" title="6.为什么wait(), notify() 和 notifyAll()这些方法不在Thread类中"></a>6.为什么<code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code>这些方法不在Thread类中</h3><p><code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 这些方法不在 <code>Thread</code> 类里面，而是在 <code>Object</code> 类里面，这是<strong>因为它们是与同步相关的操作，而同步是基于对象的，而不是基于线程的。</strong></p>
<p><strong>在Java中，每个对象都有一个监视器（monitor），也称为锁</strong>。线程可以通过获取这个锁来获得对对象的独占访问权。<strong>当线程调用一个对象的 <code>wait()</code> 方法时，它会在该对象上释放锁并进入等待状态，直到另一个线程在同一对象上调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法来唤醒它</strong>。</p>
<p>这些方法与对象关联的原因如下：</p>
<ol>
<li><strong>同步是基于对象的</strong>：在Java中，任何对象都可以作为锁使用。当一个线程进入一个同步块（synchronized block）时，它会获取与括号内对象关联的锁。因此，等待和通知机制也是基于这个锁的。</li>
<li><strong>等待和通知是线程间通信的一部分</strong>：线程可能会在某个条件不满足时调用 <code>wait()</code> 方法进入等待状态，然后在条件满足时被其他线程通过 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒。这种通信是线程之间的，而不是线程内部的。</li>
<li><strong>共享状态</strong>：通常，线程在共享资源或状态上进行协作。这些资源或状态通常是由对象表示的。因此，等待和通知方法应该与这些共享对象相关联，而不是与线程相关联。</li>
<li><strong>设计简洁性</strong>：将等待和通知机制放在 <code>Object</code> 类中，使得任何对象都能够提供这种机制，而不需要为每个类都定义这些方法。这简化了Java语言的设计。</li>
</ol>
<h3 id="7-为什么wait和notify方法要在同步块中调用？"><a href="#7-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="7. 为什么wait和notify方法要在同步块中调用？"></a>7. 为什么wait和notify方法要在同步块中调用？</h3><p>在Java中，<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法必须在同步块（synchronized block）或同步方法（synchronized method）中调用，这是因为这些方法是用来控制对共享资源的访问和线程之间的协调的。下面是为什么这些方法需要在同步块中调用的几个原因：</p>
<ol>
<li><strong>锁定机制</strong>：**<code>wait()</code>方法会使当前线程释放它所持有的监视器（monitor），即锁，并进入等待状态。**为了释放锁，线程必须已经持有锁。同样，<code>notify()</code>和<code>notifyAll()</code>方法需要线程持有锁才能通知其他正在等待相同锁的线程。这些操作必须在同步块中执行，以确保线程在调用这些方法时确实持有锁。</li>
<li><strong>线程安全</strong>：同步块或方法确保了一次只有一个线程可以执行特定的代码段。这避免了在多个线程同时尝试调用<code>wait()</code>、<code>notify()</code>或<code>notifyAll()</code>时可能出现的竞态条件和数据不一致的问题。</li>
<li><strong>条件队列管理</strong>：当线程调用<code>wait()</code>方法时，它会被添加到该对象的等待队列（也称为条件队列）中。<code>notify()</code>和<code>notifyAll()</code>方法负责从等待队列中唤醒线程。这些队列的管理需要与锁的获取和释放紧密协调，以确保线程安全地等待和被唤醒。</li>
<li><strong>内存可见性</strong>：同步块或方法不仅保证了操作的原子性和线程之间的可见性，还确保了在调用<code>wait()</code>之前对共享变量的修改对其他线程可见，并在从<code>wait()</code>返回后能够看到其他线程对共享变量的最新修改。</li>
</ol>
<p>如果在没有同步的情况下调用这些方法，Java虚拟机会抛出<code>IllegalMonitorStateException</code>，因为这些方法的正确行为依赖于线程当前是否持有监视器。</p>
<h3 id="8-Java中interrupted-和-isInterrupted方法的区别？"><a href="#8-Java中interrupted-和-isInterrupted方法的区别？" class="headerlink" title="8. Java中interrupted 和 isInterrupted方法的区别？"></a>8. Java中<code>interrupted</code> 和 <code>isInterrupted</code>方法的区别？</h3><p>在Java中，<code>interrupted()</code>和<code>isInterrupted()</code>方法是用来检查线程是否被中断的，但它们之间有一些关键的区别：</p>
<ol>
<li><strong><code>interrupted()</code>方法</strong>：<ul>
<li><code>interrupted()</code>是一个静态方法，它检查当前线程是否被中断，并清除中断状态。</li>
<li>如果线程被中断，<code>interrupted()</code>方法会返回<code>true</code>，并将中断状态设置为<code>false</code>。</li>
<li><code>interrupted()</code>方法会访问当前线程的中断状态，即调用<code>Thread.currentThread().isInterrupted()</code>。</li>
</ul>
</li>
<li><strong><code>isInterrupted()</code>方法</strong>：<ul>
<li><code>isInterrupted()</code>是一个实例方法，它检查调用该方法的线程对象是否被中断。</li>
<li>如果线程被中断，<code>isInterrupted()</code>方法返回<code>true</code>，但不会改变线程的中断状态。</li>
<li><code>isInterrupted()</code>方法可以用于检查任何线程的中断状态，而不仅仅是当前线程。</li>
</ul>
</li>
</ol>
<p>简而言之，<code>interrupted()</code>方法是用来检查并清除当前线程的中断状态，而<code>isInterrupted()</code>方法是用来检查指定线程的中断状态而不改变它。</p>
<h3 id="12-什么是线程安全？-Vertor是一个线程安全类嘛-是的-？"><a href="#12-什么是线程安全？-Vertor是一个线程安全类嘛-是的-？" class="headerlink" title="12. 什么是线程安全？ Vertor是一个线程安全类嘛(是的)？"></a>12. 什么是线程安全？ <code>Vertor</code>是一个线程安全类嘛(是的)？</h3><p>线程安全就是说多线程访问同一段代码，不会产生不确定的结果。</p>
<p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p>
<p><strong>（1）不可变</strong></p>
<p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>
<p><strong>（2）绝对线程安全</strong></p>
<p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code></p>
<p><strong>（3）相对线程安全</strong></p>
<p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现<code>ConcurrentModificationException</code>，也就是<strong>fail-fast机制</strong>。</p>
<p><strong>（4）线程非安全</strong></p>
<p>这个就没什么好说的了，<code>ArrayList</code>、LinkedList、HashMap等都是线程非安全的类</p>
<h3 id="13-Thread类中的yield方法有什么作用？"><a href="#13-Thread类中的yield方法有什么作用？" class="headerlink" title="13. Thread类中的yield方法有什么作用？"></a>13. Thread类中的yield方法有什么作用？</h3><p><code>Thread</code>类中的<code>yield()</code>方法是一个静态方法，它用于告知当前线程愿意让出CPU的使用权，让其他线程有机会运行。调用<code>yield()</code>方法的效果是，当前线程从运行状态（RUNNABLE）变为就绪状态（READY），从而允许线程调度器选择其他线程来运行。</p>
<p>然而，<code>yield()</code>方法并不保证一定会让出CPU。它只是建议线程调度器，当前线程愿意让出CPU，但实际上线程调度器可能会忽略这个建议。因此，<code>yield()</code>方法的效果取决于线程调度器的实现和当前系统的状态。</p>
<h3 id="18-java程序的执行"><a href="#18-java程序的执行" class="headerlink" title="18. java程序的执行"></a>18. java程序的执行</h3><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240430142116566.png" alt="image-20240430142116566"></p>
<h3 id="19-锁的优化机制"><a href="#19-锁的优化机制" class="headerlink" title="19. 锁的优化机制"></a>19. 锁的优化机制</h3><p>锁的状态从低到高依次为<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>，升级的过程就是从低到高，降级在一定条件也是有可能发生的。</p>
<p><strong>自旋锁</strong>：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。</p>
<p><strong>自适应锁</strong>：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</p>
<p><strong>锁消除</strong>：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p>
<p><strong>锁粗化</strong>：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外</p>
<p><strong>偏向锁</strong>：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以用过设置-XX:+UseBiasedLocking开启偏向锁。</p>
<p><strong>轻量级锁</strong>：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试自旋来获得锁。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240430142733799.png" alt="image-20240430142733799"></p>
<h3 id="20-进程和线程的区别"><a href="#20-进程和线程的区别" class="headerlink" title="20. 进程和线程的区别"></a>20. 进程和线程的区别</h3><p><strong>进程（Process）</strong></p>
<ol>
<li><strong>定义</strong>：进程是操作系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间、数据栈和程序计数器。</li>
<li><strong>资源</strong>：进程之间相互独立，拥有独立的内存空间和资源。</li>
<li><strong>调度</strong>：进程的创建、切换和撤销都需要操作系统进行较多的资源操作，如内存分配。</li>
<li><strong>通信</strong>：进程间通信（IPC）通常需要借助操作系统提供的机制，如管道、消息队列、共享内存等。</li>
<li><strong>执行</strong>：进程的创建和撤销开销较大，切换速度慢。</li>
</ol>
<p><strong>线程（Thread）</strong></p>
<ol>
<li><strong>定义</strong>：线程是进程内的执行单元，是CPU调度和分派的基本单位。一个进程可以有多个线程，它们共享进程的资源，如内存空间、数据栈和程序计数器。</li>
<li><strong>资源</strong>：线程之间共享进程的资源，包括内存空间。</li>
<li><strong>调度</strong>：线程的创建、切换和撤销相对进程开销较小。</li>
<li><strong>通信</strong>：线程间可以直接通过共享内存进行通信，不需要借助系统调用。</li>
<li><strong>执行</strong>：线程的创建和撤销开销较小，切换速度快。</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li>进程是资源分配的单位，线程是执行的单位。</li>
<li>进程间通信需要系统调用，线程间通信直接通过共享内存。</li>
<li>进程的创建和撤销开销大，线程的开销小。</li>
<li>进程间相互独立，线程间共享资源。</li>
</ul>
<p>在多线程环境下，线程通常比进程更加轻量级，可以提高应用程序的并发性能。然而，进程也有其优势，如更好的隔离性和更安全的数据共享。</p>
<h3 id="23-线程安全需要保证几个基本特征？"><a href="#23-线程安全需要保证几个基本特征？" class="headerlink" title="23. 线程安全需要保证几个基本特征？"></a>23. 线程安全需要保证几个基本特征？</h3><p><strong>原子性</strong>：简单来说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</p>
<p><strong>可见性</strong>：是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。</p>
<p><strong>有序性</strong>：保证线程内串行语义，避免指令重排等</p>
<h3 id="24-线程之间的通信"><a href="#24-线程之间的通信" class="headerlink" title="24. 线程之间的通信"></a>24. 线程之间的通信</h3><p>线程之间的通信有两种方式：共享内存和消息传递。</p>
<p><strong>共享内存</strong>：在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p><strong>消息传递</strong>：在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 wait() 和 notify() ，或者 <code>BlockingQueue</code> 。</p>
<h3 id="25-CSA"><a href="#25-CSA" class="headerlink" title="25. CSA"></a>25. CSA</h3><h4 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h4><p>CAS（Compare and Swap，比较并交换）是一种硬件指令，用于实现无锁的数据结构。CAS的原理是：</p>
<ol>
<li><strong>比较</strong>：首先，它会将内存中的值与一个预期的值进行比较。</li>
<li><strong>交换</strong>：如果内存中的值与预期的值相匹配，它就会将内存中的值更新为新值。</li>
<li><strong>成功与失败</strong>：如果比较成功，即内存中的值与预期值相匹配，则交换操作成功，CAS会返回<code>true</code>。如果比较失败，即内存中的值与预期值不匹配，则交换操作失败，CAS会返回<code>false</code>。</li>
</ol>
<p>CAS的原理基于CPU提供的原子操作指令，如<code>cmpxchg</code>（比较并交换）指令。CAS操作是原子的，这意味着在比较和交换的过程中，不会有其他线程能够修改内存中的值。这保证了在多线程环境下，CAS操作是线程安全的。</p>
<h4 id="CSA的缺点？"><a href="#CSA的缺点？" class="headerlink" title="CSA的缺点？"></a>CSA的缺点？</h4><p>CAS（Compare and Swap，比较并交换）是一种高效的同步机制，用于实现无锁的数据结构。尽管CAS在多线程环境下提供了很好的性能，但它也存在一些缺点：</p>
<ol>
<li><strong>ABA问题</strong>：CAS操作中的比较是基于内存地址和值进行的，如果两个线程同时执行CAS操作，并且第一个线程成功更新了内存中的值，而第二个线程仍然使用旧的值进行比较，那么它可能会误认为值没有变化，从而导致数据不一致。为了解决这个问题，通常需要引入版本号或者时间戳来跟踪值的变化。</li>
<li><strong>循环时间长</strong>：当一个线程执行CAS操作失败时，它需要等待并再次尝试执行CAS操作。如果这个线程一直在循环中执行CAS操作而没有成功，它会浪费大量的CPU时间。</li>
<li><strong>伪共享</strong>：伪共享是指当多个变量位于同一个缓存行时，即使这些变量是独立的，更新其中一个变量也可能会影响其他变量。在多核处理器上，这可能会导致性能问题。</li>
<li><strong>性能开销</strong>：尽管CAS操作本身很快，但当它失败时，可能会导致线程挂起和唤醒的开销，这可能会抵消CAS操作的性能优势。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：CAS操作通常只能保证对一个共享变量的原子操作，如果要同时更新多个共享变量，则需要其他同步机制。</li>
</ol>
<p>为了克服这些缺点，Java提供了一些高级的同步类，如<code>AtomicInteger</code>、<code>AtomicReference</code>等，这些类在内部实现了CAS操作，并提供了解决ABA问题的机制。此外，还有一些高级的数据结构，如<code>AtomicMarkableReference</code>，它们能够同时支持CAS操作和标记操作，以解决更复杂的问题。</p>
<h3 id="27-引用类型有哪些？有什么区别？"><a href="#27-引用类型有哪些？有什么区别？" class="headerlink" title="27. 引用类型有哪些？有什么区别？"></a>27. 引用类型有哪些？有什么区别？</h3><p>引用类型主要分为强软虚弱四种：</p>
<ol>
<li><strong>强引用（Strong Reference）</strong>：这是最常见的引用类型。如果一个对象有强引用指向它，那么这个对象就不会被垃圾收集器回收，直到强引用被解除或对象被垃圾收集器标记为不可达。</li>
<li><strong>软引用（Soft Reference）</strong>：软引用是指向那些有用但不是必需的对象的引用。如果内存不足，垃圾收集器会回收软引用指向的对象，以便为其他对象腾出空间。</li>
<li><strong>弱引用（Weak Reference）</strong>：弱引用是指向那些非必需且不太可能被使用的对象的引用。垃圾收集器会定期检查弱引用指向的对象，如果对象不再被任何强引用或软引用所指向，那么垃圾收集器会立即回收该对象。</li>
<li><strong>虚引用（Phantom Reference）</strong>：虚引用也称为幻象引用，它指向那些只被虚引用所引用的对象。当对象被垃圾收集器回收时，垃圾收集器会发送一个通知给虚引用。虚引用不能用来获取对象实例，因为它们总是为<code>null</code>。</li>
</ol>
<h3 id="30-多线程有什么用"><a href="#30-多线程有什么用" class="headerlink" title="30. 多线程有什么用"></a>30. 多线程有什么用</h3><ol>
<li>发挥多核CPU的优势</li>
<li>防止阻塞</li>
<li>便于建模</li>
</ol>
<h3 id="31-JMM内存模型的理解，为什么需要JMM？"><a href="#31-JMM内存模型的理解，为什么需要JMM？" class="headerlink" title="31. JMM内存模型的理解，为什么需要JMM？"></a>31. JMM内存模型的理解，为什么需要JMM？</h3><p>JMM的<strong>主要目的是解决多线程环境下变量访问的可见性和一致性问题</strong>，确保Java程序在多线程环境中正确地执行。</p>
<h4 id="JMM的必要性"><a href="#JMM的必要性" class="headerlink" title="JMM的必要性"></a>JMM的必要性</h4><ol>
<li><strong>内存可见性</strong>：在多线程环境下，一个线程对变量的修改需要及时对其他线程可见。JMM通过同步机制（如<code>synchronized</code>关键字、<code>volatile</code>关键字等）来保证内存可见性。</li>
<li><strong>原子性</strong>：JMM确保基本数据类型的读取和赋值操作是原子性的，不会被其他线程中断。</li>
<li><strong>有序性</strong>：JMM确保程序执行的顺序按照代码的先后顺序执行，除非存在指令重排。</li>
<li><strong>主内存与工作内存</strong>：JMM定义了主内存（Main Memory）和工作内存（Working Memory）的概念。工作内存是每个线程的私有内存，而主内存是所有线程共享的内存。JMM规定了主内存与工作内存之间的交互规则。</li>
</ol>
<h4 id="JMM的实现"><a href="#JMM的实现" class="headerlink" title="JMM的实现"></a>JMM的实现</h4><p>JMM的实现依赖于JVM的实现。不同的JVM实现可能会有不同的内存模型实现方式。例如，HotSpot JVM实现了JMM，并提供了一系列的同步机制来实现JMM的要求。</p>
<h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>JMM提供了多种同步机制来实现内存可见性、原子性和有序性：</p>
<ol>
<li><strong>synchronized</strong>：用于方法或代码块的同步，确保同一时刻只有一个线程可以执行同步代码。</li>
<li><strong>volatile</strong>：用于变量的同步，确保变量对所有线程的可见性和有序性。</li>
<li><strong>final</strong>：用于变量的同步，确保变量在初始化后不会被改变。</li>
<li><strong>原子类</strong>：如<code>AtomicInteger</code>、<code>AtomicLong</code>等，提供原子操作的类，确保基本数据类型的操作是原子的。</li>
<li><strong>Lock接口</strong>：如<code>ReentrantLock</code>、<code>ReadWriteLock</code>等，提供了更灵活的同步机制。</li>
<li><strong>其他同步机制</strong>：如<code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>等，用于线程间的同步和通信。</li>
<li><strong>Happens-Before规则：</strong>happens-before 指的是 Java 内存模型中两项操作的顺序关系。Java 内存模型下一共有 8 条 happens-before 规则，如果线程间的操作无法从如下几个规则推导出来，那么它们的操作就没有顺序性保障，虚拟机或者操作系统就能随意地进行重排序，从而可能会发生并发安全问题。</li>
</ol>
<h3 id="32-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#32-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="32. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>32. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h3><p>乐观锁和悲观锁是数据库事务中用于处理数据冲突的两种机制。</p>
<h6 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a>悲观锁（Pessimistic Locking）</h6><p>悲观锁假设数据冲突是常态，因此在进行数据操作之前会锁定数据，直到操作完成才释放锁。这种方式可以确保在数据操作过程中不会被其他线程干扰，从而保证数据的完整性和一致性。</p>
<h6 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h6><p>乐观锁假设数据冲突是罕见的，因此在提交数据操作之前不会锁定数据，而是在提交时检查数据是否已经被其他线程修改。如果数据已被修改，通常会抛出一个异常或者返回一个错误状态。</p>
<h6 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h6><p>悲观锁的实现方式：</p>
<ol>
<li><strong>表级锁（Table Locking）</strong>：在数据库层面，表级锁会锁定整个表，直到操作完成。</li>
<li><strong>行级锁（Row Locking）</strong>：行级锁会锁定数据表中的行，允许其他线程读取和修改表中的其他行。</li>
<li><strong>意向锁（Intention Locking）</strong>：这是一种特殊的表级锁，用于表示事务的意图，即准备对表中的某些行进行修改。</li>
</ol>
<p>乐观锁的实现方式：</p>
<ol>
<li><strong>版本号（Version Number）</strong>：为表中的每行数据设置一个版本号字段，每次修改数据时递增这个字段的值。在提交更新时，检查版本号是否与预期值匹配。</li>
<li><strong>时间戳（Timestamp）</strong>：为表中的每行数据设置一个时间戳字段，每次修改数据时更新这个字段的值。在提交更新时，检查时间戳是否与预期值匹配。</li>
<li><strong>状态字段（Status Field）</strong>：为表中的每行数据设置一个状态字段，用于表示数据的状态。在提交更新时，检查状态字段是否与预期值匹配。</li>
</ol>
<p>在实现乐观锁时，通常需要在数据库中添加一个额外的字段来存储版本号或时间戳等信息。在提交更新之前，需要检查这个字段的值是否与预期值匹配。如果不匹配，则表示数据已被其他线程修改，需要采取相应的处理措施。</p>
<h6 id="选择乐观锁还是悲观锁："><a href="#选择乐观锁还是悲观锁：" class="headerlink" title="选择乐观锁还是悲观锁："></a>选择乐观锁还是悲观锁：</h6><ul>
<li>悲观锁适用于对数据一致性要求非常高、且并发操作较少的情况。</li>
<li>乐观锁适用于对数据一致性要求较高、且并发操作较多的情况。</li>
</ul>
<h3 id="33-什么是Daemon线程？它有什么意义？"><a href="#33-什么是Daemon线程？它有什么意义？" class="headerlink" title="33. 什么是Daemon线程？它有什么意义？"></a>33. 什么是Daemon线程？它有什么意义？</h3><p>Daemon线程是那些在后台提供支持服务的线程，它们不是程序执行的核心部分。当JVM中所有的用户线程（非守护线程）都死亡后，JVM会自动终止，这包括所有的Daemon线程。换句话说，Daemon线程是在JVM中有用但不是必需的线程。</p>
<p><strong>好处</strong>：</p>
<ol>
<li><strong>资源管理</strong>：当JVM中只剩下Daemon线程时，JVM可以安全地关闭，释放所有资源。</li>
<li><strong>后台服务</strong>：Daemon线程可以用于执行一些后台任务，如垃圾收集、文件监控等。这些任务不需要用户线程来完成，但是对程序的正常运行又至关重要。</li>
<li><strong>性能优化</strong>：在执行长时间运行的任务时，可以将非关键任务（如监控和清理）放在Daemon线程中执行，从而释放主线程和用户线程，提高程序的响应性和性能。</li>
</ol>
<h3 id="34-什么是多线程中的上下文切换"><a href="#34-什么是多线程中的上下文切换" class="headerlink" title="34. 什么是多线程中的上下文切换"></a>34. 什么是多线程中的上下文切换</h3><p>多线程中的上下文切换是指操作系统从当前正在运行的线程切换到另一个线程的过程。这个过程涉及到保存当前线程的执行状态，然后加载另一个线程的执行状态，并开始执行。上下文切换是多任务操作系统中的一个基本操作，它使得系统能够同时处理多个任务或线程。</p>
<p>上下文切换主要包括以下几个步骤：</p>
<ol>
<li><strong>保存当前线程的状态</strong>：操作系统需要保存当前线程的CPU寄存器状态、程序计数器、栈指针等关键信息。</li>
<li><strong>选择下一个线程</strong>：根据调度策略（如轮转调度、优先级调度等），选择下一个要执行的线程。</li>
<li><strong>加载新线程的状态</strong>：操作系统需要从线程的上下文（如线程栈）中加载新线程的CPU寄存器状态、程序计数器、栈指针等。</li>
<li><strong>恢复新线程的执行</strong>：加载新线程的状态后，操作系统开始执行新线程的代码。</li>
</ol>
<p>上下文切换是一个开销较大的操作，因为它涉及到大量的内存访问和CPU指令。频繁的上下文切换会严重影响系统的性能，因此现代操作系统和Java虚拟机（JVM）都采用了各种优化措施来减少上下文切换的频率和成本。</p>
<h3 id="35-CompletableFuture类"><a href="#35-CompletableFuture类" class="headerlink" title="35.CompletableFuture类"></a>35.CompletableFuture类</h3><p>CompletableFuture 类提供一种<strong>观察者模式机制</strong>，可以让任务执行完成后通知监听的一方。CompletableFuture 同时实现了 Future 接口和CompletionStage 接口。CompletionStage 接口描述了一个<strong>异步计算的阶段</strong>。很多计算可以<strong>分成多个阶段或步骤</strong>，此时可以通过它将所有步骤组合起来，<strong>形成异步计算的流水线</strong>。</p>
<p><strong>四个静态方法：</strong></p>
<ul>
<li>无返回值：<strong>run</strong>Async(Runnable r)；runAsync(Runnable r, Executor e)</li>
<li>有返回值：<strong>supply</strong>Async(Supplier&lt;\U&gt; s)；supplyAsync(Supplier&lt;\U&gt; s, Executor e)</li>
</ul>
<p>【注】没有指定 Executor 的方法，<strong>默认</strong>使用 <strong>ForkJoinPool()<strong>作为线程池执行异步代码，该线程池</strong>全局共享</strong>，可能会<strong>被其他任务占用</strong>，导致<strong>性能下降或者饥饿</strong>。</p>
<p><strong>CompletableFuture 类获得结果的方法</strong> —不完整</p>
<ul>
<li>get()阻塞等待；get(时间，单位)超时报异常；</li>
<li>join()和get区别：编译不用抛Interrupte异常；getNow(valueIfAbsent):没计算完就返回该值；</li>
</ul>
<p><strong>处理异步计算的结果</strong></p>
<ul>
<li>有返回值，可以访问异步结果—thenApply()：<strong>函数型接口</strong>，s-&gt;{处理上一步的结果 s，<strong>有返回值</strong> <strong>return;</strong>}</li>
<li>没有返回值，可以访问异步结果—thenAccept()：<strong>消费型接口</strong>；</li>
<li>没有返回值，不可以访问异步结果—thenRun()：方法参数是 <strong>Runnable</strong>；</li>
</ul>
<p><strong>处理异常结果</strong></p>
<p>handle()：跟 thenApply()的区别在于，有异常的时候，可以往下多走一步，根据带的异常参数可以进一步处理。</p>
<p><strong>CompletableFuture 的组合</strong></p>
<ul>
<li><strong>thenCompose()：</strong>将前一个任务的<strong>返回结果作为下一个任务的参数</strong>，它们之间存<strong>在着先后顺序</strong>。</li>
<li><strong>thenCombine()：</strong>会在<strong>两个任务都执行完成后</strong>，把两个任务的<strong>结果合并</strong>。两个任务并行。</li>
</ul>
<p><strong>并行运行多个 CompletableFuture（静态）</strong></p>
<ul>
<li>allOf()：并行运行多个 CompletableFuture，等<strong>所有任务都运行完</strong>成之后<strong>再返回结果</strong>；</li>
<li>anyOf()：返回<strong>最先执行完</strong>的<strong>任务结果</strong>。</li>
</ul>
<h3 id="36-线程池-star2-star2-star2-star2-star2"><a href="#36-线程池-star2-star2-star2-star2-star2" class="headerlink" title="36. 线程池 :star2::star2::star2::star2::star2:"></a>36. 线程池 :star2::star2::star2::star2::star2:</h3><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><p>合理利用线程池能够带来三个好处：</p>
<p><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗</p>
<p><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行</p>
<p><strong>提高线程的可管理性。</strong>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h4 id="常用的线程池有哪些？"><a href="#常用的线程池有哪些？" class="headerlink" title="常用的线程池有哪些？"></a>常用的线程池有哪些？</h4><ul>
<li><p><strong><code>newSingleThreadExecutor</code><strong>：</strong>创建一个单线程的线程池</strong>，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</li>
<li><p><strong><code>newFixedThreadPool</code><strong>：</strong>创建固定大小的线程池</strong>，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</p>
</li>
<li><p><strong><code>newCachedThreadPool</code><strong>：可</strong>根据实际情况调整线程数量</strong>的线程池。线程池的<strong>线程数量不确定</strong>，但若<strong>有空闲线程可以复用</strong>，则会优先使用可复用的线程。若<strong>所有线程均在工作</strong>，又有新的任务提交，则<strong>会创建新的线程处理任务</strong>。所有线程在当前任务执行完毕后，将<strong>返回线程池进行复用</strong>。</p>
</li>
<li><p><code>newScheduledThreadPool</code>：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个newSingleThreadExecutor</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 创建一个newfixedThreadPool</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 创建一个newCachedThreadPool</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 创建一个newScheduledThreadPool</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool();</span><br></pre></td></tr></tbody></table></figure>

<p>【注】为什么不使用已有的线程池方法创建线程：<strong>FixedThreadPool 和 <strong>Single</strong>ThreadExecutor:使用的是</strong>无界的 <strong>LinkedBlockingQueue</strong>，任务队列最大长度为 Integer.MAX_VALUE,<strong>可能堆积大量的请求，从而导致</strong> <strong>OOM</strong>。<strong>newCachedThreadPool</strong>使用的是 <strong>同步队列SynchronousQueue</strong>, 允许创建的线程数量为Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。<strong>newScheduledThreadPool</strong>使用的 <strong>无界的延迟阻塞队列DelayedWorkQueue</strong>，任务队列最大长度为Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</p>
<h4 id="Java线程池中任务队列-阻塞队列常用类型有哪些？"><a href="#Java线程池中任务队列-阻塞队列常用类型有哪些？" class="headerlink" title="Java线程池中任务队列/阻塞队列常用类型有哪些？"></a>Java线程池中任务队列/阻塞队列常用类型有哪些？</h4><p>在某些情况下，线程池的任务队列可以是阻塞队列。</p>
<p>在Java的<code>ExecutorService</code>接口中，线程池通常会<strong>使用一个队列来存储等待执行的任务</strong>。常见的队列类型有：</p>
<ul>
<li>:book: <strong><code>LinkedBlockingQueue</code><strong>：这是一个基于链表的</strong>阻塞队列</strong>，可以设置队列容量，如果不设置，默认容量为<code>Integer.MAX_VALUE</code>，即<strong>队列可以无限大</strong>。</li>
<li>:book: <strong><code>ArrayBlockingQueue</code><strong>：这是一个基于数组的</strong>阻塞队列</strong>，可以指定队列容量，如果队列已满，则新加入的元素将被阻塞。</li>
</ul>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**【区别】LinkedBlockingQueue和ArrayBlockingQueue的区别**</span></span><br><span class="line"></span><br><span class="line">​底层：ArrayBlockingQueue<span class="code">`基于数组`</span>，LinkedBlockingQueue<span class="code">`基于链表`</span></span><br><span class="line"></span><br><span class="line">​有界/无界：ArrayBlockingQueue是<span class="code">`有界的`</span>，LinkedBlockingQueue<span class="code">`近似无界`</span></span><br><span class="line"></span><br><span class="line">​初始化：ArrayBlockingQueue<span class="code">`初始化时必须分配大小`</span>，LinkedBlockingQueue<span class="code">`动态分配内存大小`</span></span><br><span class="line"></span><br><span class="line">​锁分离：ArrayBlockingQueue<span class="code">`生产和消费用的是同一个锁`</span>，LinkedBlockingQueue<span class="code">`生产用的是putLock,消费用的是takeLock`</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>:book: <strong><code>PriorityBlockingQueue</code><strong>：这是一个基于优先级的</strong>无界阻塞队列</strong>，通常用于优先级高的任务。元素必须<strong>实现</strong> <strong>Comparable接口</strong>或者<strong>在构造函数中传入</strong> <strong>Comparator对象</strong>，并且<strong>不能插入</strong> <strong>null</strong> <strong>元素</strong>。</p>
</li>
<li><p>:book: <strong><code>DelayQueue</code><strong>：</strong>延迟队列</strong>，其中的元素只有<strong>到了其指定的延迟时间</strong>，才从队列中出队。</p>
</li>
<li><p>**<code>PriorityQueue</code>**：这是一个非阻塞的优先级队列，通常用于优先级高的任务。</p>
</li>
<li><p>:book: <strong><code>SynchronousQueue</code><strong>：同步队列是一种</strong>不存储元素</strong>的阻塞队列。每个<strong>插入操作</strong>都必须<strong>等待对应</strong>的<strong>删除操作</strong>，反之删除操作也必须等待插入操作。因此，SynchronousQueue 通常用于线程之间的<strong>直接传递数据</strong>。</p>
</li>
</ul>
<p>[注]newCachedThreadPool创建线程池使用SynchronousQueue，会导致创建大量线程从而导致OOM</p>
<p>在创建<code>ThreadPoolExecutor</code>时，可以<strong>通过<code>setQueue(BlockingQueue&lt;Runnable&gt; workQueue)</code>方法来指定队列类型</strong>。队列的选择会影响线程池的性能和行为，例如：</p>
<ul>
<li>使用无界队列可以提高吞吐量，但可能会导致内存溢出。</li>
<li>使用有界队列可以限制内存使用，但可能会导致队列满时新任务被拒绝。</li>
</ul>
<p>选择合适的队列类型对于设计有效的线程池至关重要。通常，根据任务的特性、系统的内存限制和期望的性能指标来选择合适的队列类型。</p>
<h4 id="线程池原理知道吗？以及核心参数"><a href="#线程池原理知道吗？以及核心参数" class="headerlink" title="线程池原理知道吗？以及核心参数"></a>线程池原理知道吗？以及核心参数</h4><p>首先线程池有几个核心的参数概念：</p>
<ol>
<li><p>**核心线程数 **corePoolSize</p>
</li>
<li><p><strong>最大线程数</strong> maximumPoolSize</p>
</li>
<li><p><strong>活跃时间</strong> keepAliveTime</p>
</li>
<li><p><strong>unit</strong>  keepAliveTimede参数的时间单位</p>
</li>
<li><p><strong>工作队列</strong> workQueue</p>
</li>
<li><p><strong>线程工厂</strong> threadFactory</p>
</li>
<li><p><strong>拒绝策略</strong> RejectedExecutionHandler</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.MINUTES,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy())</span><br></pre></td></tr></tbody></table></figure>

<p>当提交一个新任务到线程池时，具体的执行流程如下：</p>
<ol>
<li><p>当我们提交任务，<strong>线程池会根据corePoolSize大小创建若干任务数量线程执行任务</strong>；</p>
</li>
<li><p>当任务的数量超过corePoolSize数量，<strong>后续的任务将会进入阻塞队列阻塞排队</strong>；</p>
</li>
<li><p>当阻塞队列也满了之后<strong>，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来执行任务</strong>，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程<strong>等待keepAliveTime之后被自动销毁</strong>；</p>
</li>
<li><p><strong>如果达到<code>maximumPoolSize</code>，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理</strong></p>
</li>
</ol>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240430165555822.png" alt="image-20240430165555822"></p>
<h4 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h4><p>主要有4种拒绝策略：</p>
<ol>
<li><p><strong><code>AbortPolicy</code><strong>：</strong>直接丢弃任务，抛出异常，这是默认策略</strong></p>
</li>
<li><p>**<code>CallerRunsPolicy</code>**：只用调用者所在的线程来处理任务 。 <code>ExecutorService</code>会检查当前线程是否是调用者线程（即提交任务的线程）(使用<code>Thread.currentThread()</code>)。如果当前线程是调用者线程，<code>ExecutorService</code>会将该任务重新提交给调用者线程执行。如果当前线程不是调用者线程，<code>ExecutorService</code>会抛出一个<code>RejectedExecutionException</code>异常，表明该任务被拒绝执行。</p>
</li>
<li><p><strong><code>DiscardOldestPolicy</code><strong>：</strong>丢弃等待队列中最旧</strong>的任务，并执行当前任务</p>
</li>
<li><p>**<code>DiscardPolicy</code>**：直接丢弃任务，也不抛出异常</p>
</li>
</ol>
<h4 id="线程池中核心线程数量大小怎么设置"><a href="#线程池中核心线程数量大小怎么设置" class="headerlink" title="线程池中核心线程数量大小怎么设置"></a>线程池中核心线程数量大小怎么设置</h4><p><em><em>CPU密集型：核心线程数 = N(CPU核心数量)+1 ———- IO密集型：核心线程数 = N(CPU核心数量)</em> 2</em>*     i7-12700的CPU核心数位12，所以我一般设置的核心线程数为13</p>
<p><strong>CPU密集型任务</strong>：比如像<strong>加解密，压缩、计算等一系列需要大量耗费 CPU 资源的任务</strong>，大部分场景下都是纯 CPU 计算。<strong>尽量使用较小的线程池，一般为CPU核心数+1。</strong>因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。 i7-12700的CPU核心数位12，所以我一般设置的核心线程数为24</p>
<p><strong>IO密集型任务：</strong>比如像 <strong>MySQL 数据库、文件的读写、网络通信等任务</strong>，这类任务不会特别消耗 CPU 资源，但是 IO 操作比较耗时，会占用比较多时间。<strong>可以使用稍大的线程池，一般为2*CPU核心数。</strong>IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。 </p>
<p>另外：<strong>线程的平均工作时间所占比例越高，就需要越少的线程</strong>；线程的平均等待时间所占比例越高，就需要越多的线程； 以上只是理论值，实际项目中建议在本地或者测试环境进行多次调优，找到相对理想的值大小。</p>
<h4 id="使用线程池（Executor框架）"><a href="#使用线程池（Executor框架）" class="headerlink" title="使用线程池（Executor框架）"></a>使用线程池（Executor框架）</h4><p>可以使用Executor框架中的线程池来管理和执行线程。通过ExecutorService接口的实现类，例如ThreadPoolExecutor，可以提交任务并由线程池管理线程的生命周期。 —  不推荐</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExecutor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Thread is running."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyExecutor</span>();</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        }</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) {</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"All threads are finished."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Java线程池中submit-和-execute-方法有什么区别"><a href="#Java线程池中submit-和-execute-方法有什么区别" class="headerlink" title="Java线程池中submit() 和 execute()方法有什么区别?"></a>Java线程池中submit() 和 execute()方法有什么区别?</h4><p>在Java的<code>ExecutorService</code>接口中，<code>submit()</code>和<code>execute()</code>方法用于提交任务到线程池执行，它们之间的主要区别在于返回值和任务的返回值处理：</p>
<ol>
<li><strong><code>execute()</code>方法</strong>：<ul>
<li><code>execute()</code>方法<strong>不接受返回值</strong>，它主要用于不需要返回值的后台任务。</li>
<li>它返回一个<code>null</code>值，表示不关心任务的执行结果。</li>
<li>它<strong>不抛出<code>UnsupportedOperationException</code>异常</strong>，因为<code>ExecutorService</code>接口的实现可以自由地选择是否支持返回值。</li>
</ul>
</li>
<li><strong><code>submit()</code>方法</strong>：<ul>
<li><code>submit()</code>方法<strong>接受一个实现了<code>Callable</code>接口的任务，这个任务可以返回一个值。</strong></li>
<li>它返回一个<code>Future</code>对象，该对象可以用来检查任务是否完成，以及获取任务的返回值。</li>
<li>如果任务抛出异常，<code>submit()</code>方法会捕获这个异常，并抛出<code>ExecutionException</code>。</li>
</ul>
</li>
</ol>
<h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><ul>
<li><p>RUNNING: 运行状态</p>
</li>
<li><p>SHUTDOWN: 关闭状态</p>
</li>
<li><p>STOP: 停止状态</p>
</li>
<li><p>TIDYING: 整理状态</p>
</li>
<li><p>TERMINATED: 销毁状态</p>
</li>
</ul>
<p>【注】SHUTDOWN和STOP状态的区别：<strong>SHUTDOWN会继续处理阻塞队列里的任务，不接受新任务；STOP不接受新任务也不处理阻塞队列里的任务。</strong></p>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240815104713021.png" alt="image-20240815104713021"></p>
<h3 id="基本的增删改查语句"><a href="#基本的增删改查语句" class="headerlink" title="基本的增删改查语句"></a>基本的增删改查语句</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="1-delete、drop、truncate区别"><a href="#1-delete、drop、truncate区别" class="headerlink" title="1. delete、drop、truncate区别"></a>1. delete、drop、truncate区别</h3><p><strong>delete、truncate只会删除数据，不会删除表结构，drop会删除整个表</strong></p>
<p>速度 drop&gt;truncate&gt;delete</p>
<p>delete 属于dml,操作可以回滚;truncate、drop属于ddl, 操作立即生效，不可以回滚</p>
<h3 id="2-3范式"><a href="#2-3范式" class="headerlink" title="2. 3范式"></a>2. 3范式</h3><p>第一范式(1NF)：<strong>每个列都不可以再拆分。</strong><br>第二范式(2NF)：在第一范式的基础上，<strong>非主键列完全依赖于主键，而不能是依赖于主键的一部分。</strong> <strong>— 不存在部分依赖</strong><br>第三范式(3NF)：在第二范式的基础上，<strong>非主键列只依赖于主键，不依赖于其他非主键。</strong> <strong>— 不存在传递依赖</strong></p>
<p><strong>目的是提高数据的一致性、完整性和减少冗余，从而提高数据库的性能和可维护性。</strong></p>
<h3 id="3-什么是内连接，左外连接，右外连接"><a href="#3-什么是内连接，左外连接，右外连接" class="headerlink" title="3. 什么是内连接，左外连接，右外连接"></a>3. 什么是内连接，左外连接，右外连接</h3><p>内联接（Inner Join）：匹配2张表中相关联的记录。不匹配的直接删除 </p>
<p>左外联接（Left Outer Join）：<strong>除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。</strong></p>
<p>右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。</p>
<p>全连接：匹配左右，左右没有的都置空</p>
<p>在判定左表和右表时，要根据表名出现在Outer Join的左右位置关系。</p>
<h3 id="4-说下数据库事务的理解"><a href="#4-说下数据库事务的理解" class="headerlink" title="4. 说下数据库事务的理解"></a>4. 说下数据库事务的理解</h3><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p><strong>数据库事务是指一系列数据库操作的逻辑单元，这些操作要么全部成功执行，要么全部回滚。</strong>它的目的是<strong>确保数据的一致性和完整性</strong>。<strong>事务具备4大特性，即原子性、一致性、隔离性和持久性</strong>： </p>
<p><strong>原子性(Atomicity)：</strong>事务中的所有操作要么全部执行成功，要么全部回滚到事务开始前的状态。如果在事务执行期间发生错误，系统将回滚所有已执行的操作，以保持数据的一致性。 </p>
<p><strong>一致性(Consistency)：</strong>事务的执行不会破坏数据库的完整性约束。在事务开始和结束时，数据库必须处于一致的状态。  </p>
<p>如小李转账100元给小白，不管操作是否成功，小李和小白的账户总额是不变的。  </p>
<p><strong>隔离性(Isolation)：</strong>事务的执行是相互隔离的，即每个事务对其他事务是透明的。并发执行的多个事务不会相互干扰，每个事务感知不到其他事务的存在。 </p>
<p><strong>持久性(Durability)：</strong>一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。 以上就是我对数据库事务的理解。</p>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p><strong>脏读</strong>：一个事务访问并修改数据，<strong>修改还未提交时另外一个事务访问该数据</strong>，导致使用的是未提交的事务，这是另外一个事务读到的数据就是脏数据。</p>
<p><strong>丢失修改</strong>：<strong>两个事务先后对同一个数据进行修改，导致一开始的那个修改被丢失了</strong></p>
<p><strong>不可重复读</strong>：一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，<strong>在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。</strong></p>
<p><strong>幻读</strong>：它发生在<strong>一个事务（T1）读取了几行数据</strong>，接着<strong>另一个并发事务（T2）插入了一些数据</strong>时。在随后的查询中，<strong>第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样</strong>，所以称为幻读。 —-   <strong>采用MVCC解决</strong></p>
<p>【注】<em>不可重复读和幻读的区别</em>：不可重复读的重点是<strong>修改</strong>，比如多次读取一条<strong>记录</strong>发现其中某些列的值<strong>被修改</strong>；幻读的重点在于<strong>新增或者删除</strong>，比如多次读取一条记录发现<strong>记录增多或减少</strong>了。</p>
<p>为了<strong>解决并发一致性问题和并发事务带来的问题</strong>，可以采用以下方法：</p>
<ol>
<li><strong>事务隔离级别：</strong>通过设置事务隔离级别来控制事务之间的并发操作，从而避免并发问题。</li>
<li><strong>数据库锁：</strong>通过在数据操作时对数据加锁来实现并发控制，避免并发问题。<ul>
<li><strong>乐观锁和悲观锁：</strong> 乐观锁和悲观锁是实现并发控制的两种方式。<strong>悲观锁</strong>通过在数据操作时对数据<strong>加锁</strong>来实现并发控制，而<strong>乐观锁</strong>则是在数据更新时<strong>检查数据版本号</strong>，如果版本号不一致，则表示数据已被其他事务修改，需要回滚。</li>
</ul>
</li>
<li><strong>数据库事务处理：</strong>使用<strong>数据库事务处理</strong>可以保证数据库操作的原子性、一致性、隔离性和持久性，从而避免并发问题。</li>
</ol>
<h4 id="事务隔离级别？mysql的默认隔离级别？-star"><a href="#事务隔离级别？mysql的默认隔离级别？-star" class="headerlink" title="事务隔离级别？mysql的默认隔离级别？:star:"></a>事务隔离级别？mysql的默认隔离级别？:star:</h4><p>READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</p>
<p>READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</p>
<p><strong>PEREATABLE-READ(可重复读)：</strong>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p>
<p>SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240520143952626.png" alt="image-20240520143952626"></p>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
<p><strong>【注】不可重复读和幻读有什么区别</strong></p>
<ul>
<li><p><strong>发生场景不同</strong>：<strong>不可重复读主要涉及到修改数据，而幻读则主要涉及到插入或删除数据</strong></p>
<p>不可重复读指的是在同一事务中，<strong>多次读取同一行数据，但是每次读取的结果都不同，这个因为在这个事务读取数据期间，其他事务修改了这些数据导致的。</strong></p>
<p>幻读指的是同一事务中，<strong>多次执行相同的查询，但是每次查询返回的行数却不同，这是因为在这个事务读取数据期间，其他事务插入了新的数据所导致的。</strong></p>
</li>
<li><p><strong>解决方案不同</strong>：不可重复读的解决方案通常是使用<strong>行锁或者表锁</strong>来解决，而幻读的解决方案通常是使用<strong>间隙锁</strong>来解决。</p>
</li>
</ul>
<h3 id="6-大表如何优化-star-star-star"><a href="#6-大表如何优化-star-star-star" class="headerlink" title="6. 大表如何优化:star::star::star:"></a>6. 大表如何优化:star::star::star:</h3><p>所谓的“大表”指的是<strong>一张表中有大量的数据</strong>，而通常情况下数据量越多，那么也就意味着查询速度越慢。这是因为当数据量增多时，那么查询一个数据需要匹配和检索的内容也就越多，而检索的项目越多，那么查询速度也就越慢。</p>
<p>:blue_heart:<strong>限定数据的范围：</strong> <strong>务必禁止不带任何限制数据范围条件的查询语句</strong>。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<p>:blue_heart:<strong>读/写分离：经典的数据库拆分方案，主库负责写，从库负责读；</strong></p>
<p>:blue_heart:<strong>垂直分区：</strong> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>:blue_heart:<strong>水平分区：</strong> <strong>保持数据表结构不变，通过某种策略存储数据分片。</strong>这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p>
<p>:blue_heart:<strong>创建适当的索引</strong>：通过创建适当的索引，可以加速查询操作。索引可以提高查询语句的执行效率，尤其是对于常用的查询条件和排序字段进行索引，<strong>可以显著减少查询的扫描范围和 IO 开销</strong></p>
<p>:blue_heart:<strong>优化查询语句</strong>：优化查询语句本身，避免全表扫描和大数据量的关联查询。可以优化查询条件，使用合适的索引、合理的查询策略，减少不必要的字段和数据返回。</p>
<p>:blue_heart:<strong>缓存查询结果</strong>：对于一些相对稳定的查询结果，可以将其缓存在内存中，避免重复查询数据库，提高查询速度。缓存的查询速度一定比直接查询数据库的效率高，这是因为缓存具备以下特征：</p>
<ul>
<li><strong>内存访问速度快</strong>：缓存通常将数据存储在内存中，而数据库将数据存储在磁盘上。相比于磁盘访问，内存访问速度更快，可以达到纳秒级别的读取速度，远远快于数据库的毫秒级别的读取速度。</li>
<li><strong>IO 操作次数少</strong>：数据库通常需要进行磁盘 IO 操作，包括读取和写入磁盘数据。而缓存将数据存储在内存中，避免了磁盘 IO 的开销。内存访问不需要进行磁盘寻址和机械运动，相对来说速度更快。</li>
<li><strong>特殊的数据结构</strong>：缓存的数据结构通常为 key-value 形式的，也就是说缓存可以做到任何数据量级下的查询数据复杂度为 O(1)，所以它的查询效率是非常高的；而数据库采用的是传统数据结构设计，可能需要查询二叉树、或全文搜索、或回表查询等操作，所以其查询性能是远低于缓存系统的</li>
</ul>
<p>:blue_heart:<strong>提升硬件配置</strong>：对于大数据量的表，可以考虑采用更高性能的硬件设备，如更快的存储介质（如固态硬盘），更大的内存容量等，以提升查询的 IO 性能。</p>
<p>:blue_heart:<strong>数据归档和分离</strong>：对于历史数据或不经常访问的数据，可以进行归档和分离，将这些数据从主表中独立出来，减少主表的数据量，提高查询速度。</p>
<p>:blue_heart:<strong>数据库分片</strong>：当单个数据库无法满足查询性能需求时，可以考虑使用数据库分片技术，将数据分散到多个数据库中，每个数据库只处理部分数据，从而提高查询的并发度和整体性能。<strong>数据库分片技术的具体实现是分库分表</strong>。</p>
<p>【总结】大数据量的表的查询优化方案有很多，例如：<strong>创建索引、优化查询语句、缓存查询结果、提升硬件配置、数据归档和分离，以及数据分片技术（分库分表）</strong>等，而这些技术通常是一起配合使用，来共同解决大数据量表的查询速度慢的问题的，其中分库分表的实现最为复杂，所以需要根据自身业务的需要酌情使用。</p>
<h3 id="7-分库分表之后，id主键如何处理-star-star-star"><a href="#7-分库分表之后，id主键如何处理-star-star-star" class="headerlink" title="7. 分库分表之后，id主键如何处理 :star::star::star:"></a>7. 分库分表之后，id主键如何处理 :star::star::star:</h3><p><strong>为什么需要全局唯一ID：</strong>传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT=1设置自增起始值，<strong>但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。</strong>这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。</p>
<ul>
<li><p><strong>数据库自增 id</strong>：<strong>两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。</strong>这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。以MySQL举例，利用给字段设置**<code>auto_increment_increment</code><strong>(表示自增长字段从那个数开始)和</strong><code>auto_increment_offset</code>**(表示自增长字段每次递增的量)来保证ID自增。</p>
</li>
<li><p><strong>UUID</strong>：通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为 <code>16^32=2^128</code>。【注】缺点：不易存储，信息不安全，对MySQL索引不利。</p>
<ul>
<li>基于时间的UUID；DCE安全的UUID；基于名字的UUID（MD5）；随机UUID；基于名字的UUID（SHA1）</li>
</ul>
</li>
<li><p><strong>利用redis生成id :</strong>   <strong>性能比较好，灵活方便，不依赖于数据库。</strong>但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>
</li>
<li><p><strong>Twitter的snowflake算法</strong>：</p>
<ul>
<li>Snowflake，雪花算法是由Twitter开源的分布式ID生成算法，<strong>以划分命名空间的方式将 64-bit位分割成多个部分，每个部分代表不同的含义。</strong>而 Java中64bit的整数是Long类型，<strong>所以在 Java 中 SnowFlake 算法生成的 ID 就是 long 来存储的</strong>。</li>
<li>雪花算法是 64 位 的二进制，一共包含了四部分：<strong>符号位；时间戳；机器标识；计数序列号。</strong><ul>
<li><strong>1位是符号位</strong>，也就是最高位，<strong>始终是0</strong>，没有任何意义，因为要是唯一计算机二进制补码中就是负数，0才是正数。</li>
<li><strong>第2位开始的41位(2-42)是时间戳，具体到毫秒</strong>，41位的二进制可以使用69年，因为时间理论上永恒递增，所以根据这个排序是可以的。</li>
<li><strong>中间10位(43-52)是机器标识，可以全部用作机器ID，也可以用来标识机房ID + 机器ID，10位最多可以表示1024台机器。</strong></li>
<li><strong>最后12位(53-64)是计数序列号</strong>，也就是同一台机器上同一时间，理论上还可以同时生成不同的ID，12位的序列号能够区分出4096个ID。</li>
</ul>
</li>
</ul>
<p><strong>雪花算法提供了一个很好的设计思想，雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，而且可以根据自身业务特性分配bit位，非常灵活</strong>。</p>
<p>【缺点】但是雪花算法强<strong>依赖机器时钟</strong>，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复。</p>
<p>雪花算法：<a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-domain-id-snowflake.html">https://pdai.tech/md/algorithm/alg-domain-id-snowflake.html</a></p>
</li>
</ul>
<h3 id="9-MySql中varchar和char的区别？"><a href="#9-MySql中varchar和char的区别？" class="headerlink" title="9.MySql中varchar和char的区别？"></a>9.MySql中varchar和char的区别？</h3><p>CHAR和VARCHAR的区别可以总结如下： </p>
<p>1 存储方式：<strong>CHAR是固定长度的字符类型，而VARCHAR是可变长度的字符类型。</strong> </p>
<p>2 占用空间：<strong>CHAR会以固定的长度存储数据，不论实际存储的字符数目</strong>，而<strong>VARCHAR则根据实际需要的空间动态分配存储</strong>。 </p>
<p>3 尾随空格：CHAR在存储时会<strong>用空格填充到指定长度</strong>，并在<strong>检索时需要删除尾随空格</strong>，而VARCHAR没有这个问题。 </p>
<p>4 长度限制：CHAR的长度范围为1到255个字符，而VARCHAR的长度范围也是255个字符，但可以根据需求设定更长的长度。 </p>
<p>5 访问效率：由于CHAR是固定长度的，它在某些情况下可能会比VARCHAR稍微快一些。 — <strong>CHAR固定长度，稍快。</strong></p>
<p>综上所述，CHAR适合存储长度固定且固定大小的数据，而VARCHAR适用于长度可变的数据。</p>
<h3 id="10-MySql中int-11-中的11代表什么含义？"><a href="#10-MySql中int-11-中的11代表什么含义？" class="headerlink" title="10.MySql中int(11)中的11代表什么含义？"></a>10.MySql中int(11)中的11代表什么含义？</h3><p>括号中的数字<code>(11)</code>在MySQL中被称为<strong>“显示宽度”</strong>，它并不影响存储空间或数值范围</p>
<p>在MySQL中，<code>INT</code>是整数数据类型，而括号中的数字<code>(11)</code>通常被误解为该整数类型的长度或最大位数。但实际上，对于<code>INT</code>类型，MySQL会始终分配4个字节的空间，无论括号中的数字是多少。这4个字节允许<code>INT</code>存储从-2,147,483,648到2,147,483,647范围内的值。<strong>括号中的数字<code>(11)</code>在MySQL中被称为“显示宽度”，它并不影响存储空间或数值范围</strong>，而是指当数值类型用于显示时，如果设置了<code>ZEROFILL</code>属性，MySQL会使用这个宽度来决定是否在数值前面填充零以达到指定的宽度。例如，如果你有一个定义为<code>INT(11) ZEROFILL</code>的字段，并且插入了数值<code>42</code>，那么在显示时，这个数值将会被填充成<code>00000000042</code>以满足宽度为11的要求。</p>
<h3 id="11-为什么select-count-from-table-在InnoDB比MyISAM慢"><a href="#11-为什么select-count-from-table-在InnoDB比MyISAM慢" class="headerlink" title="11. 为什么select count(*) from table 在InnoDB比MyISAM慢?"></a>11. 为什么select count(*) from table 在<code>InnoDB</code>比<code>MyISAM</code>慢?</h3><p>对于 SELECT COUNT(<em>) FROM table 语句，在没有 WHERE 条件的情况下，<code>InnoDB</code> 比 <code>MyISAM</code> 可能会慢很多，尤其在大表的情况下。*<em>因为，<code>InnoDB</code>是去实时统计结果，会全表扫描；而 <code>MyISAM</code>内部维持了一个计数器，预存了结果，所以直接返回即可。</em></em></p>
<h3 id="12-InnoDB-和MyISAM有什么区别"><a href="#12-InnoDB-和MyISAM有什么区别" class="headerlink" title="12. InnoDB 和MyISAM有什么区别?"></a>12. <code>InnoDB</code> 和<code>MyISAM</code>有什么区别?</h3><p>InnoDB 支持<strong>行级锁</strong>；<strong>事务</strong>；<strong>外键</strong>；<strong>MVCC</strong>；<strong>索引类型不同</strong>；支持数据库<strong>异常崩溃后的安全恢复</strong>，依赖 <strong>redo log</strong>。</p>
<ul>
<li>在 MySQL 5.5 及之前的版本中，<code>MyISAM 是默认的存储引擎</code>，而在 MySQL 5.5 版本以后，默认使用 <code>InnoDB</code> 存储引擎。</li>
<li><code>MyISAM</code> <strong>不支持行级锁</strong>，换句话说，<code>MyISAM</code> 会对整张表加锁，而不是针对行。同时，<code>MyISAM</code> <strong>不支持事务和外键</strong>。<code>MyISAM</code> 可被压缩，存储空间较小，而且 <code>MyISAM</code> 在筛选大量数据时非常快。</li>
<li><strong>InnoDB 是聚集索引，MyISAM 是非聚集索引</strong></li>
<li><code>InnoDB</code> 是事务型引擎，当事务异常提交时，会被回滚。同时，**<code>InnoDB</code> 支持行锁。<strong>此外，<code>InnoDB</code> 需要更多存储空间，会在内存中建立其专用的缓冲池用于高速缓冲数据和索引。</strong><code>InnoDB</code> 支持自动崩溃恢复特性**</li>
</ul>
<h3 id="13-MySQL索引"><a href="#13-MySQL索引" class="headerlink" title="13. MySQL索引"></a>13. <code>MySQL索引</code></h3><h4 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h4><p><strong>===加快查询速度，减少磁盘IO===</strong></p>
<p>加索引后 ，通过索引可以找到主键，根据主键id去聚簇索引里读取数据，<strong>更快地找到数据所在的页，减少磁盘IO</strong>。</p>
<h4 id="2-什么是索引？索引有哪些优缺点？-star2-star2-star2"><a href="#2-什么是索引？索引有哪些优缺点？-star2-star2-star2" class="headerlink" title="2. 什么是索引？索引有哪些优缺点？:star2::star2::star2:"></a>2. 什么是索引？索引有哪些优缺点？:star2::star2::star2:</h4><p><strong>索引是数据库中用于提高数据检索性能的排好序的数据结构。</strong>它类似于书籍的目录，<strong>通过建立特定的数据结构将列或多个列的值与它们在数据表中对应的行关联起来，以加快查询速度。</strong> </p>
<p>索引的优点包括： </p>
<p><strong>1 提高查询性能：</strong>索引可以加快数据库查找数据的速度，通过快速定位到符合查询条件的数据行，减少了数据库进行全表扫描的开销，从而显著提高查询效率。 </p>
<p><strong>2 唯一性约束：</strong>通过在索引上设置唯一性约束，可以确保数据的唯一性，防止重复数据的插入。 </p>
<p><strong>3 减少磁盘IO</strong></p>
<p>然而，索引也有一些缺点： </p>
<p><strong>1 占用存储空间：</strong>索引通常需要占用一定的磁盘空间。过多的索引可能会增加存储成本。 </p>
<p><strong>2 索引维护的开销：</strong>当对数据表进行插入、更新或删除操作时，索引也需要进行相应的维护操作，这可能导致数据写入的性能下降，更新缓慢。 </p>
<p>因此，在设计数据库时，需要根据具体的查询需求、数据特点和系统环境来决定是否以及如何建立索引，以平衡查询性能和维护成本。</p>
<h4 id="3-索引类型"><a href="#3-索引类型" class="headerlink" title="3. 索引类型"></a>3. 索引类型</h4><ul>
<li><strong>主键索引</strong>：<strong>索引列中的值必须是唯一的，不允许有空值。</strong> 每个表只有一个主键索引。</li>
<li><strong>普通索引</strong>：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</li>
<li><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。一个表可以有多个唯一索引。</li>
<li><strong>全文索引</strong>：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。<code>MyISAM</code>和<code>InnoDB</code>中都可以使用全文索引。</li>
<li><strong>空间索引</strong>：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</li>
<li><strong>复合索引：</strong>复合索引也叫<strong>多列索引或联合索引</strong>，它是包含多个列的索引类型，能够加速多列查询和排序操作。</li>
<li><strong>哈希索引：</strong>哈希索引是<strong>基于哈希表实现的索引类型</strong>，能够对等值查询进行高效的处理，但不支持范围查询和排序，MySQL 中 Memory 引擎中支持哈希索引</li>
</ul>
<h4 id="4-什么时候不要使用索引？"><a href="#4-什么时候不要使用索引？" class="headerlink" title="4. 什么时候不要使用索引？"></a>4. 什么时候不要使用索引？</h4><ul>
<li>经常增删改的列不要建立索引</li>
<li>有大量重复的列不要建立索引</li>
<li>表记录太少不要建立索引</li>
</ul>
<h4 id="5-索引失效的情况"><a href="#5-索引失效的情况" class="headerlink" title="5. 索引失效的情况"></a>5. 索引失效的情况</h4><p><strong>未遵循最左匹配原则—使用列运算—使用函数方法—类型转换—错误的模糊匹配—使用is not null</strong></p>
<ul>
<li><strong>违反最左原则：</strong>如果查询条件中的列顺序与索引列的顺序不一致，索引可能无法被使用。例如，一个联合索引（A, B），如果查询条件只包含了B列而没有A列，那么这个索引就无法被利用。</li>
</ul>
<p>​		什么是最左前缀原则：</p>
<p>​		最左前缀原则（Leftmost Prefix Rule）是索引在数据库查询中的一种使用规则。<strong>它指的是在使用复合索引时，索引的最左边的连续几个列会被用于查询过滤条件的匹配。</strong> 具体来说，如果在表中创建了一个复合索引，包含多个列 A、B、C，那么最左前缀原则要求查询中的过滤条件必须从索引的最左边开始，并且不能跳过中间的列。只有当查询中的过滤条件与索引的最左前缀完全匹配时，索引才能被充分利用。</p>
<ul>
<li><p><strong>使用函数或者表达式</strong>：当查询条件中对索引列应用了函数、数学运算、类型转换等操作时，索引可能无法被使用。<strong>因为索引的创建是基于原始列值的，无法直接使用函数计算后的结果进行索引匹配。</strong></p>
</li>
<li><p><strong>数据类型不匹配</strong>：当查询条件的数据类型与索引列的数据类型不匹配时，索引可能无法被使用。尤其是在进行隐式数据类型转换、不同字符集的比较或编码问题时，需要特别留意。</p>
</li>
<li><p><strong>使用了NOT、&lt;&gt;、OR等非优化的逻辑操作符：</strong>这些逻辑操作符在查询条件中的使用会导致索引失效，因为它们无法充分利用索引的特性。</p>
</li>
<li><p>**头部模糊查询(%天)**：索引失效，尾部不会；</p>
</li>
<li><p><strong>or 前索引列 or 后不是</strong>，则都失效；</p>
</li>
</ul>
<h4 id="6-什么是覆盖索引"><a href="#6-什么是覆盖索引" class="headerlink" title="6. 什么是覆盖索引"></a>6. 什么是覆盖索引</h4><p><strong>覆盖索引是指一个索引包含了查询所需的所有列，而无需访问表的实际数据页。</strong></p>
<p>当数据库系统执行查询时，通常需要从磁盘中读取数据页到内存中才能进行处理。而如果使用了覆盖索引，由于索引已经包含了查询所需的所有列的值，数据库系统可以直接通过索引来获取这些值，而不需要额外地读取数据页。这样可以减少磁盘 I/O 的次数和数据在内存中的占用，提高查询的效率。</p>
<p>什么时候使用覆盖索引</p>
<ol>
<li>查询语句只需要返回索引列中的数据，而不需要访问其他列的值。</li>
<li>查询语句中的条件过滤、排序或分组的列都在同一个索引上。</li>
</ol>
<p>总结来说：<strong>使用覆盖索引可以减少数据库系统的工作量，提高查询的性能。它可以避免不必要的数据读取操作，减少磁盘 I/O，并且在内存中更高效地处理查询操作。因此，在设计数据库索引时，可以考虑创建覆盖索引来优化相关的查询。</strong></p>
<h4 id="7-什么是索引下推"><a href="#7-什么是索引下推" class="headerlink" title="7. 什么是索引下推"></a>7. 什么是索引下推</h4><p>索引下推（Index Condition Pushdown，简称ICP）是<strong>一种数据库查询优化技术</strong>，它利用了数据库引擎中的索引和过滤条件，将<strong>部分过滤工作</strong>下推到<strong>存储引擎层面</strong>进行处理，从而减少<strong>不必要的数据读取和传输</strong>。</p>
<h4 id="8-聚簇索引VS非聚簇索引"><a href="#8-聚簇索引VS非聚簇索引" class="headerlink" title="8. 聚簇索引VS非聚簇索引"></a>8. 聚簇索引VS非聚簇索引</h4><ol>
<li>存储数据不同：<strong>聚簇索引</strong>将<strong>数据行</strong>存储在与索引相同的B+树结构中，而<strong>非聚簇索引</strong>将<strong>主键ID</strong>存储在B+树结构中；</li>
<li>数量限制不同：一张表只能有<strong>一个聚簇索引</strong>，但可以有<strong>多个非聚簇索引</strong>；</li>
<li>索引更新不同：由于<strong>聚簇索引中的数据行与索引行是一一对应的</strong>，因此<strong>对于聚簇索引的任何更新都需要重新排列数据行的物理顺序</strong>。这可能会导致性能问题，特别是在高并发环境中，而非聚簇索引的更新不需要重新排列数据行的物理顺序，因为索引和数据行是分开存储的；</li>
<li>索引大小不同：由于聚簇索引中的数据行与索引行是一一对应的，因此<strong>聚簇索引的大小通常比非聚簇索引大</strong>，而非聚簇索引通常比较小，因为它们只存储索引不存储数据行；</li>
<li>范围查询不同：聚簇索引中的数据行与索引行是一一对应的，因此<strong>聚簇索引通常比非聚簇索引更适合范围查询</strong>，而非聚簇索引需要进行两次查找：首先查找索引，然后查找数据行，这可能会导致性能问题，特别是在大型表上进行范围查询时。</li>
</ol>
<h3 id="14-快照读和当前读有什么区别？"><a href="#14-快照读和当前读有什么区别？" class="headerlink" title="14. 快照读和当前读有什么区别？"></a>14. 快照读和当前读有什么区别？</h3><p><strong>快照读（一致性非锁定读）</strong>：<strong>单纯的 select语句使用快照读</strong>；当读取的记录正在执行更新或删除时，读取操作不会等，而是直接读取一个快照；（MVCC；适合一致性要求不高的）</p>
<ul>
<li><strong>读取已提交：被锁定行的最新一份快照；</strong></li>
<li><strong>可重复读：本事务开始时的行数据快照；</strong></li>
</ul>
<p><strong>当前读（一致性锁定读）</strong>：给<strong>行记录加 X 锁或 S 锁</strong>；select 语句最后加 for update/share；<strong>每次读取的都是当前最新的数据，但是读的时候不允许写，写的时候也不允许读。</strong></p>
<h3 id="15-说说什么是MVCC？"><a href="#15-说说什么是MVCC？" class="headerlink" title="15. 说说什么是MVCC？"></a>15. 说说什么是MVCC？</h3><p><a target="_blank" rel="noopener" href="https://www.javacn.site/interview/mysql/mvcc-execution.html">https://www.javacn.site/interview/mysql/mvcc-execution.html</a></p>
<p>MVCC是一种<strong>并发控制策略</strong>，它在多个事务同时执行时，<strong>确保数据库的一致性和隔离性</strong>。MVCC通过<strong>为每个事务创建数据的不同版本，避免了锁竞争问题</strong>。</p>
<p><strong>定义</strong>：<strong>多版本并发控制(MVCC = Multi-Version Concurrency Control)，是一种用来解决读-写冲突的无锁并发控制。</strong>也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。</p>
<p><strong>目的：</strong> 提高数据库的并发性能</p>
<p><strong>功能</strong>：在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。同时还可以解决脏读、幻读、不可重复读等事务隔离问题，但不能解决更新丢失问题。</p>
<p>实现原理：<strong>它的实现原理主要是依赖记录中的 <font color="blue">隐藏字段、undo 日志、Read View </font>来实现的。</strong></p>
<ul>
<li>每条数据行都有<strong>一个隐藏的版本号或时间戳</strong>，<strong>记录该行的创建或最后修改时间</strong>。 </li>
<li>当事务开始，它会<strong>获取一个唯一的事务ID，作为其开始时间戳</strong>。</li>
<li>在读取数据时，<strong>事务只能访问在其开始时间戳之前已提交的数据</strong>。这个版本的数据在事务开始前就已存在。 — 快照读</li>
<li>当事务更新数据，会创建新版本的数据，将更新后的数据写入新的数据行，并将事务ID与新版本关联。</li>
<li>其他事务可以继续访问旧版本的数据，不受正在进行的更新事务影响。这种机制被称为<strong>快照读。</strong></li>
<li><strong>当事务提交，其所有修改才对其他事务可见</strong>。此时，新版本的数据成为其他事务读取的数据。</li>
</ul>
<p>【补充】 <strong>undo log 链:</strong> Undo Log 链是指在每个数据对象上维护的 Undo Log 记录链表。每张表都会有与之相对应的 Undo Log 链，用于记录修改前的数据信息（以方便数据进行回滚）；undo log的<strong>链首</strong>就是<strong>最新的旧记录</strong>，<strong>链尾</strong>就是<strong>最早的旧记录</strong>。</p>
<p>【补充】<strong>Read View:</strong> Read View（读视图）用于管理事务之间数据可见性的一种机制。Read View 在特定时刻为事务创建的一个快照，该快照包含了在该时刻所有未提交事务的事务标识符，以及其他一些辅助信息。主要包含4个字段：<strong>m_ids：当前活跃的事务编号集合</strong>；<strong>min_trx_id：最小活跃事务编号</strong>；max_trx_id：预分配事务编号，当前最大事务编号+1；<strong>creator_trx_id：ReadView 创建者的事务编号</strong>。</p>
<p><strong>RC （读已提交）级别中，每次快照读都会生成一个全新的 Read View，而 RR（可重复读） 级别中同一个事务会复用一个 Read View。</strong></p>
<h3 id="16-Undo-log是如何回滚事务的-star-star-star"><a href="#16-Undo-log是如何回滚事务的-star-star-star" class="headerlink" title="16. Undo log是如何回滚事务的 :star::star::star:"></a>16. Undo log是如何回滚事务的 :star::star::star:</h3><p>在数据库中，Undo Log通常用于实现事务的回滚操作。当事务执行更新操作时，数据库会将相应的旧数据记录在Undo Log中，用于回滚事务时还原到事务开始前的状态。以下是Undo Log回滚事务的一般步骤： </p>
<p>首先，<strong>获取事务的回滚指针或Undo Log的起始位置</strong>。 从Undo Log的末尾开始逆向扫描，按照事务操作的逆序依次处理每个日志记录。 </p>
<p>然后，<strong>针对 INSERT 操作，执行 DELETE 操作来撤销插入的数据。对于 UPDATE 操作，使用Undo Log 中记录的旧值将数据还原到之前的状态。</strong> </p>
<p>在回滚过程中，对于已经提交的其他事务所做的修改需要跳过，只处理属于当前回滚事务的 Undo Log 记录。 </p>
<p>按照逆序依次处理所有的日志记录，直到达到回滚指针位置或 Undo Log 的起始位置。 </p>
<p>回滚完成后，清除或标记已回滚的 Undo Log 记录。 </p>
<p>总体而言，事务回滚是<strong>通过执行 Undo Log 中记录的反向操作</strong>，将事务的修改操作撤销，恢复到事务开始前的状态。</p>
<h3 id="17-MySql数据库的锁？"><a href="#17-MySql数据库的锁？" class="headerlink" title="17. MySql数据库的锁？"></a>17. <code>MySql</code>数据库的锁？</h3><h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>MySQL 中有<strong>共享锁和排它锁</strong>，也就是读锁和写锁。</p>
<ol>
<li><p>共享锁：不堵塞，多个用户可以同一时刻读取同一个资源，相互之间没有影响。</p>
</li>
<li><p>排它锁：一个写操作阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。</p>
</li>
<li><p><strong>表锁</strong>：<strong>系统开销最小，会锁定整张表，<code>MyISAM</code> 使用表锁。</strong></p>
</li>
<li><p><strong>行锁</strong>：<strong>容易出现死锁，发生冲突概率低，并发高，<code>InnoDB</code> 支持行锁</strong>（必须有索引才能实现，否则会自动锁全表，那么就不是行锁了）。</p>
<p>行锁的分类：</p>
<ul>
<li><strong>记录锁(Record Lock):</strong> 锁定单个行记录；</li>
<li><strong>间隙锁(Gap Lock):</strong> 锁定一个范围，不包括记录本身；</li>
<li><strong>临键锁(Next-Key Lock) ：</strong>Record Lock+Gap Lock，<strong>锁定一个范围</strong>，<strong>包含记录本身</strong>，<strong>主要目的是为了解决幻读问题</strong>。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。 —- 行锁默认，索引上等值查询，给<strong>唯一索引加锁</strong>时，临键锁退化成记录锁；索引上等值查询，<strong>向右遍历且最后一个值不满足</strong>等值条件时，退化成间隙锁；</li>
</ul>
</li>
</ol>
<p>【注】使用行级锁需要注意的事项：当执行<strong>UPADTE、DELETE语句</strong>时，如果<strong>WHERE条件中字段没有命中唯一索引</strong>或者<strong>索引失效</strong>的话，就会<strong>导致扫描全表对表中的所有行记录进行加锁</strong>。</p>
<p><strong>意向锁</strong>：<strong>表级锁</strong>，快速判断是否可以对某表使用表锁；</p>
<ul>
<li><strong>意向共享锁</strong>：事务有意向对表中某些记录加共享锁，<strong>加共享锁前</strong>必须先取得该表的 IS 锁；</li>
<li><strong>意向排他锁</strong>：事务有意向对表中某些记录加排他锁，<strong>加排他锁前</strong>必须先取得该表的 IX 锁；</li>
</ul>
<h4 id="MySql的锁升级"><a href="#MySql的锁升级" class="headerlink" title="MySql的锁升级"></a><code>MySql</code>的锁升级</h4><p><strong>MySQL 行锁只能加在索引上，如果操作不走索引，就会升级为表锁。</strong>因为 <code>InnoDB</code> 的行锁是加在索引上的，如果不走索引，自然就没法使用行锁了，原因是 <code>InnoDB</code> 是将 primary key index和相关的行数据共同放在 B+ 树的叶节点。<code>InnoDB</code> 一定会有一个 primary key，secondary index 查找的时候，也是通过找到对应的 primary，再找对应的数据行。</p>
<p><strong>当非唯一索引上记录数超过一定数量时，行锁也会升级为表锁。</strong>测试发现当非唯一索引相同的内容不少于整个表记录的二分之一时会升级为表锁。因为当非唯一索引相同的内容达到整个记录的二分之一时，索引需要的性能比全文检索还要大，查询语句优化时会选择不走索引，造成索引失效，行锁自然就会升级为表锁。</p>
<p>常见的锁升级场景：</p>
<ol>
<li>当某个事务需要获取的是行级锁，但由于并发冲突或其他原因无法满足事务的要求时，系统会将该事务的锁级别升级为表级锁，从而保证数据的一致性和并发性能。</li>
<li>当某个事务操作的对象不符合行锁加锁规则，比如没有走索引或非唯一索引记录数达到一定数量，系统也会将该事务的锁级别升级为表级锁，以确保数据的完整性和一致性。 所以在实际应用时，合理的索引设计、适当的事务隔离级别设置可以帮助减少锁升级的发生，从而提高并发性能和系统吞吐量。</li>
</ol>
<h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p><strong>悲观锁</strong></p>
<p>说的是数据库被外界（包括本系统当前的其他事物以及来自外部系统的事务处理）修改保持着保守态度，因此在整个数据修改过程中，将数据处于锁状态。悲观的实现往往是依靠数据库提供的锁机制，也只有数据库层面提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统汇总实现了加锁机制，也是没有办法保证系统不会修改数据。</p>
<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。<strong>读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</strong></p>
<p><strong>乐观锁</strong></p>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，<strong>大多是基于数据版本（Version）记录机制实现</strong>。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。<strong>读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</strong></p>
<h3 id="18-MySQL如何做到高可用方案"><a href="#18-MySQL如何做到高可用方案" class="headerlink" title="18. MySQL如何做到高可用方案"></a>18. MySQL如何做到高可用方案</h3><p>MySQL 高可用，意味着不能一台 MySQL 出了问题，就不能访问了。</p>
<p>MySQL的高可用方案主要有以下几种： </p>
<p><strong>1 主从复制：</strong>这是最常见的高可用方案。<strong>主库负责处理写操作，并将数据变更记录到binlog日志。从库将主库的binlog复制到自己的中继日志，然后执行中继日志中的事件，以达到与主库数据一致的目的。</strong>当主库出现故障时，可以将从库提升为新的主库，实现服务的高可用。 </p>
<p><strong>2 集群：</strong>MySQL集群是一个高可用、高性能的数据库集群解决方案。它使用了共享无关的架构，可以在节点之间自动分割和复制数据，实现了数据的高可用和高性能。</p>
<h3 id="1-MySQL为什么默认引擎是InnoDB"><a href="#1-MySQL为什么默认引擎是InnoDB" class="headerlink" title="1. MySQL为什么默认引擎是InnoDB"></a>1. MySQL为什么默认引擎是InnoDB</h3><p><strong>MySQL 默认的存储引擎是 InnoDB，这是因为 InnoDB 在性能、事务支持和容错能力等方面具有较好的特性，适合大多数应用场景。</strong></p>
<p>下面是一些原因：</p>
<p>:hand: 1 支持事务：<strong>InnoDB 是一个支持事务的存储引擎。</strong>事务是一组数据库操作的原子性执行，可以保证操作的一致性和完整性。 </p>
<p>:hand: 2 并发控制：<strong>InnoDB 支持行级锁定，在高并发环境下可以最大程度地减少锁冲突，提高并发性能。</strong>相比之下，MySQL 的另一个存储引擎 MyISAM 只支持表级锁定，并发性能较低。 </p>
<p>:hand: 3 外键约束：<strong>InnoDB 支持外键约束，可以保证数据的完整性。</strong>外键用于建立表与表之间的连接，通过外键约束可以实现数据之间的关联和参照完整性。 </p>
<p>:hand: 4 崩溃恢复：<strong>InnoDB 具有自动崩溃恢复的能力。</strong>即使在发生意外故障或系统崩溃时，InnoDB 引擎也能够自动进行崩溃恢复，保障数据的一致性。 </p>
<p>:hand: 5 支持热备份：<strong>InnoDB 支持在线热备份，可以在不停止数据库服务的情况下进行备份操作。</strong>这对于需要实时运行且对数据可用性要求高的应用程序非常重要。 </p>
<p>需要注意的是，虽然 InnoDB 是 MySQL 默认的存储引擎，但在某些场景下，可以根据实际需求选择其他存储引擎，如 MyISAM、Memory 等。不同的存储引擎适用于不同的应用场景和需求。</p>
<h3 id="2-慢SQL"><a href="#2-慢SQL" class="headerlink" title="2. 慢SQL"></a>2. 慢SQL</h3><h4 id="如何定位慢SQL-star"><a href="#如何定位慢SQL-star" class="headerlink" title="如何定位慢SQL:star:"></a>如何定位慢SQL:star:</h4><p>要查询慢SQL产生的原因，可以采取以下4个步骤： <strong>启用慢查询日志；使用EXPLAIN分析执行计划；检查索引使用情况；分析查询语句</strong></p>
<p><strong>1 启用慢查询日志：</strong>在MySQL配置中启用慢查询日志，这样可以记录执行时间超过阈值的查询语句。通过分析慢查询日志，可以找到执行时间较长的SQL语句。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将 slow_query_log 全局变量设置为“ON”状态</span><br><span class="line">set global slow_query_log='ON'; </span><br><span class="line"># 设置慢查询日志存放的位置</span><br><span class="line">set global slow_query_log_file='/usr/local/mysql/data/slow.log';</span><br><span class="line">查询超过1秒就记录</span><br><span class="line">set global long_query_time=1;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2 使用EXPLAIN分析执行计划：</strong>对于慢查询的SQL语句，使用EXPLAIN命令来查看其执行计划。通过分析执行计划，确定查询是否有效利用了索引以及是否存在性能瓶颈。 </p>
<p><strong>3 检查索引使用情况：</strong>确保查询中涉及的列都有适当的索引，并且查询条件能够充分利用索引。可以使用SHOW INDEX命令或查询表的索引信息来检查索引情况。 <strong>4 分析查询语句：</strong>仔细分析查询语句本身，检查是否存在冗余的操作、重复的子查询、不必要的排序、大量的JOIN操作等。 </p>
<p>通过这些步骤的分析，找出慢查询产生的原因，并针对性地进行优化和调整，来提升查询性能。</p>
<h4 id="慢SQL你是怎么优化的-star"><a href="#慢SQL你是怎么优化的-star" class="headerlink" title="慢SQL你是怎么优化的:star:"></a>慢SQL你是怎么优化的:star:</h4><p>针对SQL慢查询，可以考虑以下一些优化措施： </p>
<p>1 <strong>优化查询语句结构</strong>：检查是否存在冗余的操作、重复的子查询、<strong>不必要的排序、大量的JOIN操作</strong>等。优化查询语句的结构和逻辑，<strong>减少不必要的数据读取和计算。</strong> </p>
<p><strong>2 添加合适的</strong>索引： <strong>确保查询中涉及的列都有适当的索引，并且查询条件能够充分利用索引。</strong>通过使用适当的索引，提高查询的性能。但是要避免过多的索引，因为过多的索引会增加写入操作的开销。 </p>
<p>3 <strong>使用覆盖索引</strong>： 如果查询只需要使用索引列的数据而不需要访问表的其他列，可以考虑使用覆盖索引。覆盖索引避免了访问表的额外IO操作，提高查询性能。 </p>
<p>4 <strong>避免全表扫描：</strong>尽量避免全表扫描的情况，通过合适的索引或筛选条件来限制查询范围，减少数据读取量。 </p>
<p>5 <strong>合理分页查询：</strong>对于大数据量的分页查询，可以通过使用LIMIT分页、使用游标、定期同步缓存等方式来提高性能。 </p>
<p>以上是一些常见的SQL慢查询优化措施，具体的优化方法还因根据具体问题和应用场景进行调整。</p>
<h3 id="3-UNION-与UNION-ALL-的区别？"><a href="#3-UNION-与UNION-ALL-的区别？" class="headerlink" title="3. UNION 与UNION ALL 的区别？"></a>3. UNION 与UNION ALL 的区别？</h3><p>:blue_book:<strong>UNION会去除重复的行，UNION ALL不会</strong></p>
<p>UNION和UNION ALL是在SQL中用于合并查询结果集的操作符，它们之间存在以下区别： </p>
<p>1 UNION：<strong>UNION用于合并两个或多个查询结果集，并去除重复的行。</strong>它将多个查询的结果合并为一个结果集，并自动去除重复的行。在执行UNION操作时，数据库会进行额外的去重操作，这可能会带来一定的性能开销。 </p>
<p>2 UNION ALL：<strong>UNION ALL同样用于合并查询结果集，但不去除重复的行。</strong>它将多个查询的结果简单地合并在一起，包括重复的行。相比于UNION，UNION ALL不进行去重操作，因此执行效率更高。</p>
<p>总结来说：在使用时，可以根据具体的需求来选择合适的操作符。<strong>如果需要去除重复的行，可以使用UNION；如果不需要去重，或者对性能要求较高，可以使用UNION ALL。</strong>需要注意的是，使用UNION或UNION ALL时，要求被合并的查询结果的列数和列类型保持一致。</p>
<h3 id="4-count-1-、count-与-count-列名-的区别？"><a href="#4-count-1-、count-与-count-列名-的区别？" class="headerlink" title="4. count(1)、count(*) 与 count(列名) 的区别？"></a>4. count(1)、count(*) 与 count(列名) 的区别？</h3><p>在SQL查询中，COUNT(1)、COUNT(*)和COUNT(列名)是用于计算行数的聚合函数，但它们在实际应用时有一些区别。 </p>
<p>1 <strong>COUNT(1)：这种写法中，1表示一个常量值，它会被用于计算查询结果集的行数。</strong>由于1是一个常量，在执行COUNT(1)时，数据库不会去访问或读取任何实际的数据，仅仅是对满足条件的行进行计数，因此执行速度相对较快。 </p>
<p>2 <strong>COUNT(*)：这种写法中，表示选取所有列，它会对满足条件的行进行计数。</strong>与COUNT(1)不同的是，执行COUNT(*)时，数据库需要读取每一行的数据，然后进行计数操作，因此它可能会比COUNT(1)稍微慢一些。不过，在大多数数据库中，优化器会对COUNT(*)进行特殊处理，可以通过索引等方式进行优化，使得性能相对较好。 </p>
<p>3 <strong>COUNT(列名)：这种写法中，列名表示具体的表列，它会对非空（NULL）值的行进行计数。</strong>相比于COUNT(1)和COUNT(*)，<strong>COUNT(列名)会跳过值为NULL的行，只统计非空值的行数。</strong>这在某些特定的情况下可能更符合实际需求，例如统计某个列的非空值个数。 </p>
<p>总体来说，COUNT(1)和COUNT(*)的性能较好且结果一致，而COUNT(列名)则对非空值进行计数。在实际使用时，可以根据具体的查询需求和性能要求选择适当的写法。</p>
<h3 id="5-MySQL主从复制"><a href="#5-MySQL主从复制" class="headerlink" title="5. MySQL主从复制"></a>5. MySQL主从复制</h3><p>主要设计三个线程：</p>
<ul>
<li>binlog线程：负责将主服务器上的数据更改写入二进制日志中。</li>
<li>I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>
<li>SQL线程：负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<p>读写分离提高性能的原因：</p>
<ul>
<li>主从服务器负责各自的读和写，<strong>极大程度缓解了锁的争用</strong>；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><p>MySQL 的主从复制原理如下： </p>
<p>首先，主库将变更写入 <strong>binlog 日志</strong>。 从库连接到主库后，有一个 IO 线程负责将主库的 binlog 日志复制到自己本地，并写入到<strong>中继日志</strong>中。 </p>
<p>然后，<strong>从库中有一个 SQL 线程会从中继日志读取 binlog</strong>，并执行其中的 SQL 内容，即在从库上再次执行一遍。 以上就是主从复制的原理。</p>
<p><strong>那么主从延迟的原因有哪些呢？</strong>  </p>
<p>1 主库的从库太多，<strong>主库需要将 binlog 日志传输给多个从库，导致复制延迟。</strong> </p>
<p>2 在<strong>从库执行的 SQL 中存在慢查询语句</strong>，会导致整体复制进程的延迟。  </p>
<p>3 如果<strong>主库的读写压力过大，会导致主库处理 binlog 的速度减慢</strong>，进而影响复制延迟。 </p>
<p>为了<strong>优化主从复制的延迟</strong>，我们可以采取以下措施： </p>
<p>1 <strong>减少从库的数量，降低主库的负载，减少复制延迟。</strong> </p>
<p>2 <strong>优化慢查询语句</strong>，减少从库执行SQL 的延迟。 </p>
<p>3 <strong>对主库进行性能优化，减少主库的读写压力</strong>，提高 binlog 写入速度。 </p>
<p>通过以上措施可以帮助降低主从复制的延迟，提高复制的效率和一致性。</p>
<h3 id="6-如何优化深分页-limit-1000000"><a href="#6-如何优化深分页-limit-1000000" class="headerlink" title="6. 如何优化深分页 limit 1000000"></a>6. 如何优化深分页 limit 1000000</h3><p>深分页问题是 MySQL 中常见的性能问题，当你尝试获取大量数据的后续页面时，性能会显著下降。这是因为 MySQL 需要先扫描到指定的偏移量，然后再返回数据。 </p>
<p>例如，以下查询可能会非常慢：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table ORDER BY id LIMIT 1000000, 10;</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为 MySQL 需要先扫描 1000000 行数据，然后再返回后面的 10 行数据。 </p>
<p>解决深分页问题的常见方法有以下几种： </p>
<ol>
<li><strong>使用覆盖索引： 覆盖索引可以让 MySQL 在索引中获取所有需要的数据，而无需回表查询</strong>。这可以大大提高查询速度。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table ORDER BY id LIMIT 1000000, 10;</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><strong>记住上次的位置：</strong> 如果你的应用程序可以记住上次查询的最后一个 ID，那么你可以使用 WHERE 子句来避免扫描大量数据。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE id &gt; last_id ORDER BY id LIMIT 10;</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><strong>使用分页插件：</strong> 有些数据库框架提供了分页插件，可以自动优化分页查询。 </li>
<li><strong>避免深分页：</strong> 在设计应用程序时，尽量避免深分页。例如，你可以提供搜索功能，让用户快速找到他们需要的数据，而不是浏览大量的页面。</li>
</ol>
<h3 id="7-如何解决MySQL死锁问题"><a href="#7-如何解决MySQL死锁问题" class="headerlink" title="7. 如何解决MySQL死锁问题"></a>7. 如何解决MySQL死锁问题</h3><p>MySQL在并发环境下可能会出现死锁问题。<strong>死锁是指两个或多个事务互相等待对方释放资源，导致无法继续执行的情况</strong>。 解决死锁问题的方法通常有以下几种： </p>
<ol>
<li>尽量<strong>让数据表中的数据检索都通过索引来完成，避免无效索引导致行锁升级为表锁。</strong></li>
<li><strong>合理设计索引，尽量缩小锁的范围</strong>。</li>
<li><strong>尽量减少查询条件的范围</strong>，尽量避免间隙锁或缩小间隙锁的范围。</li>
<li>尽量控制事务的大小，<strong>减少一次事务锁定的资源数量</strong>，缩短锁定资源的时间。</li>
<li><strong>如果一条SQL语句涉及事务加锁操作，则尽量将其放在整个事务的最后执行。</strong></li>
<li><strong>尽可能使用低级别的事务隔离机制。</strong></li>
</ol>
<h3 id="8-MySQL索引底层结构为什么使用-B-树"><a href="#8-MySQL索引底层结构为什么使用-B-树" class="headerlink" title="8. MySQL索引底层结构为什么使用 B+树"></a>8. MySQL索引底层结构为什么使用 B+树</h3><p>B+ 树是一种<strong>多路搜索树</strong>，<strong>它的叶子节点存储了所有的数据行信息，叶子节点之间使用指针连接</strong>，方便范围查询和排序等操作，<strong>非叶子节点存储的是索引字段的值</strong>，这样就可以通过非叶子节点的索引值快速定位到叶子节点的数据了</p>
<p>MySQL使用B+树作为索引的底层结构有以下几个主要原因： </p>
<p><strong>1 存储效率：</strong> <strong>B+树在内存中的节点大小通常比其他树结构更大，这样可以减少磁盘I/O操作的次数。</strong>同时，B+树的<strong>非叶子节点只存储索引列的值</strong>，而不包含实际数据，这进一步减小了索引的尺寸。 </p>
<p><strong>2 良好的平衡性</strong>：<strong>B+树是一种自平衡的树结构，不论是在插入、删除还是查询操作中，它都能保持相对较好的平衡状态。</strong>这使得B+树能够快速定位到目标数据，提高查询效率。 </p>
<p><strong>3 顺序访问性：</strong> <strong>B+树的所有叶子节点是按照索引键的顺序排序的。</strong>这使得范围查询和顺序访问非常高效，<strong>因为相邻的数据通常在物理上也是相邻存储的，可以利用磁盘预读提高IO效率。</strong> </p>
<p><strong>4 支持高并发：</strong> <strong>B+树的特性使得它能够支持高并发的读写操作。</strong>通过使用合适的锁或事务隔离级别，多个并发查询和更新操作可以同时进行而不会出现严重的阻塞或冲突。 </p>
<p><strong>5 易于扩展和维护：</strong>B+树的结构相对简单，可以较容易地进行扩展和维护。当插入或删除数据时，B+树只需要调整路径上的少数节点，而不需要整颗树的重构。这样能够有效降低维护成本，并保证索引的高性能。 </p>
<p>综上所述，B+树具有良好的平衡性、顺序访问性、存储效率、并发性和可扩展性，使得它成为一种理想的索引底层结构。</p>
<h4 id="为什么不用一般二叉树"><a href="#为什么不用一般二叉树" class="headerlink" title="为什么不用一般二叉树"></a>为什么不用一般二叉树</h4><p>如果<strong>二叉树特殊化为一个链表，相当于全表扫描。</strong>平衡二叉树相比于二叉查找 树来说，查找效率更稳定，总体的查找速度也更快。</p>
<h4 id="为什么不是平衡二叉树"><a href="#为什么不是平衡二叉树" class="headerlink" title="为什么不是平衡二叉树"></a>为什么不是平衡二叉树</h4><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作 为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说 的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，<strong>如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数 就降下来啦，查询效率就快啦。</strong></p>
<h4 id="为什么不是B树"><a href="#为什么不是B树" class="headerlink" title="为什么不是B树"></a>为什么不是B树</h4><ul>
<li>B+树非叶子节点上是不存储数据的，仅存储键值，<strong>而 B 树节点中不仅存储 键值，也会存储数据</strong>。<strong>innodb 中页的默认大小是 16KB，如果不存储数据，那 么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖</strong>，如此一来我们查<strong>找数据进行磁盘的 IO 次数有会再次减少，数据查 询的效率也会更快。</strong></li>
<li><strong>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。</strong>那么 B+树<strong>使得范围查找，排序查找，分组查找以及去重查找变得 异常简单。</strong></li>
</ul>
<h4 id="Hash索引和B-树区别是什么"><a href="#Hash索引和B-树区别是什么" class="headerlink" title="Hash索引和B+树区别是什么"></a>Hash索引和B+树区别是什么</h4><ul>
<li>B+树可以进行范围查询，Hash索引不能；</li>
<li>B+树支持联合索引的最左原则，Hash索引不支持；</li>
<li>B+树支持order by 排序，Hash索引不支持；</li>
<li>Hash索引在等值查询上比B+树效率更高；但是索引列的重复值很多的话，Hash冲突，效率降低</li>
<li>B+树使用 like 进行模糊查询的时候，like 后面（比如%开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。</li>
</ul>
<h3 id="9-数据库的分库分表"><a href="#9-数据库的分库分表" class="headerlink" title="9. 数据库的分库分表"></a>9. 数据库的分库分表</h3><p>首先来说，分库分表是一组技术，而不是一个单一的技术，<strong>分库分表可以分为以下几种情况：</strong></p>
<ol>
<li><p><strong>只分库</strong>：将一个大数据库分为 N 个小数据库。例如将一个电商数据库，分为多个数据库，如：用户数据库、仓库数据库、订单数据库、商品数据库等。</p>
</li>
<li><p>只分表</p>
<p>：在一个数据库中，将一张表拆分成多张表，而<strong>分表又有以下两种实现</strong>： </p>
<ol>
<li><strong>横向拆分</strong>：不修改原有的表结构，将原本一张表中的数据，分成 N 个表来存储数据。</li>
<li><strong>纵向拆分</strong>：修改原有的表结构，将常用的字段放到主表中，将不常用的和查询效率低的字段放到扩展表中。</li>
</ol>
</li>
<li><p><strong>既分库又分表</strong>：它的实现最复杂，顾名思义，它是将一个数据库拆分成多个数据库，并将一个数据库的一张表，同时有拆分为多张表。</p>
</li>
</ol>
<p><strong>Sharding策略</strong></p>
<ul>
<li>哈希取模: hash(key) % NUM_DB</li>
<li>范围: 可以是 ID 范围也可以是时间范围</li>
<li>映射表: 使用单独的一个数据库来存储映射关系</li>
</ul>
<p><strong>分库分表面临的问题和解决方案如下：</strong> </p>
<p>1 <strong>数据一致性：****由于数据被分布到不同的数据库和表中，分库分表涉及跨节点的事务，需要确保数据的一致性。</strong>可以采用两阶段提交（2PC）协议、最终一致性方案或者基于分布式事务的工具来管理分布式事务，确保数据的一致性。 </p>
<p>2 <strong>跨分片查询：</strong>当业务需要跨多个分片进行查询时，可能会面临性能问题和复杂的查询逻辑。可以使用分布式查询引擎、数据聚合、缓存和分布式计算框架等技术来处理跨分片查询需求，提高查询效率和简化查询逻辑。 </p>
<p>3 <strong>全局唯一性约束：</strong>在分库分表环境下，全局唯一性约束可能受到挑战。可以<strong>采用分布式唯一ID生成器（如Snowflake算法）来生成全局唯一ID，避免冲突。</strong> </p>
<p>在实施分库分表时，需要根据具体情况选择适合的拆分策略，并结合具体的业务特点进行优化和调整。同时，有效的监控和测试也是必不可少的，以确保分库分表系统的高可用性、性能和稳定性。</p>
<h3 id="10-为什么需要数据库连接池呢？"><a href="#10-为什么需要数据库连接池呢？" class="headerlink" title="10. 为什么需要数据库连接池呢？"></a>10. 为什么需要数据库连接池呢？</h3><p>数据库连接池是一种管理和维护数据库连接的技术。它在应用程序和数据库之间建立了一个连接的缓冲池，用于存储和复用已经建立好的数据库连接。</p>
<p>作用：</p>
<ol>
<li><strong>提高性能：</strong>数据库连接的建立和断开是比较耗时的操作，频繁地创建和销毁连接会增加系统的负担。<strong>通过使用连接池，可以避免频繁地创建和关闭连接，减少了连接的开销，提高了系统的性能。</strong></li>
<li>资源管理：数据库连接是有限的资源，如果每个请求都创建一个新的连接，可能导致连接过多而耗尽资源。连接池通过对连接的管理和复用，能够更有效地管理数据库连接，避免资源的浪费。</li>
<li>并发处理：在高并发的场景下，如果每个请求都去单独连接数据库，可能会导致数据库连接数量过多，从而限制了系统的扩展性。连接池允许多个请求共享连接，减少了数据库连接的数量，提高了并发处理能力。 </li>
<li>连接可靠性：数据库连接可能会因为网络问题或服务器故障而中断，当发生这种情况时，连接池能够检测到连接的失效，并重新创建一个可用的连接，确保应用程序的可靠运行。</li>
</ol>
<p>总结来说： <strong>数据库连接池是为了提高性能、更有效地管理资源、提高并发处理能力和增加连接的可靠性而存在的。</strong>它通过缓存已经建立好的连接，复用连接以及管理连接的生命周期，从而减少了连接的开销，提高了系统的性能和稳定性。</p>
<h3 id="11-分表后非分片键的查询、排序怎么处理"><a href="#11-分表后非分片键的查询、排序怎么处理" class="headerlink" title="11. 分表后非分片键的查询、排序怎么处理"></a>11. 分表后非分片键的查询、排序怎么处理</h3><p>在使用分表后，非分片键的查询和排序可以通过以下方式进行处理： </p>
<p><strong>1 联合查询：</strong>如果需要执行涉及多个分表的查询，可以使用联合查询（UNION）或者连接查询（JOIN）来合并结果。将查询条件应用到对应的分表，然后将结果联合起来返回给用户。 </p>
<p><strong>2 扫描所有分表：</strong>如果查询涉及到的数据无法通过分片键进行过滤，那么可能需要扫描所有的分表来获取满足条件的数据。这样的查询会比较慢，因为需要访问所有的分表并合并结果，但在某些场景下是必要的。 </p>
<p><strong>3 手动分页和排序：</strong>如果需要对分表后的数据进行排序和分页，可以在每个分表上执行独立的排序和分页操作，然后将结果合并或者按需返回给用户。这需要在应用程序中进行额外的逻辑处理。 </p>
<p><strong>4 使用全局索引：</strong>如果有一些特定的查询需要在非分片键上执行，并且这些查询非常频繁，可以考虑创建全局索引。全局索引不关心分片键，而是在整个集群上创建索引，可以加速这类查询的执行速度。</p>
<h3 id="12-数据库CPU飙升如何处理"><a href="#12-数据库CPU飙升如何处理" class="headerlink" title="12. 数据库CPU飙升如何处理"></a>12. 数据库CPU飙升如何处理</h3><p>当MySQL数据库的CPU使用率飙升时，可能是由于以下几个原因导致的： </p>
<p><strong>1 查询性能问题：</strong>某些查询可能没有被正确地优化，导致查询执行时间过长，从而占用大量的CPU资源。可以通过查看慢查询日志和执行计划来分析问题查询，并进行索引优化、重写查询语句或调整数据库配置等方式来改善查询性能。 </p>
<p><strong>2 数据库连接问题：</strong>如果存在大量的数据库连接并发访问，可能会造成CPU负载过高。可以检查应用程序连接池的配置情况、数据库连接数限制以及是否有闲置的连接未关闭等问题，并进行相应调整。 </p>
<p><strong>3 锁和死锁问题：</strong>并发事务之间的锁竞争或死锁可能导致CPU飙升。可以通过查看数据库的锁状态、死锁日志以及事务并发控制的设置来解决锁相关的问题。 </p>
<p><strong>4 配置问题：</strong>不合理的数据库配置可能导致CPU资源浪费和效率低下。可以检查MySQL的配置参数，如缓冲区大小、并发连接数、线程池大小等是否合理设置，并进行相应调整。 </p>
<p><strong>5 资源竞争：</strong>如果服务器的物理资源（如内存、磁盘I/O）不足或受限，可能会导致CPU过度使用。可以通过监控系统资源使用情况，调整或增加资源配置，以满足数据库的需求。 </p>
<p>此外，定期进行数据库性能优化和监控也是重要的措施，可以通过数据库性能分析工具、慢查询日志、系统监控工具等来识别和解决性能问题。</p>
<h3 id="13-SQL的执行过程时怎么样的"><a href="#13-SQL的执行过程时怎么样的" class="headerlink" title="13. SQL的执行过程时怎么样的"></a>13. SQL的执行过程时怎么样的</h3><p><strong>连接器–&gt;查询缓存–&gt;分析器–&gt;优化器–&gt;执行器–&gt;存储引擎–&gt;返回结果</strong></p>
<ol>
<li>连接器：<ul>
<li>客户端与数据库建立连接，并发送 SQL 语句给数据库服务。</li>
<li><strong>连接器验证客户端的身份和权限，确保用户有足够的权限执行该 SQL 语句</strong>。</li>
</ul>
</li>
<li>查询缓存<ul>
<li>连接器首先检查查询缓存，尝试找到与当前 SQL 语句完全相同的查询结果。</li>
<li>如果在缓存中找到匹配的结果，查询缓存直接返回结果，避免了后续的执行过程。</li>
</ul>
</li>
<li>分析器<ul>
<li><strong>若查询不命中缓存，连接器将 SQL 语句传递给分析器进行处理</strong>。</li>
<li>分析器对 SQL 语句进行<strong>语法分析</strong>，确保语句的结构和语法正确。</li>
<li>分析器还会进行<strong>语义分析</strong>，检查表、列、函数等对象的存在性和合法性，并进行权限验证。</li>
</ul>
</li>
<li>优化器<ul>
<li>分析器将经过验证的 SQL 语句传递给优化器。</li>
<li><strong>优化器根据统计信息和数据库的规则，生成多个可能的执行计划</strong>，这些计划包括不同的索引选择、连接顺序、筛选条件等。</li>
<li>目的是选出最优的执行路径以提高查询性能。</li>
</ul>
</li>
<li>执行器<ul>
<li><strong>优化器选择一个最优的执行计划，并将其传递给执行器。</strong></li>
<li>执行器根据执行计划执行具体的查询操作。</li>
<li>它负责调用存储引擎的接口，处理数据的存储、检索和修改。</li>
<li>执行器会<strong>根据执行计划从磁盘或内存中获取相关数据，并进行联接、过滤、排序等操作，生成最终的查询结果。</strong></li>
</ul>
</li>
<li>存储引擎<ul>
<li>执行器将查询请求发送给存储引擎组件。</li>
<li>存储引擎组件负责具体的数据存储、检索和修改操作。</li>
<li>存储引擎根据执行器的请求，从磁盘或内存中读取或写入相关数据。</li>
</ul>
</li>
<li>返回结果<ul>
<li>存储引擎根据执行器的请求，从磁盘或内存中读取或写入相关数据。</li>
<li>执行器将结果返回给连接器。</li>
<li>最后，连接器将结果发送回客户端，完成整个执行过程。</li>
</ul>
</li>
</ol>
<p><strong>需要注意的是，查询缓存在一些场景下可能不太适用，因为它有一定的缺陷和开销。MySQL 8.0 版本开始，默认情况下查询缓存已被废弃。因此，在实际应用中，需要权衡是否使用查询缓存。</strong></p>
<h3 id="14-自增主键会遇到什么问题"><a href="#14-自增主键会遇到什么问题" class="headerlink" title="14. 自增主键会遇到什么问题"></a>14. 自增主键会遇到什么问题</h3><p>使用数据库的自增主键，虽然在很多情况下都很方便，但也可能遇到一些问题： </p>
<p><strong>1 插入性能问题：对于非常高并发的插入操作，自增主键可能会成为性能瓶颈。</strong>因为每次插入新记录时，都需要获取一个新的自增ID，这个操作是串行的，无法并发执行。 </p>
<p><strong>2 主键耗尽：如果表的记录非常多，可能会出现自增主键耗尽的情况。</strong>尤其是对于定义为整型的自增主键，如果插入的记录数超过了整型的最大值，就无法再插入新的记录。 </p>
<p><strong>3 分布式系统问题：在分布式系统中，如果多个数据库节点都需要生成自增主键，就需要保证生成的主键在全局是唯一的。</strong>这通常需要引入额外的机制或工具，比如分布式ID生成器。</p>
<h3 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/sql-mysql/sql-mysql-performance.html">https://pdai.tech/md/db/sql-mysql/sql-mysql-performance.html</a></p>
<h4 id="使用Explain进行分析"><a href="#使用Explain进行分析" class="headerlink" title="使用Explain进行分析"></a>使用Explain进行分析</h4><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有:</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h4 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h4><h5 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h5><ul>
<li><strong>只返回必要的列</strong>: 最好不要使用 SELECT * 语句。</li>
<li><strong>只返回必要的行</strong>: <strong>使用 LIMIT 语句</strong>来限制返回的数据。</li>
<li><strong>缓存重复查询的数据</strong>: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h5 id="减少服务端扫描的行数"><a href="#减少服务端扫描的行数" class="headerlink" title="减少服务端扫描的行数"></a>减少服务端扫描的行数</h5><ul>
<li>最有效的方式是使用索引来覆盖查询。</li>
</ul>
<h4 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h4><h5 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h5><ul>
<li>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</li>
</ul>
<h5 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h5><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有: </p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 </li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 </li>
<li><strong>减少锁竞争</strong>； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 </li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-overview.html">https://pdai.tech/md/db/nosql-redis/db-redis-overview.html</a></p>
<h3 id="1-Redis为什么比较快"><a href="#1-Redis为什么比较快" class="headerlink" title="1. Redis为什么比较快"></a>1. Redis为什么比较快</h3><p><strong>基于内存：</strong> <strong>Redis 的数据存储在内存中，而内存的读写速度远远快于硬盘</strong>。这使得 Redis 能够实现非常快速的读写操作。</p>
<p><strong>单线程：</strong>Redis 是单线程的，因此可以避免线程切换和锁竞争等问题，提高了 CPU 的利用率和性能。</p>
<p><strong>异步IO：</strong>Redis 使用异步 I/O 技术，可以在等待客户端输入或输出时继续处理其他请求，从而提高了系统的吞吐量。</p>
<p><strong>高效的持久化机制：</strong>Redis 提供了多种持久化机制，如 RDB、AOF 和混合持久化机制，这些机制运行都非常高效，可以在不影响性能的情况下保证数据的安全。</p>
<p><strong>高效的数据结构：</strong>Redis 提供了多种高效的数据结构，如哈希表、有序集合等，这些数据结构能够快速地进行插入、删除、查找和排序等操作。</p>
<h3 id="2-Redis可以实现什么功能"><a href="#2-Redis可以实现什么功能" class="headerlink" title="2. Redis可以实现什么功能"></a>2. Redis可以实现什么功能</h3><p>缓存：Redis 可以作为缓存系统，将热点数据存储在内存中，提高读写性能和响应速度，减少对后端数据存储的压力。</p>
<p>消息队列：Redis 的发布订阅功能和 List 数据结构可以实现消息队列的功能，实现异步处理任务、解耦系统组件之间的依赖关系等。</p>
<p>计数器和排行榜：Redis 的原子操作和 Sorted Set 数据结构可以实现计数器和排行榜的功能，支持快速地增加、减少和排序操作。</p>
<p>分布式锁：Redis的 <strong>SETNX命令</strong>可以实现分布式锁，避免多个客户端同时修改同一个数据，保证数据的一致性和正确性</p>
<p>分布式会话管理：Redis 可以存储会话信息，实现分布式会话管理，支持会话的共享和迁移等功能。</p>
<h3 id="3-Redis有哪些数据类型"><a href="#3-Redis有哪些数据类型" class="headerlink" title="3. Redis有哪些数据类型"></a>3. Redis有哪些数据类型</h3><p><strong>String(字符串类型)</strong></p>
<p><strong>List(列表类型)</strong></p>
<p><strong>Hash(哈希表类型)</strong></p>
<p><strong>Set(集合类型)<strong>：是</strong>一个无序并唯一的键值集合</strong>，它的常见使用场景是：关注功能，比如关注我的人和我关注的人，使用集合存储，可以保证人员不会重复；</p>
<p><strong>Sorted Set(有序集合类型)<strong>：</strong>相比于 Set 集合类型多了一个排序属性 score（分值）</strong>，它的常见使用场景是：可以用来存储排名信息、关注列表功能，这样就可以根据关注实现排序展示了。</p>
<p>**Bitmap(位图)**：Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。</p>
<p>**HyperLogLog(基数统计)**：HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>
<p>**Geospatial(地理位置)**：Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>
<h3 id="4-有序集合底层是如何实现的"><a href="#4-有序集合底层是如何实现的" class="headerlink" title="4. 有序集合底层是如何实现的"></a>4. 有序集合底层是如何实现的</h3><p>**有序集合是由ziplist(压缩列表)和skiplist(跳跃列表)**组成的</p>
<p><strong>压缩列表 ziplist</strong> 本质上就是一个<strong>字节数组</strong>，是 Redis 为了节约内存而设计的一种线性数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。</p>
<p><strong>跳跃表 skiplist 是一种有序数据结构</strong>，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均 O(logN)、最坏 O(N) 复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p><strong>当数据比较少时，有序集合是压缩列表 ziplist 存储的，反之则为跳跃表 skiplist 存储</strong>，使用压缩列表存储必满足以下两个条件：</p>
<ol>
<li>有序集合保存的<strong>元素个数要小于 128 个</strong>；</li>
<li>有序集合保存的所有元素成员的<strong>长度都必须小于 64 字节</strong>。</li>
</ol>
<p>如果不能满足以上两个条件中的任意一个，有序集合将会使用跳跃表 skiplist 结构进行存储。</p>
<h4 id="跳跃表底层是如何实现的"><a href="#跳跃表底层是如何实现的" class="headerlink" title="跳跃表底层是如何实现的"></a>跳跃表底层是如何实现的</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> {</span></span><br><span class="line">	<span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="type">double</span> score; <span class="comment">// 分值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 回退指针</span></span><br><span class="line">    <span class="comment">//层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> {</span></span><br><span class="line">    	<span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    } level[];</span><br><span class="line">} zskiplistNode;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>obj：</strong>用于存储字符串类型的数据；</p>
<p><strong>score：</strong>用于存储排序的分值；</p>
<p><strong>backward：</strong>后退指针，只能指向当前节点最底层的前一个节点，头节点和第一个节点 backward 指向 NULL，从后向前遍历跳跃表时使用；</p>
<p><strong>level：柔性数组。</strong>每个节点的数组长度不一样，在生成跳跃表节点时，随机生成一个 1-64 的值，值越大出现的概率越低。level 数组的每项包含以下两个元素： </p>
<ul>
<li>forward：指向本层下一个节点，尾节点的 forward 指向 NULL；</li>
<li>span：forward 指向的节点与本节点之间的元素个数，span 值越大，跳过的节点个数越多。</li>
</ul>
<p>除了跳跃表节点外，还需要一个跳跃表结构来管理节点，Redis 使用 zskiplist 结构体，定义如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">} zskiplist;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>header：指向跳跃表头节点。</strong>头节点是跳跃表的一个特殊节点，它的 level 数组元素个数为 64。头节点在有序集合中不存储任何 member 和 score 值，ele 值为 NULL, score 值为 0，也不计入跳跃表的总长度。头节点在初始化时，64 个元素的 forward 都指向 NULL,span 值都为 0；</p>
<p><strong>tail：指向跳跃表尾节点；</strong></p>
<p><strong>length：跳跃表长度，表示除头节点之外的节点总数；</strong></p>
<p><strong>level：跳跃表的高度。</strong></p>
<h3 id="5-Redis如何实现消息队列"><a href="#5-Redis如何实现消息队列" class="headerlink" title="5. Redis如何实现消息队列"></a>5. Redis如何实现消息队列</h3><p>Redis 实现消息队列的常见方法有两种：<strong>使用 Redis 中提供的发布订阅（Pub/Sub）功能或 List 数据结构。</strong></p>
<p>发布订阅（Pub/Sub）：<strong>Redis 的发布订阅功能可以实现消息队列的发布和订阅功能。</strong> <strong>生产者将消息发布到指定的通道（channel）中，消费者可以订阅该通道，接收并处理消息。</strong> 该模式<strong>支持一对多的消息传递</strong>，一个消息可以被多个消费者接收，也可以实现分组订阅，将不同的消费者分为不同的组，实现广播或点对点的消息传递。</p>
<p>List 数据结构：<strong>Redis 的 List 数据结构可以实现消息队列的入队和出队操作</strong>。<strong>生产者将消息插入到 List 的尾部，消费者从 List 的头部获取消息，实现先进先出（FIFO）的消息处理。</strong>可以使用阻塞式的 POP 操作来实现消费者等待新消息到达，也可以使用定时轮询的方式来获取新消息。</p>
<h4 id="发布订阅和List的区别"><a href="#发布订阅和List的区别" class="headerlink" title="发布订阅和List的区别"></a>发布订阅和List的区别</h4><p>发布订阅：发布订阅是一种<strong>一对多的消息传递方式</strong>，即一个消息可以被多个消费者同时接收。生产者发布消息到指定的通道，消费者订阅该通道，接收并处理消息。如果消费者在消息发布之前订阅了该通道，则可以接收到该消息；如果在消息发布后才订阅，则无法接收到之前的消息。<strong>发布订阅模式适用于广播或点对点的消息传递，但是无法保证消息的顺序。</strong></p>
<p>List 数据结构：<strong>List 数据结构是一种先进先出（FIFO）的消息传递方式，即消息入队列时在队列尾部添加，消息出队列时从队列头部删除。</strong>生产者将消息插入到 List 的尾部，消费者从 List 的头部获取消息。可以使用阻塞式的 POP 操作来实现消费者等待新消息到达，也可以使用定时轮询的方式来获取新消息。<strong>List 模式适用于需要按顺序处理消息的场景，但是不适用于广播消息传递。</strong></p>
<p>【区别】</p>
<p>发布订阅：优点是<strong>可以实现一对多的消息传递，支持分组订阅和模式匹配订阅</strong>；缺点是<strong>无法保证消息的顺序和可靠性</strong>，消费者无法感知到生产者是否已经处理完该消息。</p>
<p>List 数据结构：优点是<strong>可以保证消息的顺序和可靠性</strong>，消费者可以在处理完一个消息后再获取下一个消息；缺点是<strong>不适用于一对多的消息传递</strong>。</p>
<h3 id="6-Redis如何实现分布式锁"><a href="#6-Redis如何实现分布式锁" class="headerlink" title="6. Redis如何实现分布式锁"></a>6. Redis如何实现分布式锁</h3><p><strong>分布式锁的作用：</strong>在分布式系统中，<strong>当多个线程（或进程）同时操作同一个资源时，为了保证数据一致性问题，所以就需要一种机制来确保在同一时间只有一个线程（或进程）能够对资源进行修改</strong>，这就是分布式锁的作用。</p>
<p>在 Redis 中实现分布式锁可以<strong>使用 SETNX 和 EXPIRE 命令</strong>来实现，SETNX 是 “SET if Not eXists” 的缩写，是<strong>一个原子性操作</strong>，用于在指定的 key 不存在时设置 key 的值。如果 key 已经存在，SETNX 操作将不做任何事情，返回失败；如果 key 不存在，SETNX 操作会设置 key 的值，并返回成功。而 <strong>EXPIRE 是设置锁的过期时间的，主要为了防止死锁的发生</strong>。</p>
<h4 id="分布式锁问题—SETNX-存在的问题"><a href="#分布式锁问题—SETNX-存在的问题" class="headerlink" title="分布式锁问题—SETNX 存在的问题"></a>分布式锁问题—SETNX 存在的问题</h4><p><strong>死锁问题</strong>：<strong>SETNX 如未设置过期时间，锁忘记删了或加锁线程宕机</strong>都会导致死锁，也就是分布式锁一直被占用的情况。</p>
<p><strong>锁误删问题</strong>：SETNX 设置了超时时间，但因为执行时间太长，所以在超时时间之内锁已经被自动释放了，但线程不知道，因此在线程执行结束之后，会把其他线程的锁误删的问题。比如线程 1 设置的过期时间为 5s，而线程 1 执行了 7s，那么在第 5s 之后锁过期了，那么其他线程就可以拥有这把锁了，之后线程 1 执行完业务，又执行了锁删除操作，那么此时锁就被误删了。—【如何解决】此时可以每个锁的 value 中<strong>添加拥有者的标识</strong>，<strong>删除之前先判断是否是自己的锁，如果是则删除，否则不删除</strong>。但是判断和删除之间不是原子性操作，所以依然有问题。此时<strong>可以使用 lua 脚本来判断并删除锁，lua 脚本可以保证 redis 中多条语句执行的原子性，所以就可以解决此问题了</strong>。</p>
<p>​		<font color="blue"><strong>【注】lua脚本为什么能原子性：</strong></font> 在Lua脚本执行期间，<strong>Redis会暂停处理其他客户端的请求，直到该脚本执行完毕。</strong></p>
<p><strong>不可重入问题</strong>：也就是说<strong>同一线程在已经获取了某个锁的情况下，如果再次请求获取该锁，则请求会失败</strong>（因为只有在第一次能加锁成功）。也就是说，一个线程不能对自己已持有的锁进行重复锁定。</p>
<p><strong>无法自动续期</strong>：线程在持有锁期间，任务未能执行完成，锁可能会因为超时而自动释放。<strong>SETNX 无法自动根据任务的执行情况，设置新的超时实现，以延长锁的时间。</strong></p>
<p><strong>如何解决上述问题，使用Redisson框架</strong></p>
<h4 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h4><p>【定义】Redisson 是一个开源的用于操作 Redis 的 Java 框架。</p>
<p>因为使用Redis的 SETNX 和 EXPIRE 命令实现分布式锁会出现上述问题，因此我们采用Redisson框架来解决上述问题。</p>
<p><strong>Redisson特性说明</strong></p>
<p>Redisson 可以<strong>设置分布式锁的过期时间</strong>，从而<strong>避免锁一直被占用而导致的死锁问题</strong>。</p>
<p>Redisson 在<strong>为每个锁关联一个线程 ID 和重入次数（递增计数器）</strong>作为分布锁 value 的一部分存储在 Redis 中，这样就<strong>避免了锁误删和不可重入</strong>的问题。</p>
<p>Redisson 还提供了自动续期的功能，<strong>通过定时任务（看门狗）定期延长锁的有效期</strong>，确保在业务未完成前，锁不会被其他线程获取。</p>
<h4 id="RedLock-红锁"><a href="#RedLock-红锁" class="headerlink" title="RedLock 红锁"></a>RedLock 红锁</h4><p>RedLock 算法<strong>旨在解决单个 Redis 实例作为分布式锁时可能出现的单点故障问题</strong>，<strong>通过在多个独立运行的 Redis 实例上同时获取锁的方式</strong>来提高锁服务的可用性和安全性。</p>
<p><strong>实现思路</strong></p>
<p>RedLock 是<strong>对集群的每个节点进行加锁，如果大多数节点（N/2+1）加锁成功，则才会认为加锁成功。</strong> 这样即使集群中有某个节点挂掉了，因为大部分集群节点都加锁成功了，所以分布式锁还是可以继续使用的。</p>
<p><strong>存在问题</strong></p>
<p><strong>性能问题</strong>：RedLock 要等待大多数节点返回之后，才能加锁成功，而这个过程中可能会因为网络问题，或节点超时的问题，影响加锁的性能。</p>
<p><strong>并发安全性问题</strong>：当客户端加锁时，如果遇到 GC 可能会导致加锁失效，但 GC 后误认为加锁成功的安全事故，例如以下流程： </p>
<ol>
<li>客户端 A 请求 3 个节点进行加锁。</li>
<li>在节点回复处理之前，客户端 A 进入 GC 阶段（存在 STW，全局停顿）。</li>
<li>之后因为加锁时间的原因，锁已经失效了。</li>
<li>客户端 B 请求加锁（和客户端 A 是同一把锁），加锁成功。</li>
<li>客户端 A GC 完成，继续处理前面节点的消息，误以为加锁成功。</li>
<li>此时客户端 B 和客户端 A 同时加锁成功，出现并发安全性问题。</li>
</ol>
<h3 id="7-Redis持久化机制"><a href="#7-Redis持久化机制" class="headerlink" title="7. Redis持久化机制"></a>7. Redis持久化机制</h3><h4 id="为什么需要持久化"><a href="#为什么需要持久化" class="headerlink" title="为什么需要持久化"></a>为什么需要持久化</h4><p>Redis是个基于内存的数据库。那服务一旦宕机，内存中的数据将全部丢失。通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复，1、会对数据库带来巨大的压力，2、数据库的性能不如Redis。导致程序响应慢。所以对Redis来说，<strong>实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。</strong></p>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，<strong>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程</strong>，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。</p>
<p>触发方式：RDB持久化分为<strong>手动触发和自动触发</strong>两种方式。</p>
<p>手动触发：分别对应<strong>save</strong>和<strong>bgsave</strong>命令，<strong>save命令</strong> <strong>：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间</strong>阻塞<strong>，线上环境不建议使用；</strong> <strong>bgsave命令</strong>：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</p>
<p>自动触发：</p>
<ol>
<li><strong>redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时</strong>，自动触发bgsave生成rdb文件；</li>
<li><strong>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作</strong>，生成当时的快照发送到从节点；</li>
<li><strong>执行debug reload命令重新加载redis</strong>时也会触发bgsave操作；</li>
<li><strong>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作</strong>；</li>
</ol>
<p>数据持久化是指将数据从内存中，保存到磁盘或其他持久存储介质的过程，这样做的目的是为了保证数据不丢失。</p>
<p>Redis 的持久化功能<strong>默认是开启的</strong>，这样做的目的也是为了保证程序的稳定性（防止缓存雪崩、缓存击穿等问题）和数据不丢失。</p>
<p>Redis持久化共有三种方式：</p>
<p><strong>RDB（Redis DataBase）持久化</strong>：<strong>快照方式持久化</strong>，将某一个时刻的内存数据，以二进制的方式写入磁盘。</p>
<p><strong>AOF（Append Only File）持久化</strong>：<strong>文件追加持久化</strong>，<strong>记录所有非查询操作命令</strong>，并以文本的形式追加到文件中。</p>
<p><strong>混合持久化</strong>：混合持久化是<strong>结合了 RDB 和 AOF</strong> 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">操作redis.conf配置文件</span><br><span class="line">// 关闭DBS持久化 </span><br><span class="line">save <span class="string">""</span>  <span class="comment"># 将 save 参数列表清空，表示不进行任何条件下的数据保存</span></span><br><span class="line">// 关闭AOP持久化</span><br><span class="line">appendonly no  <span class="comment"># 设置为 no，表示关闭 AOF 持久化</span></span><br><span class="line">// 关闭混合持久化</span><br><span class="line">rdb-aof-use-rdb-preamble no <span class="comment"># no 表示关闭混合持久化</span></span><br><span class="line">以上持久化关闭之后，都需要重启 Redis 服务才能生效。</span><br></pre></td></tr></tbody></table></figure>

<p>【注】RDB持久化适合用于备份数据，AOF持久化适合用于恢复数据。在RDB持久化中，Redis会fork一个子进程来进行持久化操作，可能会对性能产生影响；而AOF持久化采用追加写入的方式，相对来说性能更好。</p>
<h3 id="8-Redis的过期删除策略"><a href="#8-Redis的过期删除策略" class="headerlink" title="8. Redis的过期删除策略"></a>8. Redis的过期删除策略</h3><p>Redis 中的过期删除策略是指在键（key）上设置了过期时间后，Redis 在某个条件触发时会自动删除过期的键。</p>
<p>:blue_heart:<strong>定期删除策略（定时任务方式）：</strong> Redis 会<strong>定期地（默认每秒钟检查 10 次）随机抽取一部分设置了过期时间的键，检查它们是否过期，如果过期则删除</strong>。该策略可以通过配置文件中的 hz 参数进行调整。</p>
<p><strong>[注] 定期删除流程</strong>：从设置了过期时间的字典中随机取出 20 个键；删除这 20 个键中过期的键；如果过期 key 的比例超过 25% ，重复步骤 1。</p>
<p>:blue_heart:<strong>惰性删除策略（懒汉式方式）：</strong> <strong>当访问一个键时，Redis 会先检查该键是否过期，如果过期则删除。</strong>这意味着过期键可能会在访问时被删除，而不是在过期时立即删除。</p>
<p>Redis 定期删除策略<strong>并不会遍历删除每个过期键，而是采用随机抽取的方式删除过期键</strong>，同时为了保证过期扫描不影响 Redis 主业务，Redis 的定期删除策略中还提供了最大执行时间，以保证 Redis 正常并高效的运行。</p>
<h3 id="9-Redis内存淘汰策略"><a href="#9-Redis内存淘汰策略" class="headerlink" title="9.Redis内存淘汰策略"></a>9.Redis内存淘汰策略</h3><p>当 Redis（运行）内存被使用完时，也就是当 Redis 的运行内存，已经超过 Redis 设置的最大内存之后，<strong>Redis 将采用内存淘汰机制来删除符合条件的键值对，以此来保障 Redis 的正常运行</strong>。</p>
<p><strong>6种内存淘汰机制+2种：</strong></p>
<ol>
<li><strong>noeviction:</strong> 不淘汰任何数据，当内存不足时，新增操作会报错，Redis<strong>默认</strong>内存淘汰策略。</li>
<li><strong>allkeys-lru:</strong> 淘汰<strong>整个键值中最久未使用</strong>的键值。</li>
<li><strong>volatile-lru:</strong> 淘汰所有设置了过期时间的键值中最久未使用的键值。</li>
<li><strong>allkeys-random:</strong> 随机淘汰任意键值。</li>
<li><strong>volatile-random:</strong> 随机淘汰设置了过期时间的任意键值。</li>
<li><strong>volatile-ttl:</strong> 优先淘汰更早过期的键值</li>
<li><strong>volatile-lfu:</strong> 淘汰所有设置了过期时间的键值中，最少使用的键值。 — Redis4.0中新增</li>
<li><strong>allkeys-lfu:</strong> 淘汰整个键值中<strong>最少使用的</strong>键值。— Redis4.0中新增</li>
</ol>
<h4 id="何时触发内存淘汰策略"><a href="#何时触发内存淘汰策略" class="headerlink" title="何时触发内存淘汰策略"></a>何时触发内存淘汰策略</h4><p><strong>写操作时内存超过限制：</strong>当 <strong>Redis 内存使用量超过了设置的 maxmemory 参数</strong>所定义的限制时，<strong>写操作（例如 set、hset 等）会触发内存淘汰策略</strong>。Redis 会根据设置的淘汰策略来删除一些键值对，以释放内存空间来容纳新的数据。</p>
<p><strong>启用 AOF 重写：</strong> <strong>如果 Redis 使用了 AOF（Append Only File）持久化方式，并且开启了 AOF 重写功能，那么在执行 AOF 重写过程中也会触发内存淘汰策略。</strong>AOF 重写是将 AOF 文件重写为一种更紧凑、更快速加载的格式，这个过程中会使用更少的内存来存储数据。</p>
<p><strong>通过命令主动释放内存：</strong>Redis 也可以<strong>通过主动执行 MEMORY PURGE 命令</strong>来释放内存。</p>
<h4 id="LRU和LFU的区别"><a href="#LRU和LFU的区别" class="headerlink" title="LRU和LFU的区别"></a>LRU和LFU的区别</h4><p>LRU（最近最少使用）：<strong>LRU 策略基于时间的概念</strong>，它<strong>认为最近被访问过的键是最有可能被再次访问的，因此在淘汰时会优先选择最久未被访问的键</strong>。LRU 策略会<strong>维护一个访问顺序列表</strong>，每当一个键被访问时，它会被移动到列表的末尾，最近没有被访问的键会位于列表的前面。当需要淘汰键时，LRU 策略会选择列表前面的键进行淘汰。</p>
<p>LFU（最不常使用）：<strong>LFU 策略基于访问频率的概念，它认为被访问次数最少的键是最不常用的，因此在淘汰时会优先选择访问次数最少的键</strong>。LFU 策略会为每个键<strong>维护一个访问计数器</strong>，每当一个键被访问时，其计数器会增加。当需要淘汰键时，LFU 策略会选择访问计数最低的键进行淘汰。</p>
<h3 id="10-Redis的事务"><a href="#10-Redis的事务" class="headerlink" title="10. Redis的事务"></a>10. Redis的事务</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。— <strong>redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</strong></p>
<h4 id="Redis事务相关命令和使用"><a href="#Redis事务相关命令和使用" class="headerlink" title="Redis事务相关命令和使用"></a>Redis事务相关命令和使用</h4><ul>
<li>MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li>
<li>EXEC: 执行事务中的所有操作命令。</li>
<li>DISCARD: 取消事务，放弃执行事务块中的所有命令。</li>
<li>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li>
<li>UNWATCH：取消WATCH对所有key的监视。</li>
</ul>
<h4 id="Redis事务执行步骤："><a href="#Redis事务执行步骤：" class="headerlink" title="Redis事务执行步骤："></a>Redis事务执行步骤：</h4><ul>
<li>开启：以MULTI开始一个事务。</li>
<li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面。</li>
<li>执行：由EXEC命令触发事务。</li>
</ul>
<p>当一个客户端切换到事务状态之后， 服务器会根据这个客户端发来的不同命令执行不同的操作：</p>
<ul>
<li>如果客户端发送的命令为 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令的其中一个， 那么服务器立即执行这个命令。 </li>
<li>与此相反， 如果客户端发送的命令是 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令以外的其他命令， 那么服务器并不立即执行这个命令， 而是将这个命令放入一个事务队列里面， 然后向客户端返回 QUEUED 回复。</li>
</ul>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811111338480" style="zoom:50%;">

<h4 id="CAS操作实现乐观锁"><a href="#CAS操作实现乐观锁" class="headerlink" title="CAS操作实现乐观锁"></a>CAS操作实现乐观锁</h4><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。</p>
<p><strong>如何使用watch实现监视的</strong></p>
<p>Redis使用WATCH命令来决定事务是继续执行还是回滚，那就需要在MULTI之前使用WATCH来监控某些键值对，然后使用MULTI命令来开启事务，执行对数据结构操作的各种命令，此时这些命令入队列。 </p>
<p>当使用EXEC执行事务时，首先会比对WATCH所监控的键值对，如果没发生改变，它会执行事务队列中的命令，提交事务；如果发生变化，将不会执行事务中的任何命令，同时事务回滚。当然无论是否回滚，Redis都会取消执行事务前的WATCH命令。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240811110918957.png" alt="image-20240811110918957"></p>
<h4 id="为什么Redis不支持回滚"><a href="#为什么Redis不支持回滚" class="headerlink" title="为什么Redis不支持回滚"></a>为什么Redis不支持回滚</h4><ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<h4 id="如何理解Redis与事务的ACID"><a href="#如何理解Redis与事务的ACID" class="headerlink" title="如何理解Redis与事务的ACID"></a>如何理解Redis与事务的ACID</h4><p><strong>原子性atomicity</strong>：Redis官方文档给的理解是，Redis的事务是原子性的：<strong>所有的命令，要么全部执行，要么全部不执行。而不是完全成功。</strong></p>
<p><strong>一致性consistency：</strong>redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非redis进程意外终结。</p>
<p><strong>隔离性Isolation</strong>: redis事务是严格遵守隔离性的，原因是redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。</p>
<p><strong>持久性Durability</strong>:redis事务是不保证持久性的，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</p>
<h4 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h4><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完 </li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li>
</ul>
<h3 id="11-Redis的集群模式有哪些方案"><a href="#11-Redis的集群模式有哪些方案" class="headerlink" title="11. Redis的集群模式有哪些方案"></a>11. Redis的集群模式有哪些方案</h3><p><strong>主从复制模式 — 哨兵模式 — 集群模式</strong></p>
<h3 id="12-Redis-缓存问题"><a href="#12-Redis-缓存问题" class="headerlink" title="12. Redis - 缓存问题"></a>12. Redis - 缓存问题</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指<strong>在缓存中大量的键同时过期或失效</strong>，导致请求直接访问数据库或后端服务，给数据库或后端服务造成巨大压力，导致系统性能下降甚至崩溃的现象。</p>
<p><strong>发生原因：</strong> </p>
<p>​		<strong>大量缓存键同时过期：</strong>当缓存键设置了相同的过期时间，或者由于某种原因导致大量的键同时失效，会导致缓存雪崩。</p>
<p>​		<strong>缓存服务器故障：</strong>当缓存服务器发生故障，无法提供服务时，请求将直接访问后端服务，导致压力集中在后端服务上。</p>
<p><strong>解决策略：</strong></p>
<ol>
<li><strong>设置随机过期时间：</strong>为缓存键设置随机的过期时间，<strong>避免大量键同时过期</strong>的情况发生，减少缓存雪崩的概率。</li>
<li><strong>实现缓存预热：</strong>在系统启动或缓存失效前，<strong>提前加载热门数据到缓存中</strong>，避免在关键时刻大量请求直接访问后端服务。</li>
<li><strong>使用分布式缓存：</strong> 将缓存数据分布在多个缓存节点上，<strong>通过分散请求负载来减少单个缓存节点的压力</strong>，提高系统的可用性和抗压能力。</li>
<li><strong>设置熔断机制：</strong>在缓存失效的情况下，通过设置熔断机制，直接返回默认值或错误信息，避免请求直接访问后端服务，减轻后端服务的压力。</li>
<li><strong>实时监控和报警：</strong> <strong>监控缓存系统的状态和性能指标</strong>，及时发现异常情况，并通过报警机制通知运维人员进行处理，减少缓存雪崩的影响。</li>
</ol>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指在缓存系统中，<strong>大量的请求查询不存在于缓存和数据库中的数据，导致这些请求直接访问数据库</strong>，占用数据库资源，而缓存无法发挥作用的现象。</p>
<p><strong>发生原因</strong>：</p>
<ol>
<li><strong>恶意请求（异常情况）：</strong>攻击者发送大量恶意请求，故意查询不存在的数据，以触发缓存穿透。</li>
<li><strong>高并发请求（正常业务）：</strong> <strong>当有大量的并发请求同时查询不存在的数据时</strong>，可能会导致缓存无法命中，从而触发缓存穿透。</li>
</ol>
<p><strong>解决策略</strong>：</p>
<ol>
<li><strong>布隆过滤器（Bloom Filter）：</strong>布隆过滤器是一种高效的数据结构，<strong>可以用于快速判断一个元素是否存在于集合中</strong>。在缓存层引入布隆过滤器，可以在查询请求到达时，首先通过布隆过滤器判断该请求对应的数据是否存在于缓存或数据库中，从而避免无效的查询操作。</li>
<li><strong>缓存空值处理：</strong> 对于查询数据库返回的空结果，也可以将空结果缓存起来，设置一个较短的过期时间，避免频繁查询数据库。这样在下次查询相同的数据时，可以直接从缓存中获取空结果，而不需要再次查询数据库。</li>
<li><strong>异步加载缓存：</strong> 当缓存未命中时，可以<strong>异步加载数据到缓存中，避免在高并发场景下直接访问数据库</strong>。在异步加载过程中，可以通过互斥锁或分布式锁来保证只有一个线程去加载数据，避免重复加载。</li>
<li><strong>设置热点数据永不过期：</strong> 对于一些热点数据，可以将其设置为永不过期，或者过期时间较长，以保证这部分数据始终在缓存中可用。</li>
<li><strong>限制恶意请求：</strong> 通过访问频率控制、验证码等手段，限制对缓存的恶意请求，防止攻击者通过查询不存在的数据来触发缓存穿透。</li>
</ol>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指在缓存系统中，<strong>某个热点数据过期或失效时，同时有大量的请求访问该数据，导致请求直接访问数据库或后端服务</strong>，给数据库或后端服务造成巨大压力，导致系统性能下降甚至崩溃的现象。</p>
<p><strong>发生原因</strong></p>
<ol>
<li><strong>热点数据失效：</strong>当某个热点数据过期时，此时大量请求访问该数据，导致缓存失效，请求直接访问数据库。</li>
<li><strong>并发访问热点数据：</strong>在高并发环境下，<strong>大量的请求同时访问同一个热点数据</strong>，导致该热点数据在缓存失效期间被并发地访问，触发缓存击穿。</li>
</ol>
<p><strong>解决策略</strong>：</p>
<ol>
<li><strong>设置热点数据永不过期或过期时间较长：</strong>对于一些热点数据，可以将其设置为永不过期，或者设置一个较长的过期时间，确保热点数据在缓存中可用，减少因为过期而触发的缓存击穿。</li>
<li><strong>加互斥锁或分布式锁：</strong>在访问热点数据时，<strong>可以引入互斥锁或分布式锁，保证只有一个线程去访问后端服务或数据库</strong>，其他线程等待结果。当第一个线程获取到数据后，其他线程可以直接从缓存获取，避免多个线程同时访问后端服务，减轻压力。</li>
<li><strong>限制并发访问：</strong>通过<strong>限制并发访问热点数据的请求量，可以控制请求的流量</strong>，避免过多请求同时访问热点数据。</li>
</ol>
<p><strong>【注】缓存雪崩和缓存击穿有什么区别</strong></p>
<ul>
<li>触发条件不同：缓存雪崩是<strong>大量缓存键同时失效或过期</strong>，缓存击穿是<strong>针对某个热点数据失效或过期。</strong></li>
<li>影响范围不同：<strong>缓存雪崩影响整个缓存系统</strong>，所有请求都受到影响；<strong>缓存击穿通常只影响到热点数据</strong>，其他数据仍可从缓存中获取。</li>
<li>对后端服务的影响不同：缓存雪崩会给后端服务带来巨大压力，导致性能下降甚至崩溃；缓存击穿只在热点数据失效期间对后端服务产生压力。</li>
<li>解决方法不同：解决雪崩—合理设置缓存过期时间，引入热点数据永不过期、缓存预热、分布式缓存等策略。解决击穿—设置热点数据永不过期或过期时间较长，加互斥锁或分布式锁，异步加载缓存等策略。</li>
</ul>
<h4 id="缓存污染（或满了）"><a href="#缓存污染（或满了）" class="headerlink" title="缓存污染（或满了）"></a>缓存污染（或满了）</h4><p>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。 </p>
<p>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</p>
<h3 id="13-数据库和缓存一致性"><a href="#13-数据库和缓存一致性" class="headerlink" title="13. 数据库和缓存一致性"></a>13. 数据库和缓存一致性</h3><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811161745153" style="zoom:80%;">

<p><strong>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况</strong>。</p>
<ul>
<li>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。 </li>
<li>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</li>
</ul>
<p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching; </p>
<p>节选最最常用的Cache Aside Pattern, 总结来说就是 </p>
<ul>
<li><strong>读的时候</strong>，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。 </li>
<li><strong>更新的时候</strong>，先更新数据库，然后再删除缓存。</li>
</ul>
<p>其具体逻辑如下： </p>
<ul>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。 </li>
<li>命中：应用程序从cache中取数据，取到后返回。 </li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<h4 id="队列-重试机制"><a href="#队列-重试机制" class="headerlink" title="队列+重试机制"></a>队列+重试机制</h4><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811162918446" style="zoom:80%;">

<ul>
<li>更新数据库数据；</li>
<li>缓存因为种种问题删除失败</li>
<li>将需要删除的key发送至消息队列</li>
<li>自己消费消息，获得需要删除的key</li>
<li>继续重试删除操作，直到成功</li>
</ul>
<p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<h4 id="异步更新缓存（基于订阅binlog的同步机制）"><a href="#异步更新缓存（基于订阅binlog的同步机制）" class="headerlink" title="异步更新缓存（基于订阅binlog的同步机制）"></a>异步更新缓存（基于订阅binlog的同步机制）</h4><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811163134217" style="zoom:80%;">

<p>技术整体思路： </p>
<ol>
<li><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li><p>读Redis：热数据基本都在Redis </p>
</li>
<li><p>写MySQL: 增删改都是操作MySQL </p>
</li>
<li><p>更新Redis数据：MySQ的数据操作binlog，来更新到Redis</p>
</li>
</ul>
</li>
<li><p>Redis更新</p>
<ul>
<li>数据操作主要分为两大块：一个是全量(将全部数据一次写入到redis) 一个是增量（实时更新）；这里说的是增量,指的是mysql的update、insert、delate变更数据。</li>
<li>读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</li>
</ul>
</li>
</ol>
<h3 id="15-布隆过滤器"><a href="#15-布隆过滤器" class="headerlink" title="15. 布隆过滤器"></a>15. 布隆过滤器</h3><p>布隆过滤器（Bloom Filter）是<strong>一种空间效率极高的概率型数据结构，用于判断一个元素是否在一个集合中</strong>。它<strong>基于位数组和多个哈希函数的原理，可以高效地进行元素的查询，而且占用的空间相对较小</strong>，如下图所示：</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240804171356318.png" alt="image-20240804171356318"></p>
<p>根据 key 值计算出它的存储位置，然后将此位置标识全部标识为 1（未存放数据的位置全部为 0），查询时也是查询对应的位置是否全部为 1，如果全部为 1，则说明<strong>数据是可能存在的，否则一定不存在</strong>。</p>
<p>也就是说，如果<strong>布隆过滤器说一个元素不在集合中，那么它一定不在这个集合中；但如果它说一个元素在集合中，则有可能是不存在的（存在误差）</strong>。</p>
<h4 id="布隆过滤器执行过程"><a href="#布隆过滤器执行过程" class="headerlink" title="布隆过滤器执行过程"></a>布隆过滤器执行过程</h4><ol>
<li>在 Redis 中创建一个位数组，用于存储布隆过滤器的位向量。</li>
<li>初始化多个哈希函数，并将每个哈希函数的计算结果对应的位数组位置设置为 1。</li>
<li>添加元素到布隆过滤器时，对元素进行多次哈希计算，并将对应的位数组位置设置为 1。</li>
<li>查询元素是否存在时，对元素进行多次哈希计算，并检查对应的位数组位置是否都为 1。</li>
</ol>
<h4 id="布隆过滤器使用场景"><a href="#布隆过滤器使用场景" class="headerlink" title="布隆过滤器使用场景"></a>布隆过滤器使用场景</h4><ol>
<li><strong>大数据量去重</strong>：可以用布隆过滤器来进行数据去重，判断一个数据是否已经存在，避免重复插入。</li>
<li><strong>缓存穿透</strong>：可以用布隆过滤器来过滤掉恶意请求或请求不存在的数据，避免对后端存储的频繁访问。</li>
<li><strong>网络爬虫的 URL 去重</strong>：可以用布隆过滤器来判断 URL 是否已经被爬取，避免重复爬取。</li>
</ol>
<h3 id="16-Redis如何保证高可用性"><a href="#16-Redis如何保证高可用性" class="headerlink" title="16. Redis如何保证高可用性"></a>16. Redis如何保证高可用性</h3><p>Redis 高可用（High Availability，HA）是指 Redis 通过一系列技术手段确保在面临故障的情况下也能持续提供服务的能力。</p>
<p>Redis 作为一个内存数据库，其数据通常存储在内存中，一旦发生故障，可能导致数据丢失或服务中断，所以，为了保证 Redis 的高可用，它主要采用了以下两种手段：</p>
<ol>
<li><strong>持久化</strong>：持久化机制能够在一定程度上保证即使在服务器意外停止后，数据还能被恢复。</li>
<li><strong>多机部署</strong>：将原本为单机的 Redis 服务，变为多个 Redis 节点，主节点用来处理数据的写操作，然后再把最新的数据同步给从节点，这样即使其中有一个节点宕机了，那么其他节点依然保存了最新的数据，从而避免了 Redis 的单机故障。</li>
</ol>
<h3 id="17-Redis如何实现延时任务"><a href="#17-Redis如何实现延时任务" class="headerlink" title="17 Redis如何实现延时任务"></a>17 Redis如何实现延时任务</h3><h4 id="Redis过期事件监听"><a href="#Redis过期事件监听" class="headerlink" title="Redis过期事件监听"></a>Redis过期事件监听</h4><p>Redis 2.0 引入了发布订阅 (pub/sub) 功能。在 pub/sub 中，引入了一个叫做 <strong>channel（频道）</strong> 的概念，有点类似于消息队列中的 <strong>topic（主题）</strong>。</p>
<p>pub/sub 涉及发布者（publisher）和订阅者（subscriber，也叫消费者）两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>
</ul>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240808141011381.png" alt="image-20240808141011381"></p>
<p>在 pub/sub 模式下，生产者需要指定消息发送到哪个 channel 中，而消费者则订阅对应的 channel 以获取消息。</p>
<p>Redis 中有很多默认的 channel，这些 channel 是由 Redis 本身向它们发送消息的，而不是我们自己编写的代码。其中，<code>__keyevent@0__:expired</code> 就是一个默认的 channel，负责监听 key 的过期事件。也就是说，<strong>当一个 key 过期之后，Redis 会发布一个 key 过期的事件到<code>__keyevent@&lt;db&gt;__:expired</code>这个 channel 中。</strong> 我们只需要监听这个 channel，就可以拿到过期的 key 的消息，进而实现了延时任务功能。</p>
<p>【缺陷】</p>
<p><strong>时效性差：</strong>过期事件消息是在 Redis 服务器删除 key 时发布的，而不是一个 key 过期之后就会就会直接发布。Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。但是存在我设置了 key 的过期时间，但到了指定时间 key 还未被删除，进而没有发布过期事件的情况。</p>
<p><strong>丢消息</strong>：Redis 的 pub/sub 模式中的消息并不支持持久化，这与消息队列不同。在 Redis 的 pub/sub 模式中，发布者将消息发送给指定的频道，订阅者监听相应的频道以接收消息。当没有订阅者时，消息会被直接丢弃，在 Redis 中不会存储该消息。</p>
<p><strong>多服务实例下消息重复消费</strong>：Redis 的 pub/sub 模式目前只有广播模式，这意味着当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。这个时候，我们需要注意多个服务实例重复处理消息的问题，这会增加代码开发量和维护难度。</p>
<h4 id="Redisson内置的延时队列"><a href="#Redisson内置的延时队列" class="headerlink" title="Redisson内置的延时队列"></a>Redisson内置的延时队列</h4><p>Redisson 的延迟队列 RDelayedQueue 是基于 Redis 的 SortedSet 来实现的。SortedSet 是一个有序集合，其中的每个元素都可以设置一个分数，代表该元素的权重。Redisson 利用这一特性，将需要延迟执行的任务插入到 SortedSet 中，并给它们设置相应的过期时间作为分数。</p>
<p>Redisson 使用 <code>zrangebyscore</code> 命令扫描 SortedSet 中过期的元素，然后将这些过期元素从 SortedSet 中移除，并将它们加入到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样做可以避免对整个 SortedSet 进行轮询，提高了执行效率。</p>
<p>相比于 Redis 过期事件监听实现延时任务功能，这种方式具备下面这些优势：</p>
<p><strong>减少了丢消息的可能</strong>：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。</p>
<p><strong>消息不存在重复消费问题</strong>：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</p>
<p>跟 Redisson 内置的延时队列相比，消息队列可以通过保障消息消费的可靠性、控制消息生产者和消费者的数量等手段来实现更高的吞吐量和更强的可靠性，实际项目中首选使用消息队列的延时消息这种方案。</p>
<h3 id="18-Redis-数据结构"><a href="#18-Redis-数据结构" class="headerlink" title="18. Redis 数据结构"></a>18. Redis 数据结构</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</a></p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240810162721622" style="zoom:60%;">

<p><strong>底层数据结构主要有：</strong></p>
<ul>
<li>简单动态字符串 - sds</li>
<li>压缩列表 - ZipList</li>
<li>快表 - QuickList</li>
<li>字典/哈希表 - Dict</li>
<li>整数集 - IntSet</li>
<li>跳表 - ZSkipList</li>
</ul>
<p><strong>SDS:</strong> Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 <strong>简单动态字符串（simple dynamic string,SDS</strong>）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p>
<ul>
<li><strong>为什么使用SDS</strong><ul>
<li>常数复杂度获取字符串长度, 通过strlen key命令就可以获取key的字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串的内存重新分配的次数</li>
</ul>
</li>
</ul>
<p><strong>ZipList:</strong> ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p>
<h3 id="19-Redis消息传递模式-—-发布订阅模式"><a href="#19-Redis消息传递模式-—-发布订阅模式" class="headerlink" title="19. Redis消息传递模式 — 发布订阅模式"></a>19. Redis消息传递模式 — 发布订阅模式</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-pub-sub.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-pub-sub.html</a></p>
<h4 id="基于频道的发布订阅模式"><a href="#基于频道的发布订阅模式" class="headerlink" title="基于频道的发布订阅模式"></a>基于频道的发布订阅模式</h4><p><strong>发布者发布消息</strong>：publish</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 发布者发布消息的命令是 publish,用法是 publish channel message，如向 channel1.1说一声hi</span><br><span class="line">127.0.0.1:6379&gt; publish channel:1 hi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></tbody></table></figure>

<p><strong>订阅者订阅频道：</strong> subscribe</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 订阅频道的命令是 subscribe，可以同时订阅多个频道，用法是 subscribe channel1 [channel2 ...],例如新开一个客户端订阅上面频道:(不会收到消息，因为不会收到订阅之前就发布到该频道的消息)</span><br><span class="line">127.0.0.1:6379&gt; subscribe channel:1</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span> // 消息类型</span><br><span class="line">2) <span class="string">"channel:1"</span> // 频道</span><br><span class="line">3) <span class="string">"hi"</span> // 消息内容</span><br></pre></td></tr></tbody></table></figure>

<p>消息类型的取值可能有以下3个：</p>
<ul>
<li>subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</li>
<li>message。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</li>
<li>unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非”发布/订阅”模式的命令了。</li>
</ul>
<h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5><p>底层是<strong>通过字典（图中的pubsub_channels）实现的</strong>，这个字典就用于保存订阅频道的信息：字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<p>当客户端调用 SUBSCRIBE 命令时， 程序就将客户端和要订阅的频道在 pubsub_channels 字典中关联起来。</p>
<p>当调用 <code>PUBLISH channel message</code> 命令， 程序首先根据 channel 定位到字典的键， 然后将信息发送给字典值链表中的所有客户端。</p>
<p>使用 UNSUBSCRIBE 命令可以退订指定的频道， 这个命令执行的是订阅的反操作： 它从 pubsub_channels 字典的给定频道（键）中， 删除关于当前客户端的信息， 这样被退订频道的信息就不会再发送给这个客户端。</p>
<h4 id="基于模式的发布订阅模式"><a href="#基于模式的发布订阅模式" class="headerlink" title="基于模式的发布订阅模式"></a>基于模式的发布订阅模式</h4><p>如果有某个/某些模式和这个频道匹配的话，那么所有订阅这个/这些频道的客户端也同样会收到信息。 — 多了一个模式匹配</p>
<p>通配符中?表示1个占位符，*表示任意个占位符(包括0)，?*表示1个以上占位符。</p>
<p>发布消息：publish发布；订阅消息：psubscribe订阅；</p>
<h5 id="如何实现-1"><a href="#如何实现-1" class="headerlink" title="如何实现"></a>如何实现</h5><p>底层是pubsubPattern节点的链表。<strong>数据结构</strong> redisServer.pubsub_patterns 属性是一个链表，链表中保存着所有和模式相关的信息。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> {</span></span><br><span class="line">    redisClient *client;</span><br><span class="line">    robj *pattern;</span><br><span class="line">} pubsubPattern;</span><br><span class="line"><span class="comment">// client 属性保存着订阅模式的客户端，而 pattern 属性则保存着被订阅的模式。</span></span><br></pre></td></tr></tbody></table></figure>

<p>订阅：当调用 <strong>PSUBSCRIBE</strong> 命令订阅一个模式时,程序就创建一个包含客户端信息和被订阅模式的 pubsubPattern 结构,并将该结构添加到redisServer.pubsub_patterns 链表中。通过遍历整个 pubsub_patterns 链表，程序可以检查所有正在被订阅的模式，以及订阅这些模式的客户端。</p>
<p>发布：发送信息到模式的工作也是由 <strong>PUBLISH</strong> 命令进行的, 显然就是匹配模式获得Channels，然后再把消息发给客户端。</p>
<p> 退订：使用 <strong>PUNSUBSCRIBE</strong> 命令可以退订指定的模式， 这个命令执行的是订阅模式的反操作： 程序会删除 redisServer.pubsub_patterns 链表中， 所有和被退订模式相关联的 pubsubPattern 结构， 这样客户端就不会再收到和模式相匹配的频道发来的信息。</p>
<h3 id="20-Redis-事件机制"><a href="#20-Redis-事件机制" class="headerlink" title="20. Redis 事件机制"></a>20. Redis 事件机制</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html</a></p>
<p>Redis中的事件驱动库<strong>只关注网络IO，以及定时器</strong>。</p>
<p>该事件库主要处理两类事件：</p>
<ul>
<li>文件事件：用于处理Redis服务器和客户端之间的网络IO。</li>
<li>时间事件：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li>
</ul>
<p><code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis基于Reactor模式开发了自己的网络事件处理器，也就是文件事件处理器。文件事件处理器使用IO多路复用技术（建议先看下 Java IO多路复用详解 ），同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>1. 为什么单线程的Redis能那么快？</strong></p>
<p><strong>Redis的瓶颈主要在IO而不是CPU</strong>，所以为了省开发量，在6.0版本前是单线程模型；其次，Redis 是单线程主要是指 <strong>Redis 的网络 IO 和键值对读写是由一个线程来完成的</strong>，这也是 Redis 对外提供键值存储服务的主要流程。（但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的）。</p>
<p><strong>Redis 采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</strong></p>
<p><strong>2. Redis事件响应框架ae_event及文件事件处理器</strong></p>
<p>Redis并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。</p>
<p><strong>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等</strong>。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如<code>ae_select.c</code>，<code>ae_epoll.c</code>， <code>ae_kqueue.c</code>等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。事件响应框架一般都采用该架构，比如 netty 和 libevent。</p>
<p>文件事件处理器有四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器以及事件处理器。</p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811095537159" style="zoom:60%;">

<p>一次 Redis 客户端与服务器进行连接并且发送命令的过程如图所示：</p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811095631899" style="zoom:60%;">

<ul>
<li>客户端向服务端发起<strong>建立 socket 连接的请求</strong>，那么监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行。处理器会对客户端的连接请求</li>
<li>进行<strong>应答</strong>，然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器关联。</li>
<li>客户端建立连接后，向服务器<strong>发送命令</strong>，那么客户端套接字将产生 AE_READABLE 事件，触发命令请求处理器执行，处理器读取客户端命令，然后传递给相关程序去执行。</li>
<li><strong>执行命令获得相应的命令回复</strong>，为了将命令回复传递给客户端，服务器将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器关联。当客户端试图读取命令回复时，客户端套接字产生 AE_WRITEABLE 事件，触发命令回复处理器将命令回复全部写入到套接字中。</li>
</ul>
<p><strong>3. Redis IO多路复用模型</strong></p>
<p>在 Redis 只运行单线程的情况下，<strong>该机制允许内核中，同时存在多个监听套接字和已连接套接字</strong>。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>
<p>下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811100103291" style="zoom:38%;">

<p>基于多路复用的Redis高性能IO模型为了在请求到达时能通知到 Redis 线程，<strong>select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数</strong>。那么，回调机制是怎么工作的呢？</p>
<p>其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</p>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><ul>
<li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li>
<li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>返回值为AE_NOMORE表示定时事件，返回值为非AE_NOMORE表示周期事件。</p>
<p><strong>服务器所有的时间事件都放在一个无序链表中</strong>，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件，所以不影响事件执行的性能。</p>
<h4 id="创建事件管理器"><a href="#创建事件管理器" class="headerlink" title="创建事件管理器"></a>创建事件管理器</h4><p>Redis 服务端在其初始化函数 initServer中，会创建事件管理器aeEventLoop对象。</p>
<p>函数aeCreateEventLoop将创建一个事件管理器，主要是初始化 aeEventLoop的各个属性值，比如events、fired、timeEventHead和apidata：</p>
<ul>
<li>首先创建aeEventLoop对象。</li>
<li>初始化未就绪文件事件表、就绪文件事件表。events指针指向未就绪文件事件表、fired指针指向就绪文件事件表。表的内容在后面添加具体事件时进行初变更。</li>
<li>初始化时间事件列表，设置timeEventHead和timeEventNextId属性。</li>
<li>调用aeApiCreate 函数创建epoll实例，并初始化 apidata。</li>
</ul>
<p>aeApiCreate 函数首先创建了aeApiState对象，初始化了epoll就绪事件表；然后调用epoll_create创建了epoll实例，最后将该aeApiState赋值给apidata属性。</p>
<p>aeApiState对象中epfd存储epoll的标识，events是一个epoll就绪事件数组，当有epoll事件发生时，所有发生的epoll事件和其描述符将存储在这个数组中。这个就绪事件数组由应用层开辟空间、内核负责把所有发生的事件填充到该数组。</p>
<h4 id="创建文件事件"><a href="#创建文件事件" class="headerlink" title="创建文件事件"></a>创建文件事件</h4><p>aeFileEvent是文件事件结构，对于每一个具体的事件，都有读处理函数和写处理函数等。Redis 调用aeCreateFileEvent函数针对不同的套接字的读写事件注册对应的文件事件。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> {</span></span><br><span class="line">    <span class="comment">/* 监听事件类型掩码,值可以是 AE_READABLE 或 AE_WRITABLE */</span></span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="comment">/* 读事件处理器 */</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    <span class="comment">/* 写事件处理器 */</span></span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    <span class="comment">/* 多路复用库的私有数据 */</span></span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">} aeFileEvent;</span><br><span class="line"><span class="comment">/* 使用typedef定义的处理器函数的函数类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">aeFileProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, </span></span><br><span class="line"><span class="params"><span class="type">int</span> fd, <span class="type">void</span> *clientData, <span class="type">int</span> mask)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>比如说，Redis 进行主从复制时，从服务器需要主服务器建立连接，它会发起一个 socekt连接，然后调用aeCreateFileEvent函数针对发起的socket的读写事件注册了对应的事件处理器，也就是syncWithMaster函数。</p>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>因为 Redis 中同时存在文件事件和时间事件两个事件类型，所以服务器必须对这两个事件进行调度，决定何时处理文件事件，何时处理时间事件，以及如何调度它们。</p>
<h4 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h4><p>当不在需要某个事件时，需要把事件删除掉。例如: 如果fd同时监听读事件、写事件。当不在需要监听写事件时，可以把该fd的写事件删除。</p>
<p>aeDeleteEventLoop函数的执行过程总结为以下几个步骤</p>
<ul>
<li>根据fd在未就绪表中查找到事件</li>
<li>取消该fd对应的相应事件标识符</li>
<li>调用aeApiFree函数，内核会将epoll监听红黑树上的相应事件监听取消。</li>
</ul>
<h3 id="21-Redis-高可用-主从复制"><a href="#21-Redis-高可用-主从复制" class="headerlink" title="21. Redis - 高可用 主从复制"></a>21. Redis - 高可用 主从复制</h3><p><strong>主从复制概述</strong></p>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；<strong>数据的复制是单向的，只能由主节点到从节点。</strong></p>
<p>主从复制的作用主要包括：</p>
<ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用性：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ul>
<p>主从库之间采用的是读写分离的方式：</p>
<ul>
<li>读操作：主库、从库都可以接受</li>
<li>写操作：首先到主库执行，然后将写操作同步给从库</li>
</ul>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811125258996" style="zoom:50%;">

<p><strong>主从复制原理</strong></p>
<ul>
<li>全量复制：比如第一次同步时 RDB快照文件</li>
<li>增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库</li>
</ul>
<h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>当我们启动多个 Redis 实例的时候，<strong>它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系</strong>，之后会按照三个阶段完成数据的第一次同步。</p>
<p>现在有实例 1(ip：172.16.19.3)和实例 2(ip：172.16.19.5)，我们在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 172.16.19.3 6379</span><br></pre></td></tr></tbody></table></figure>

<p><strong>全量复制的三个阶段</strong></p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811125644073" style="zoom:30%;">

<p><strong>第一阶段是主从库间建立连接、协商同步的过程</strong>，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p>
<p>具体来说，<strong>从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制</strong>。<strong>psync 命令包含了主库的 runID 和复制进度 offset 两个参数。</strong>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。<strong>当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”</strong>。<strong>offset，此时设为 -1，表示第一次复制</strong>。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：<strong>主库 runID 和主库目前的复制进度 offset，返回给从库。</strong>从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</p>
<p><strong>第二阶段，主库将所有数据同步给从库。</strong>从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p>
<p>具体来说，<strong>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</strong>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，<strong>主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</strong></p>
<p><strong>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</strong>具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。</p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811130421216" style="zoom:30%;">

<p><code>replication buffer</code> 和 <code>repl_backlog_buffer</code></p>
<p><code>repl_backlog_buffer</code> : 它是为了从库断开之后，<strong>如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。</strong> <strong>如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制</strong>，<strong>所以repl_backlog_buffer配置尽量大一些</strong>，可以降低主从断开后全量复制的概率。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。</p>
<p><code>replication buffer</code>: Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。</p>
<p><strong>如果在网络断开期间，repl_backlog_size环形缓冲区写满之后，从库是会丢失掉那部分被覆盖掉的数据，还是直接进行全量复制呢？</strong></p>
<p>对于这个问题来说，有两个关键点： </p>
<ol>
<li>一个从库如果和主库断连时间过长，造成它在主库repl_backlog_buffer的slave_repl_offset位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。 </li>
<li><strong>每个从库会记录自己的slave_repl_offset，每个从库的复制进度也不一定相同。</strong> 在和主库重连进行恢复时，从库会通过psync命令把自己记录的slave_repl_offset发给主库，主库会根据从库各自的复制进度，来决定这个从库可以进行增量复制，还是全量复制。</li>
</ol>
<h4 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a>当主服务器不进行持久化时复制的安全性</h4><p>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</p>
<p><strong>为什么不持久化的主服务器自动重启非常危险呢</strong>？为了更好的理解这个问题，看下面这个失败的例子，其中主服务器和从服务器中数据库都被删除了。</p>
<ul>
<li>我们设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。</li>
<li>这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。</li>
<li>节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。</li>
<li>当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。</li>
</ul>
<p>如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</p>
<h4 id="为什么主从全量复制使用RDB而不使用AOF"><a href="#为什么主从全量复制使用RDB而不使用AOF" class="headerlink" title="为什么主从全量复制使用RDB而不使用AOF"></a>为什么主从全量复制使用RDB而不使用AOF</h4><p><strong>RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。</strong>而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。  <strong>在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快</strong>，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。</p>
<p>假设要使用AOF做全量复制，意味着必须打开AOF功能，<strong>打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能</strong>。而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。</p>
<h4 id="为什么还有无磁盘复制模式"><a href="#为什么还有无磁盘复制模式" class="headerlink" title="为什么还有无磁盘复制模式"></a>为什么还有无磁盘复制模式</h4><p>Redis 默认是磁盘复制，但是如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力。Redis从2.8.18版本开始尝试支持无磁盘的复制。使用这种设置时，<strong>子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。</strong></p>
<p><strong>无磁盘复制模式</strong>：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。</p>
<p><strong>使用repl-diskless-sync配置参数来启动无磁盘复制</strong>。</p>
<p><strong>使用repl-diskless-sync-delay 参数来配置传输开始的延迟时间</strong>；master等待一个repl-diskless-sync-delay的秒数，如果没slave来的话，就直接传，后来的得排队等了; 否则就可以一起传。</p>
<h4 id="为什么还会有从库的从库的设计"><a href="#为什么还会有从库的从库的设计" class="headerlink" title="为什么还会有从库的从库的设计"></a>为什么还会有从库的从库的设计</h4><p>通过分析主从库间第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。</p>
<p>如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量复制。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。那么，有没有好的解决方法可以分担主库压力呢？</p>
<p>在刚才介绍的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，我们可以通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。</p>
<h4 id="读写分离及其中的问题"><a href="#读写分离及其中的问题" class="headerlink" title="读写分离及其中的问题"></a>读写分离及其中的问题</h4><p>在主从复制基础上实现的读写分离，可以实现Redis的读负载均衡：由<strong>主节点提供写服务，由一个或多个从节点提供读服务</strong>（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可以大大提高Redis服务器的并发量。下面介绍在使用Redis读写分离时，需要注意的问题。</p>
<p><strong>延迟与不一致问题</strong></p>
<p>前面已经讲到，由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等。</p>
<p>在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的slave-serve-stale-data参数便与此有关：它控制这种情况下从节点的表现；如果为yes（默认值），则从节点仍能够响应客户端的命令，如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为no。</p>
<p><strong>数据过期问题</strong></p>
<p>在单机版Redis中，存在两种删除策略：</p>
<ul>
<li><strong>惰性删除：</strong>服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。 </li>
<li><strong>定期删除：</strong>服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li>
</ul>
<p>在主从复制场景下，为了主从节点的数据一致性，<strong>从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除</strong>。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</p>
<p><strong>故障切换问题</strong></p>
<p>在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。</p>
<h3 id="22-Redis-高可用-哨兵机制-Redis-Sentinel"><a href="#22-Redis-高可用-哨兵机制-Redis-Sentinel" class="headerlink" title="22. Redis - 高可用  哨兵机制(Redis Sentinel)"></a>22. Redis - 高可用  哨兵机制(Redis Sentinel)</h3><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811142207367" style="zoom:57%;">

<p><strong>哨兵的功能</strong></p>
<ul>
<li><strong>监控：</strong> 哨兵会不断地检查主节点和从节点是否运作正常</li>
<li><strong>自动故障转移：</strong> 当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li>
<li><strong>配置提供者：</strong> 客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li>
<li><strong>通知：</strong> 哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p> 其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h4 id="哨兵集群的组建"><a href="#哨兵集群的组建" class="headerlink" title="哨兵集群的组建"></a>哨兵集群的组建</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6995794821805768718#heading-7">https://juejin.cn/post/6995794821805768718#heading-7</a></p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811143510830" style="zoom:30%;">

<p><strong>配置主从节点,主要是修改配置文件</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 主节点</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">port 6379</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">logfile <span class="string">"/usr/local/redis-6379/redis-6379.log"</span></span><br><span class="line"><span class="comment">#全量备份文件名</span></span><br><span class="line">dbfilename redis-6379.rdb</span><br><span class="line"><span class="comment">#指定路径名</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/redis-6379</span><br><span class="line"><span class="comment">#设置redis密码</span></span><br><span class="line">requirepass 123456</span><br><span class="line"><span class="comment">#开启增量备份</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line">appendfilename <span class="string">"appendonly-6379.aof"</span></span><br><span class="line"></span><br><span class="line">// 从节点</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">port 7001</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">pidfile /var/run/redis_7001.pid</span><br><span class="line">logfile <span class="string">"/usr/local/redis-7001/redis-7001.log"</span></span><br><span class="line"><span class="comment">#全量备份文件名</span></span><br><span class="line">dbfilename redis-7001.rdb</span><br><span class="line"><span class="comment">#指定路径名</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/redis-7001</span><br><span class="line"><span class="comment">#设置主节点 地址端口+主节点连接密码</span></span><br><span class="line">replicaof 192.168.154.145 6379     <span class="comment"># 认主操作</span></span><br><span class="line">masterauth 123456</span><br><span class="line"><span class="comment">#设置redis密码</span></span><br><span class="line">requirepass 123456</span><br><span class="line"><span class="comment">#开启增量备份</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line">appendfilename <span class="string">"appendonly-7001.aof"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>配置哨兵节点</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件 左侧为修改的行数,方便大家查找</span></span><br><span class="line">vim /usr/local/redis-6379/sentinel/sentinel.conf </span><br><span class="line"><span class="comment"># 配置哨兵端口</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 配置进程id存储地址</span></span><br><span class="line">pidfile <span class="string">"/usr/local/redis-6379/redis-sentinel-26379.pid"</span></span><br><span class="line"><span class="comment">#配置log路径    </span></span><br><span class="line">logfile <span class="string">"/usr/local/redis-6379/sentinel/redis-sentinel.log"</span></span><br><span class="line"><span class="comment"># 配置哨兵工作目录</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">"/usr/local/redis-6379/sentinel"</span></span><br><span class="line"><span class="comment"># 配置监控的redis主节点</span></span><br><span class="line">sentinel monitor mymaster 192.168.154.145 6379 2</span><br><span class="line"><span class="comment"># 配置主节点登录密码</span></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置哨兵端口</span></span><br><span class="line">port 27001</span><br><span class="line"><span class="comment"># 配置进程id存储地址</span></span><br><span class="line">pidfile <span class="string">"/usr/local/redis-7001/redis-sentinel-27001.pid"</span></span><br><span class="line"><span class="comment"># 配置log路径    </span></span><br><span class="line">logfile <span class="string">"/usr/local/redis-7001/sentinel/redis-sentinel.log"</span></span><br><span class="line"><span class="comment"># 配置哨兵工作目录</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">"/usr/local/redis-7001/sentinel"</span></span><br><span class="line"><span class="comment"># 配置监控的redis主节点</span></span><br><span class="line">sentinel monitor mymaster 192.168.154.145 6379 2</span><br><span class="line"><span class="comment"># 配置主节点登录密码</span></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h4 id="哨兵监控Redis库"><a href="#哨兵监控Redis库" class="headerlink" title="哨兵监控Redis库"></a>哨兵监控Redis库</h4><p>这是由<strong>哨兵向主库发送 INFO 命令来完成的</strong>。就像下图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。</p>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811145212796" style="zoom:30%;">

<h4 id="主库下线的判定"><a href="#主库下线的判定" class="headerlink" title="主库下线的判定"></a>主库下线的判定</h4><p>首先要理解两个概念：主观下线和客观下线 </p>
<ul>
<li><strong>主观下线：</strong>任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断； </li>
<li><strong>客观下线：</strong>有哨兵集群共同决定Redis节点是否下线；</li>
</ul>
<p>当某个哨兵（如下图中的哨兵2）判断主库“主观下线”后，就会<strong>给其他哨兵发送 is-master-down-by-addr 命令</strong>。接着，其他哨兵会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p>
<p>如果<strong>赞成票数（这里是2）是大于等于哨兵配置文件中的 quorum 配置项</strong>（比如这里如果是quorum=2）, 则可以判定主库客观下线了。</p>
<h4 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h4><p> <strong>哨兵的选举机制是什么样的</strong></p>
<p>哨兵的选举机制其实很简单，就是一个<strong>Raft选举算法</strong>： <strong>选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举</strong></p>
<p>任何一个想成为 Leader 的哨兵，要满足两个条件：</p>
<ul>
<li>第一，拿到半数以上的赞成票； </li>
<li>第二，<strong>拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</strong></li>
</ul>
<h4 id="新主库的选出"><a href="#新主库的选出" class="headerlink" title="新主库的选出"></a>新主库的选出</h4><p><strong>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</strong> </p>
<p><strong>选择salve-priority从节点优先级最高（redis.conf）的</strong> </p>
<p><strong>选择复制偏移量最大</strong>，只复制最完整的从节点</p>
<h4 id="故障的转移"><a href="#故障的转移" class="headerlink" title="故障的转移"></a>故障的转移</h4><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811151922015" style="zoom:60%;">

<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240811151823691" style="zoom:87%;">

<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240811152015325.png" alt="image-20240811152015325"></p>
<ul>
<li>将slave-1脱离原从节点（PS: 5.0 中应该是replicaof no one)，升级主节点</li>
<li>将从节点slave-2指向新的主节点 </li>
<li>通知客户端主节点已更换 </li>
<li>将原主节点（oldMaster）变成从节点，指向新的主节点</li>
</ul>
<h3 id="23-Redis-分片技术"><a href="#23-Redis-分片技术" class="headerlink" title="23. Redis - 分片技术"></a>23. Redis - 分片技术</h3><h4 id="哈希槽-Hash-Slot"><a href="#哈希槽-Hash-Slot" class="headerlink" title="哈希槽(Hash Slot)"></a>哈希槽(Hash Slot)</h4><p>Redis-cluster没有使用一致性hash，而是引入了<strong>哈希槽</strong>的概念。<strong>Redis-cluster中有16384(即2的14次方）个哈希槽</strong>，<strong>每个key通过CRC16校验后对16383取模来决定放置哪个槽。</strong>Cluster中的每个节点负责一部分hash槽（hash slot）。</p>
<p>比如集群中存在三个节点，则可能存在的一种分配如下：</p>
<ul>
<li>节点A包含0到5500号哈希槽；</li>
<li>节点B包含5501到11000号哈希槽；</li>
<li>节点C包含11001 到 16384号哈希槽。</li>
</ul>
<h4 id="Keys-hash-tags"><a href="#Keys-hash-tags" class="headerlink" title="Keys hash tags"></a>Keys hash tags</h4><p>Hash tags提供了一种途径，<strong>用来将多个(相关的)key分配到相同的hash slot中</strong>。这时Redis Cluster中实现multi-key操作的基础。</p>
<p>hash tag规则如下，如果满足如下规则，{和}之间的字符将用来计算HASH_SLOT，以保证这样的key保存在同一个slot中。 </p>
<ul>
<li>key包含一个{字符 </li>
<li>并且 如果在这个{的右面有一个}字符 </li>
<li>并且 如果在{和}之间存在至少一个字符</li>
</ul>
<h4 id="Cluster-nodes属性"><a href="#Cluster-nodes属性" class="headerlink" title="Cluster nodes属性"></a>Cluster nodes属性</h4><p>每个<strong>节点在cluster中有一个唯一的名字</strong>。这个<strong>名字由160bit随机十六进制数字表示，并在节点启动时第一次获得</strong>(通常通过/dev/urandom)。节点在配置文件中保留它的ID，并永远地使用这个ID，直到被管理员使用CLUSTER RESET HARD命令hard reset这个节点。</p>
<p>节点ID被用来在整个cluster中标识每个节点。一个节点可以修改自己的IP地址而不需要修改自己的ID。Cluster可以检测到IP /port的改动并通过运行在cluster bus上的gossip协议重新配置该节点。 </p>
<p>节点ID不是唯一与节点绑定的信息，但是他是唯一的一个总是保持全局一致的字段。每个节点都拥有一系列相关的信息。一些信息时关于本节点在集群中配置细节，并最终在cluster内部保持一致的。而其他信息，比如节点最后被ping的时间，是节点的本地信息。</p>
<p>每个节点维护着集群内其他节点的以下信息：<code>node id</code>, <code>节点的IP和port</code>，<code>节点标签</code>，<code>master node id</code>（如果这是一个slave节点），<code>最后被挂起的ping的发送时间</code>(如果没有挂起的ping则为0)，<code>最后一次收到pong的时间</code>，<code>当前的节点configuration epoch</code> ，<code>链接状态</code>，以及最后是该节点服务的<code>hash slots</code>。</p>
<h4 id="Cluster总线"><a href="#Cluster总线" class="headerlink" title="Cluster总线"></a>Cluster总线</h4><p>每个Redis Cluster节点有一个额外的TCP端口用来接受其他节点的连接。这个端口与用来接收client命令的普通TCP端口有一个固定的offset。该端口等于普通命令端口加上10000.例如，一个Redis街道口在端口6379坚挺客户端连接，那么它的集群总线端口16379也会被打开。 </p>
<p><strong>节点到节点的通讯只使用集群总线，同时使用集群总线协议</strong>：有不同的类型和大小的帧组成的二进制协议。集群总线的二进制协议没有被公开文档话，因为他不希望被外部软件设备用来预计群姐点进行对话。</p>
<h4 id="集群拓扑"><a href="#集群拓扑" class="headerlink" title="集群拓扑"></a>集群拓扑</h4><p><strong>Redis Cluster是一张全网拓扑，节点与其他每个节点之间都保持着TCP连接。</strong> 在一个拥有N个节点的集群中，每个节点由N-1个TCP传出连接，和N-1个TCP传入连接。 这些TCP连接总是保持活性(be kept alive)。当一个节点在集群总线上发送了ping请求并期待对方回复pong，（如果没有得到回复）在等待足够成时间以便将对方标记为不可达之前，它将先尝试重新连接对方以刷新与对方的连接。 而在全网拓扑中的Redis Cluster节点，节点使用gossip协议和配置更新机制来避免在正常情况下节点之间交换过多的消息，因此集群内交换的消息数目(相对节点数目)不是指数级的。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="1-IoC"><a href="#1-IoC" class="headerlink" title="1. IoC"></a>1. IoC</h3><h4 id="什么是IoC"><a href="#什么是IoC" class="headerlink" title="什么是IoC"></a>什么是IoC</h4><p>IoC（Inversion of Control，控制反转）是 Spring 框架的核心概念之一，它是一种设计原则和编程模式，用于实现松耦合和可测试的应用程序。</p>
<h4 id="如何实现IoC"><a href="#如何实现IoC" class="headerlink" title="如何实现IoC"></a>如何实现IoC</h4><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1231293">https://developer.aliyun.com/article/1231293</a></p>
<p>IoC 容器通过以下两种主要的方式来实现控制反转：</p>
<ol>
<li><strong>依赖注入（Dependency Injection，DI）</strong>：依赖注入是 IoC 的一种具体实现方式，通过将依赖关系注入到对象中，实现了对象之间的解耦。容器负责查找依赖对象，并将其自动注入到相应的对象中。依赖注入可以通过构造函数、Setter 方法或接口注入来完成。</li>
<li><strong>依赖查找（Dependency Lookup）</strong>：依赖查找是另一种 IoC 的实现方式，它通过容器提供的 API，开发人员手动查找和获取所需的依赖对象。开发人员在代码中通过容器提供的接口来获取所需的对象实例，从而实现了对象之间的解耦。</li>
</ol>
<p>【注】依赖注入和依赖查找的区别：依赖注入是一种将依赖关系从一个对象传递到另一个对象的技术；依赖查找是一种从 IoC 容器中查找依赖对象的技术。</p>
<p><strong>依赖注入是将依赖关系委托给容器，由容器来管理对象之间的依赖关系；而依赖查找是由对象自己来查找它所依赖的对象，容器只负责管理对象的生命周期。</strong></p>
<h4 id="Ioc底层原理"><a href="#Ioc底层原理" class="headerlink" title="Ioc底层原理"></a>Ioc底层原理</h4><p>Spring 中的 IoC 底层是通过<strong>工厂模式+反射</strong>实现的，具体来说，它的实现步骤是这样的：</p>
<ol>
<li>首先，我们通过代码初始化IoC容器：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicatioContext</span>  <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>之后会创建一个工厂类，工厂类中有一个创建 Bean 的方法 createBean。</li>
<li>createBean 中首先会通过读取配置文件，获取到全类名，如下所示：</li>
</ol>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"com.example.MyBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>之后通过反射，将获取到的全类名进行加载，创建对象存放到 IoC 容器中。</li>
<li>当有代码使用了 DI 时，从容器中找到（根据类名或类型查找）此实例进行使用，如下代码所示：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyBean myBean;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Bean: "</span> + myBean);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="DI实现原理"><a href="#DI实现原理" class="headerlink" title="DI实现原理"></a>DI实现原理</h4><p><strong>DI（依赖注入）是一种将依赖关系从一个对象传递到另一个对象的技术。</strong>在 Spring 框架中，DI 是通过使用注释（如 @Autowired、@Qualifier 和 @Value）来实现的。</p>
<p><strong>DI 的实现原理是通过反射机制实现的。</strong>在 Spring 框架中，当容器创建一个对象时，它会检查该对象的依赖关系，并使用反射机制查找依赖对象。然后，容器将依赖对象注入到该对象中。</p>
<p>具体来说，<strong>当使用 @Autowired 注释时，Spring 容器会自动查找与该类型匹配的 bean，并将其注入到该字段中。如果有多个匹配的 bean，则可以使用 @Qualifier 注释来指定要注入的 bean 的名称。</strong> <strong>当使用 @Value 注释时，Spring 容器会将属性值注入到该字段中。属性值可以从配置文件中读取，也可以是硬编码的值。</strong></p>
<h4 id="IoC的DI的区别"><a href="#IoC的DI的区别" class="headerlink" title="IoC的DI的区别"></a>IoC的DI的区别</h4><p><strong>IoC（Inverse of Control，控制反转）</strong>：它是一种思想，主要解决程序设计中的对象依赖关系管理问题。在 IoC 思想中，对象的创建权反转给第三方容器，由容器进行对象的创建及依赖关系的管理。</p>
<p><strong>DI（Dependency Injection，依赖注入）</strong>：它是 IoC 思想的具体实现方式之一，用于实现 IoC。在 Spring 中，依赖注入是指:在对象创建时，由容器自动将依赖对象注入到需要依赖的对象中。</p>
<p><strong>IoC 是一种思想、理念，定义了对象创建和依赖关系处理的方式。DI 是 IoC 思想的具体实现方式之一，实际提供对象依赖关系的注入功能。</strong></p>
<h3 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2. AOP"></a>2. AOP</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种软件开发的编程范式，用于<strong>将跨越多个模块的（横切）关注点从核心业务逻辑中分离出来，使得横切关注点的定义和应用能够更加集中和重用。</strong></p>
<p>AOP 通过引入横切关注点，<strong>将其与核心业务逻辑分离，并以模块化的方式进行管理</strong>。它通过切面（Aspect）来描述横切关注点，切面是对横切关注点的封装。切面定义了在何处、何时和如何应用横切关注点。在 AOP 中，切面可以横跨多个对象，独立于核心业务逻辑。</p>
<p><strong>AOP 可以通过预编译方式和运行期动态代理的方式来实现，它的主要目的是降低业务逻辑的耦合性，提高程序的可重用性和开发效率。</strong></p>
<p>AOP 常用于统一功能的处理，例如：<strong>事务管理、日志记录、权限检查等功能。</strong></p>
<h4 id="AOP的组成"><a href="#AOP的组成" class="headerlink" title="AOP的组成"></a>AOP的组成</h4><p>AOP 的实现依赖于以下几个概念：</p>
<ul>
<li><strong>切面（Aspect）</strong>：切面是横切关注点的模块化单元，它将通知和切点组合在一起，描述了在何处、何时和如何应用横切关注点。</li>
<li><strong>切点（Pointcut）</strong>：用于定义哪些连接点被切面关注，即切面要织入的具体位置。</li>
<li><strong>连接点（Join Point）</strong>：在程序执行过程中的某个特定点，例如方法调用、异常抛出等。</li>
<li><strong>通知（Advice）</strong>：切面在特定切点上执行的代码，包括在连接点之前、之后或周围执行的行为。</li>
<li><strong>织入（Weaving）</strong>：将切面应用到目标对象中的过程，可以在编译时、加载时或运行时进行。</li>
</ul>
<h4 id="AOP技术实现"><a href="#AOP技术实现" class="headerlink" title="AOP技术实现"></a>AOP技术实现</h4><p>AOP 实现技术主要分为两大类：静态代理和动态代理。</p>
<ol>
<li><strong>静态代理</strong>：通过 AOP 框架提供的命令进行编译，从而在编译阶段生成 AOP 代理类。这种方式也被称为<strong>编译时增强</strong>。静态代理包括编译时编织和类加载时编织两种方式。</li>
<li>动态代理：在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为<strong>运行时增强。</strong>动态代理主要有两种实现方式： <ol>
<li><strong>JDK 动态代理</strong>：<strong>JDK 动态代理要求被代理的类必须实现一个接口，它通过反射来接收被代理的类</strong>，<strong>并使用 InvocationHandler 接口和 Proxy 类实现代理。</strong></li>
<li><strong>CGLIB 动态代理</strong>：<strong>CGLIB 则是一个代码生成的类库，它可以在运行时动态地生成某个类的子类，通过继承的方式实现代理。</strong>如果目标类没有实现接口，Spring AOP 会选择使用 CGLIB 来动态代理目标类。</li>
</ol>
</li>
</ol>
<h4 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h4><p><strong>Spring AOP（面向切面编程）的实现原理主要基于动态代理技术</strong>，它提供了对业务逻辑各个方面的关注点分离和模块化，使得非功能性需求（如日志记录、事务管理、安全检查等）可以集中管理和维护，而不是分散在各个业务模块中。</p>
<p>Spring AOP 实现原理的关键要点如下：</p>
<ol>
<li>代理机制： <ul>
<li><strong>JDK 动态代理</strong>：<strong>对于实现了接口的目标类，Spring AOP 默认使用 JDK 的 java.lang.reflect.Proxy 类来创建代理对象。</strong>代理对象会在运行时实现代理接口，并覆盖其中的方法，在方法调用前后执行切面逻辑（即通知，advice）。</li>
<li><strong>CGLIB 动态代理</strong>：<strong>对于未实现接口的类，Spring AOP 会选择使用 CGLIB 库来生成代理对象。</strong>CGLIB 通过字节码技术创建目标类的子类，在子类中重写目标方法并在方法调用前后插入切面逻辑。</li>
</ul>
</li>
<li>关键概念： <ul>
<li><strong>切面（Aspect）</strong>：切面是一个包含了横切关注点声明的模块化单元，它可以有多个切入点和通知组成。</li>
<li><strong>切入点（Pointcut）</strong>：切入点定义了匹配通知应该被织入的方法或方法执行点的规则表达式。</li>
<li><strong>通知（Advice）</strong>：通知是在特定切入点处执行的代码片段，分为多种类型，如前置通知（Before advice）、后置通知（After returning advice）、异常后通知（After throwing advice）、最终通知（After (finally) advice）以及环绕通知（Around advice）。</li>
</ul>
</li>
<li><strong>织入（Weaving）</strong>：织入是指将切面应用到目标对象来创建一个新的代理对象的过程。在 Spring AOP 中，织入发生在运行时，通过代理对象的方式实现。</li>
<li><strong>代理工厂</strong>：Spring 内部通过 ProxyFactory 或相关的 AOP 基础设施（如 Advisor、AdvisorChainFactory 等）来创建和管理代理对象。</li>
<li><strong>执行流程</strong>：当客户端通过代理对象调用目标方法时，代理对象会拦截这个调用，根据切面配置找到对应的通知，并按照通知类型的不同执行相应的增强逻辑。例如，如果是环绕通知，它会完全控制原始方法的调用过程，可以在调用前后插入自定义逻辑，甚至决定是否执行原方法。</li>
</ol>
<h4 id="AOP实现技术有哪些"><a href="#AOP实现技术有哪些" class="headerlink" title="AOP实现技术有哪些"></a>AOP实现技术有哪些</h4><p>AOP 常见实现技术有以下两种：</p>
<ol>
<li>静态代理：静态代理是一种在编译时就已经确定代理关系的代理方式。<strong>在静态代理中，代理类和被代理类都要实现同一个接口或继承同一个父类，代理类中包含了被代理类的实例，并在调用被代理类的方法前后执行相应的操作。</strong>静态代理的优点是实现简单，易于理解和掌握，但是它的缺点是需要为每个被代理类编写一个代理类，当被代理类的数量增多时，代码量会变得很大。</li>
<li>动态代理：动态代理是一种在运行时动态生成代理类的代理方式。<strong>在动态代理中，代理类不需要实现同一个接口或继承同一个父类，而是通过 Java 反射机制动态生成代理类，并在调用被代理类的方法前后执行相应的操作。</strong>动态代理的优点是可以为多个被代理类生成同一个代理类，从而减少了代码量，但是它的缺点是实现相对复杂，需要了解 Java 反射机制和动态生成字节码的技术。</li>
</ol>
<h4 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h4><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>JDK 动态代理是一种使用 Java 标准库中的 java.lang.reflect.Proxy 类来实现动态代理的技术。在 JDK 动态代理中，被代理类必须实现一个或多个接口，并通过 InvocationHandler 接口来实现代理类的具体逻辑。</p>
<p>具体来说，<strong>当使用 JDK 动态代理时，需要定义一个实现 InvocationHandler 接口的类，并在该类中实现代理类的具体逻辑。</strong>然后，通过 <strong>Proxy.newProxyInstance() 方法来创建代理类的实例</strong>。该方法接受三个参数：类加载器、代理类要实现的接口列表和 InvocationHandler 对象，如下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.example.demo.service.AliPayService;</span><br><span class="line"><span class="keyword">import</span> org.example.demo.service.PayService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理：使用JDK提供的api（InvocationHandler、Proxy实现），此种方式实现，要求被代理类必须实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceJDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//目标对象即就是被代理对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PayServiceJDKInvocationHandler</span><span class="params">( Object target)</span> {</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//proxy代理对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="comment">//1.安全检查</span></span><br><span class="line">        System.out.println(<span class="string">"安全检查"</span>);</span><br><span class="line">        <span class="comment">//2.记录日志</span></span><br><span class="line">        System.out.println(<span class="string">"记录日志"</span>);</span><br><span class="line">        <span class="comment">//3.时间统计开始</span></span><br><span class="line">        System.out.println(<span class="string">"记录开始时间"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用被代理类的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.时间统计结束</span></span><br><span class="line">        System.out.println(<span class="string">"记录结束时间"</span>);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        PayService target=  <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line">        <span class="comment">//方法调用处理器</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PayServiceJDKInvocationHandler</span>(target);</span><br><span class="line">        <span class="comment">//创建一个代理类：通过被代理类、被代理实现的接口、方法调用处理器来创建</span></span><br><span class="line">        <span class="type">PayService</span> <span class="variable">proxy</span> <span class="operator">=</span> (PayService) Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]{PayService.class},</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line">        proxy.pay();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>JDK 动态代理的优点是实现简单，易于理解和掌握，但是它的缺点是只能代理实现了接口的类，无法代理没有实现接口的类。</p>
<h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>CGLIB 动态代理是一种使用 CGLIB 库来实现动态代理的技术。在 CGLIB 动态代理中，代理类不需要实现接口，而是通过继承被代理类来实现代理。 具体来说，当使用 CGLIB 动态代理时，需要定义一个继承被代理类的子类，并在该子类中实现代理类的具体逻辑。然后，<strong>通过 Enhancer.create() 方法来创建代理类的实例</strong>。该方法接受一个类作为参数，表示要代理的类，如下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> org.example.demo.service.AliPayService;</span><br><span class="line"><span class="keyword">import</span> org.example.demo.service.PayService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceCGLIBInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PayServiceCGLIBInterceptor</span><span class="params">(Object target)</span>{</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="comment">//1.安全检查</span></span><br><span class="line">        System.out.println(<span class="string">"安全检查"</span>);</span><br><span class="line">        <span class="comment">//2.记录日志</span></span><br><span class="line">        System.out.println(<span class="string">"记录日志"</span>);</span><br><span class="line">        <span class="comment">//3.时间统计开始</span></span><br><span class="line">        System.out.println(<span class="string">"记录开始时间"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过cglib的代理方法调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> methodProxy.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.时间统计结束</span></span><br><span class="line">        System.out.println(<span class="string">"记录结束时间"</span>);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        PayService target=  <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line">        PayService proxy= (PayService) Enhancer.create(target.getClass(),<span class="keyword">new</span> <span class="title class_">PayServiceCGLIBInterceptor</span>(target));</span><br><span class="line">        proxy.pay();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="JDK动态代理和CGLIB动态代理有什么区别"><a href="#JDK动态代理和CGLIB动态代理有什么区别" class="headerlink" title="JDK动态代理和CGLIB动态代理有什么区别"></a>JDK动态代理和CGLIB动态代理有什么区别</h4><p>JDK 动态代理和 CGLIB 动态代理都是常见的动态代理实现技术，但它们有以下区别：</p>
<ul>
<li><strong>JDK 动态代理基于接口，要求目标对象实现接口</strong>；<strong>CGLIB 动态代理基于类，可以代理没有实现接口的目标对象。</strong></li>
<li>JDK 动态代理<strong>使用 java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler 来生成代理对象</strong>；CGLIB 动态代理<strong>使用 CGLIB 库来生成代理对象</strong>。</li>
<li>JDK 动态代理<strong>生成的代理对象是目标对象的接口实现</strong>；CGLIB 动态代理<strong>生成的代理对象是目标对象的子类</strong>。</li>
<li>JDK 动态代理性能相对较高，生成代理对象速度较快；CGLIB 动态代理性能相对较低，生成代理对象速度较慢。</li>
<li><strong>CGLIB 动态代理无法代理 final 类和 final 方法</strong>；<strong>JDK 动态代理可以代理任意类。</strong></li>
</ul>
<h3 id="3-Bean"><a href="#3-Bean" class="headerlink" title="3. Bean"></a>3. Bean</h3><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><ol>
<li><strong>sigleton：</strong>singleton 是 Spring 中默认的 Bean 作用域，<strong>它表示在整个应用程序中只存在一个 Bean 实例。</strong>每次请求该 Bean 时，都会返回同一个实例。</li>
</ol>
<p><strong>prototype：</strong> prototype 表示每次请求该 Bean 时都会创建一个新的实例。每个实例都有自己的属性值和状态，因此它们之间是相互独立的。</p>
<ol start="2">
<li><p><strong>request：</strong> request <strong>表示在一次 HTTP 请求中只存在一个 Bean 实例</strong>。在同一个请求中，多次请求该 Bean 时都会返回同一个实例。不同的请求之间，该 Bean 的实例是相互独立的</p>
</li>
<li><p><strong>session：</strong> session <strong>表示在一个 HTTP Session 中只存在一个 Bean 实例</strong>。在同一个 Session 中，多次请求该 Bean 时都会返回同一个实例。不同的 Session 之间，该 Bean 的实例是相互独立的。</p>
</li>
<li><p><strong>application：</strong> application <strong>表示在一个 ServletContext 中只存在一个 Bean 实例。</strong>该作用域只在 Spring ApplicationContext 上下文中有效。</p>
</li>
<li><p><strong>websocket：</strong> websocket <strong>表示在一个 WebSocket 中只存在一个 Bean 实例</strong>。该作用域只在 Spring ApplicationContext 上下文中有效。</p>
</li>
</ol>
<h4 id="单例Bean线程安全吗？"><a href="#单例Bean线程安全吗？" class="headerlink" title="单例Bean线程安全吗？"></a>单例Bean线程安全吗？</h4><p><strong>无状态的单例 Bean 是线程安全的，而有状态的单例 Bean 是非线程安全的</strong>，所以总的来说单例 Bean 还是非线程安全的。 有状态Bean-可变成员变量</p>
<p><strong>有状态的 Bean 是指 Bean 中包含了状态，比如成员变量</strong>，而无状态的 Bean 是指 Bean 中不包含状态，比如没有成员变量，或者成员变量都是 final 的。</p>
<p><strong>如何保证线程安全</strong></p>
<ul>
<li>变为原型 Bean：在 Bean 上添加 @Scope(“prototype”) 注解，将其变为多例 Bean。这样每次注入时返回一个新的实例，避免竞争。</li>
<li>加锁：在 Bean 中对需要同步的方法或代码块添加同步锁 @Synchronized 或使用 Java 中的线程同步工具 ReentrantLock 等。</li>
<li>使用线程安全的集合：如 Vector、Hashtable 代替 ArrayList、HashMap 等非线程安全集合。</li>
<li>变为无状态 Bean：不在 Bean 中保存状态，让 Bean 成为无状态 Bean。无状态的 Bean 没有共享变量，自然也无须考虑线程安全问题。</li>
<li>使用线程局部变量 ThreadLocal：在方法内部使用线程局部变量 ThreadLocal，因为 ThreadLocal 是线程独享的，所以也不存在线程安全问题。</li>
</ul>
<h4 id="Bean有哪几种注入方式"><a href="#Bean有哪几种注入方式" class="headerlink" title="Bean有哪几种注入方式"></a>Bean有哪几种注入方式</h4><h5 id="属性注入（Field-Injection）"><a href="#属性注入（Field-Injection）" class="headerlink" title="属性注入（Field Injection）"></a>属性注入（Field Injection）</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line">    <span class="comment">// 属性对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/add")</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">add</span><span class="params">(String username, String password)</span> {</span><br><span class="line">        <span class="keyword">return</span> userService.add(username, password);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>优点：<strong>属性注入最大的优点就是实现简单、使用简单</strong>，只需要给变量上添加一个注解（@Autowired），就可以在不 new 对象的情况下，直接获得注入的对象了（这就是 DI 的功能和魅力所在），所以它的优点就是使用简单。</p>
<p>缺点：</p>
<ol>
<li>功能性问题：无法注入一个不可变的对象（final 修饰的对象）；</li>
</ol>
<p><strong>在 Java 中 final 对象（不可变）要么直接赋值，要么在构造方法中赋值，所以当使用属性注入 final 对象时，它不符合 Java 中 final 的使用规范，所以就不能注入成功了。</strong></p>
<ol start="2">
<li><p>通用性问题：只能适应于 IoC 容器；</p>
</li>
<li><p>设计原则问题：更容易违背单一设计原则。</p>
</li>
</ol>
<h5 id="Setter注入（Setter-Injection）"><a href="#Setter注入（Setter-Injection）" class="headerlink" title="Setter注入（Setter Injection）"></a>Setter注入（Setter Injection）</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line">    <span class="comment">// Setter 注入</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> {</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/add")</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">add</span><span class="params">(String username, String password)</span> {</span><br><span class="line">        <span class="keyword">return</span> userService.add(username, password);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>优点：<strong>完全符合单一职责的设计原则，因为每一个 Setter 只针对一个对象</strong>。</p>
<p>缺点：不可注入不可变的对象（final修饰的对象）；注入的对象可被修改。</p>
<p><strong>构造方法注入（Constructor Injection）</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line">    <span class="comment">// 构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>      <span class="comment">//只有一个构造方法时，@Autowired可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> {</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/add")</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">add</span><span class="params">(String username, String password)</span> {</span><br><span class="line">        <span class="keyword">return</span> userService.add(username, password);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>【总结】依赖注入的常见实现方式有 3 种：属性注入、Setter 注入和构造方法注入。其中属性注入的写法最简单，所以日常项目中使用的频率最高，但它的通用性不好；而 Spring 官方推荐的是构造方法注入，它可以注入不可变对象，其通用性也更好，如果是注入可变对象，那么可以考虑使用 Setter 注入</p>
<h4 id="AutoWired底层时如何实现的"><a href="#AutoWired底层时如何实现的" class="headerlink" title="@AutoWired底层时如何实现的"></a>@AutoWired底层时如何实现的</h4><p>@Autowired 是 Spring 框架中常用的注解之一，它可以自动装配 Bean，使得开发人员可以更加方便地使用 Spring 框架。</p>
<p><strong>Spring 中的 @Autowired 注解是通过依赖注入（DI）实现的</strong>，依赖注入是一种设计模式，它将对象的创建和依赖关系的管理从应用程序代码中分离出来，使得应用程序更加灵活和可维护。</p>
<p>具体来说，当 Spring 容器启动时，它会扫描应用程序中的所有 Bean，并将它们存储在一个 BeanFactory 中。当应用程序需要使用某个 Bean 时，Spring 容器会自动将该 Bean 注入到应用程序中。<strong>DI 是通过 Java 反射机制实现的</strong>。具体来说，当 Spring 容器需要注入某个 Bean 时，它会使用 Java 反射机制来查找符合条件的 Bean，并将其注入到应用程序中。</p>
<p><strong>@Autowired 注解是通过 DI 的方式，底层通过 Java 的反射机制来实现的。</strong></p>
<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>在 Spring 中，Bean 的生命周期指的是 Bean 实例从创建到销毁的整个过程。Spring 容器负责管理 Bean 的生命周期，<strong>包括实例化、属性赋值、初始化、销毁</strong>等过程。</p>
<p><strong>实例化</strong>：在 Spring 容器启动时，会根据配置文件或注解等方式创建 Bean 的实例，<strong>也就是说实例化就是为 Bean 对象分配内存空间</strong>。根据 Bean 的作用域不同，实例化的方式也不同。例如，singleton 类型的 Bean 在容器启动时就会被实例化，而 prototype 类型的 Bean 则是在每次请求时才会被实例化。</p>
<p><strong>属性赋值：</strong>在 Bean 实例化后，Spring 容器会自动将配置文件或注解中指定的属性值注入到 Bean 中。属性注入可以通过构造函数注入、Setter 方法注入、注解注入等方式实现。</p>
<p><strong>初始化：</strong> 在属性注入完成后，Spring 容器会调用 Bean 的初始化方法。Bean 的初始化方法可以通过实现 InitializingBean 接口、@PostConstruct 注解等方式实现。在初始化方法中，可以进行一些初始化操作，例如建立数据库连接、加载配置文件等。</p>
<p><strong>使用：</strong>在 Bean 初始化完成后，Bean 就可以被应用程序使用了。在应用程序中，可以通过 Spring 容器获取 Bean 的实例，并调用 Bean 的方法。</p>
<p><strong>销毁：</strong>在应用程序关闭时，Spring 容器会自动销毁所有的 Bean 实例。Bean 的销毁方法可以通过实现 DisposableBean 接口、@PreDestroy 注解等方式实现。在销毁方法中，可以进行一些清理操作，例如释放资源、关闭数据库连接等。</p>
<h4 id="FactoryBean和BeanFactory的区别"><a href="#FactoryBean和BeanFactory的区别" class="headerlink" title="FactoryBean和BeanFactory的区别"></a>FactoryBean和BeanFactory的区别</h4><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>BeanFactory 是 Spring 框架的基本容器，负责管理和创建应用程序中的对象。它是一个工厂模式的实现，可以根据配置信息创建和管理各种类型的 Java 对象。<strong>BeanFactory 的主要职责是实例化 Bean、处理 Bean 之间的依赖关系、注入属性以及在需要时销毁 Bean。</strong></p>
<p><strong>BeanFactory 使用延迟初始化策略，即只有在请求获取 Bean 实例时才会进行实例化。</strong>这种方式可以减少资源消耗，特别是在应用程序启动时有大量的Bean需要创建时。BeanFactory 使用配置文件（如 XML）或注解来定义 Bean 和它们之间的关系。</p>
<h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h5><p><strong>FactoryBean 是一个特殊的 Bean，它实现了 Spring 的 FactoryBean 接口。</strong>与普通的 Bean 不同，<strong>FactoryBean 负责创建其他 Bean 实例。</strong>它是一种更加灵活和可扩展的机制，可以通过编程的方式动态地创建和配置Bean。</p>
<h3 id="4-Autowired和Resource区别"><a href="#4-Autowired和Resource区别" class="headerlink" title="4. @Autowired和Resource区别"></a>4. @Autowired和Resource区别</h3><p>@Autowired 和 @Resource 都是用来实现依赖注入的注解（在 Spring/Spring Boot 项目中），但二者却有着 5 点不同：</p>
<ol>
<li>来源不同：@Autowired 来自 Spring 框架，而 @Resource 来自于（Java）JSR-250；</li>
<li>依赖查找的顺序不同：@Autowired 先根据类型再根据名称查询，而 @Resource 先根据名称再根据类型查询；</li>
<li>支持的参数不同：@Autowired 只支持设置 1 个参数(required)，而 @Resource 支持设置 7 个参数(name, lookup, type, authenticationType, shareable, mapperedName, description)；</li>
<li>依赖注入的用法支持不同：@Autowired 既支持构造方法注入，又支持属性注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入；</li>
<li>编译器 IDEA 的提示不同：当注入 Mapper 对象时，使用 @Autowired 注解编译器会提示错误，而使用 @Resource 注解则不会提示错误。</li>
</ol>
<h3 id="5-Spring中使用了哪些设计模式"><a href="#5-Spring中使用了哪些设计模式" class="headerlink" title="5. Spring中使用了哪些设计模式"></a>5. Spring中使用了哪些设计模式</h3><p><strong>单例模式：</strong> <strong>单例模式是一种创建型设计模式</strong>，它保证一个类只有一个实例，并提供了一个全局访问点。在 Spring 中，Bean 默认是单例的，这意味着每个 Bean 只会被创建一次，并且可以在整个应用程序中共享。</p>
<p><strong>工厂模式：</strong> <strong>工厂模式是一种创建型设计模式</strong>，它提供了一种创建对象的方式，使得应用程序可以更加灵活和可维护。在 Spring 中，FactoryBean 就是一个工厂模式的实现，使用它的工厂模式就可以创建出来其他的 Bean 对象。</p>
<p><strong>代理模式：</strong> <strong>代理模式是一种结构型设计模式</strong>，它允许开发人员在不修改原有代码的情况下，向应用程序中添加新的功能。在 Spring AOP（面向切面编程）就是使用代理模式的实现，它允许开发人员在方法调用前后执行一些自定义的操作，比如日志记录、性能监控等。</p>
<p><strong>观察者模式：</strong> <strong>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</strong>Spring 事件驱动模型使用观察者模式，ApplicationEventPublisher 事件发布者将事件发布给 ApplicationEventMulticaster 事件广播器，该广播器将事件派发给 @EventListener 注解的事件监听者。</p>
<p><strong>适配器模式：</strong> <strong>适配器模式是一种结构型设计模式</strong>，它允许开发人员将一个类的接口转换成另一个类的接口，以满足客户端的需求。在 Spring 中，适配器模式常用于将不同类型的对象转换成统一的接口，比如将 Servlet API 转换成 Spring MVC 的控制器接口。</p>
<h3 id="6-SpringBoot优点"><a href="#6-SpringBoot优点" class="headerlink" title="6. SpringBoot优点"></a>6. SpringBoot优点</h3><p><strong>简化配置：</strong> <strong>Spring Boot 采用约定大于配置的原则，提供了自动配置的特性</strong>，大部分情况下无需手动配置，可以快速启动和运行应用程序。同时，Spring Boot 提供了统一的配置模型，集成了大量常用的第三方库和框架，简化了配置过程</p>
<p><strong>内嵌服务器：</strong> Spring Boot 集成了常用的内嵌式服务器，如 Tomcat、Jetty 和 Undertow 等。这意味着不再需要单独安装和配置外部服务器，可以直接运行 Spring Boot 应用程序，简化了部署和发布过程。</p>
<p><strong>自动装配：</strong>Spring Boot 提供了自动装配机制，<strong>根据应用程序的依赖关系和配置信息，智能地自动配置 Spring 的各种组件和功能</strong>，大大减少了开发人员的手动配置工作，提高了开发效率。</p>
<p><strong>起步依赖：</strong> Spring Boot 引入了起步依赖（Starter Dependencies）的概念，它是一种可用于快速集成相关技术栈的依赖项集合。<strong>起步依赖能够自动处理依赖冲突和版本兼容性，并提供了默认的配置和依赖管理，简化了构建和管理项目的过程。</strong></p>
<p><strong>自动化监控和管理：</strong> <strong>Spring Boot 集成了 Actuator 模块，提供了对应用程序的自动化监控、管理和运维支持。</strong>通过 Actuator，可以获取应用程序的健康状况、性能指标、配置信息等，方便运维人员进行故障排查和性能优化。</p>
<p><strong>丰富的生态系统：</strong> Spring Boot 建立在 Spring Framework 的基础上，可以无缝集成 Spring 的各种功能和扩展，如 Spring Data、Spring Security、Spring Integration 等。同时，Spring Boot 还提供了大量的第三方库和插件，可以方便地集成其他技术栈，构建全栈式应用程序。</p>
<p><strong>可扩展性和灵活性：</strong> 尽管 Spring Boot 提供了很多自动化的功能和约定，但它也保持了良好的可扩展性和灵活性。开发人员可以根据自己的需求进行自定义配置和扩展，以满足特定的业务需求。</p>
<p>Spring Boot 是<strong>一个强大而又灵活的开发框架，具有简化配置、快速开发、自动化监控、微服务支持等诸多优点</strong>。它<strong>极大地提高了开发效率、降低了开发成本</strong>，并且在行业中得到了广泛的认可和应用。</p>
<h3 id="7-SpringBoot自动装配"><a href="#7-SpringBoot自动装配" class="headerlink" title="7. SpringBoot自动装配"></a>7. SpringBoot自动装配</h3><p>Spring Boot 的自动装配（Auto-configuration）是 Spring Boot 框架的核心特性之一。通过自动装配可以自动配置和加载 Spring Boot 所需的各种组件和功能，从而大大的减少开发人员手动配置的工作。</p>
<h4 id="①-自动装配工作原理"><a href="#①-自动装配工作原理" class="headerlink" title="①. 自动装配工作原理"></a>①. 自动装配工作原理</h4><p>Spring Boot 在启动时，会检索所有的 Spring 模块，找到符合条件的配置并应用到应用上下文中。这个过程发生在 SpringApplication 这个类中。</p>
<p>Spring Boot 自动装配主要依靠两部分：</p>
<ol>
<li><strong>SpringFactoriesLoader 驱动：</strong>在启动过程中<strong>会加载 META-INF/spring.factories 配置文件</strong>，获取自动装配相关的配置类信息。</li>
<li><strong>条件装配：</strong>Spring Boot 不会永远都自动装配，<strong>它会根据类路径下是否存在某个名称符合命名规则的自动装配类来决定是否进行自动装配。</strong>这就是条件装配，通过 <strong>@Conditional 条件注解完成</strong>。</li>
</ol>
<h4 id="②-自动装配流程"><a href="#②-自动装配流程" class="headerlink" title="②. 自动装配流程"></a>②. 自动装配流程</h4><p>Spring Boot 自动装配执行流程如下：</p>
<ol>
<li>Spring Boot 启动时会<strong>创建一个 SpringApplication 实例，该实例存储了应用相关信息</strong>，它负责启动并运行应用。</li>
<li><strong>实例化 SpringApplication 时，会自动装载 META-INF/spring.factories 中配置的自动装配类。</strong></li>
<li>SpringApplication 实例<strong>调用 run() 方法</strong>启动应用。</li>
<li>在 run() 方法中，<strong>实例会创建默认的应用上下文 Environment 以及 ApplicationContext。</strong></li>
<li>SpringApplication 会<strong>通过 ListableBeanFactory 加载应用上下文 ApplicationContext 中的所有 BeanDefinition</strong>。</li>
<li>在 BeanDefinition 加载过程中，<strong>SpringApplication 会检测是否存在基于 @Conditional 条件装配注解的自动装配类</strong>。</li>
<li>如果存在且 @Conditional 条件校验成功，则会装配这些自动装配类。</li>
<li>这些自动装配类通过 @EnableAutoConfiguration、@Configuration 等注解，装配默认的 Spring Bean。</li>
<li>装配完成后，Spring Boot 将启动应用，这里会启动嵌入的 Web 服务器，如 Tomcat 并发布 Web 应用。</li>
<li>发布完成，Spring Boot 应用启动成功。</li>
</ol>
<h3 id="8-SpringBoot中如何实现缓存预热"><a href="#8-SpringBoot中如何实现缓存预热" class="headerlink" title="8. SpringBoot中如何实现缓存预热"></a>8. SpringBoot中如何实现缓存预热</h3><p>缓存预热是指在 Spring Boot 项目启动时，预先将数据加载到缓存系统（如 Redis）中的一种机制。</p>
<p>在 Spring Boot 启动之后，可以通过以下手段实现缓存预热：</p>
<ol>
<li><strong>使用启动监听事件实现缓存预热。</strong></li>
<li>使用 <strong>@PostConstruct 注解</strong>实现缓存预热。</li>
<li>使用 <strong>CommandLineRunner 或 ApplicationRunner</strong> 实现缓存预热。</li>
<li>通过<strong>实现 InitializingBean 接口，并重写 afterPropertiesSet 方法</strong>实现缓存预热。</li>
</ol>
<h4 id="①-启动监听事件"><a href="#①-启动监听事件" class="headerlink" title="①. 启动监听事件"></a>①. 启动监听事件</h4><p>可以<strong>使用 ApplicationListener 监听 ContextRefreshedEvent 或 ApplicationReadyEvent 等应用上下文初始化完成事件</strong>，在这些事件触发后执行数据加载到缓存的操作，具体实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheWarmer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> {</span><br><span class="line">        <span class="comment">// 执行缓存预热业务...</span></span><br><span class="line">        cacheManager.put(<span class="string">"key"</span>, dataList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>或监听 ApplicationReadyEvent 事件:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheWarmer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> {</span><br><span class="line">        <span class="comment">// 执行缓存预热业务...</span></span><br><span class="line">        cacheManager.put(<span class="string">"key"</span>, dataList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="②-PostConstruct"><a href="#②-PostConstruct" class="headerlink" title="② @PostConstruct"></a>② @PostConstruct</h4><p>在需要进行缓存预热的类上添加 @Component 注解，并在其方法中添加 @PostConstruct 注解和缓存预热的业务逻辑，具体实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachePreloader</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YourCacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preloadCache</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 执行缓存预热业务...</span></span><br><span class="line">        cacheManager.put(<span class="string">"key"</span>, dataList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="③-CommandLineRunner或ApplicationRunner"><a href="#③-CommandLineRunner或ApplicationRunner" class="headerlink" title="③. CommandLineRunner或ApplicationRunner"></a>③. CommandLineRunner或ApplicationRunner</h4><p>CommandLineRunner 和 ApplicationRunner 都是 Spring Boot 应用程序启动后要执行的接口，它们都允许我们在应用启动后执行一些自定义的初始化逻辑，例如缓存预热。 CommandLineRunner 实现示例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 执行缓存预热业务...</span></span><br><span class="line">        cacheManager.put(<span class="string">"key"</span>, dataList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ApplicationRunner 实现示例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 执行缓存预热业务...</span></span><br><span class="line">        cacheManager.put(<span class="string">"key"</span>, dataList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>CommandLineRunner 和 ApplicationRunner 区别如下：</p>
<ol>
<li>方法签名不同： <ul>
<li>CommandLineRunner 接口有一个 run(String… args) 方法，它接收命令行参数作为可变长度字符串数组。</li>
<li>ApplicationRunner 接口则提供了一个 run(ApplicationArguments args) 方法，它接收一个 ApplicationArguments 对象作为参数，这个对象提供了对传入的所有命令行参数（包括选项和非选项参数）的访问。</li>
</ul>
</li>
<li>参数解析方式不同： <ul>
<li>CommandLineRunner 接口更简单直接，适合处理简单的命令行参数。</li>
<li>ApplicationRunner 接口提供了一种更强大的参数解析能力，可以通过 ApplicationArguments 获取详细的参数信息，比如获取选项参数及其值、非选项参数列表以及查询是否存在特定参数等。</li>
</ul>
</li>
<li>使用场景不同： <ul>
<li>当只需要处理一组简单的命令行参数时，可以使用 CommandLineRunner。</li>
<li>对于需要精细控制和解析命令行参数的复杂场景，推荐使用 ApplicationRunner。</li>
</ul>
</li>
</ol>
<h4 id="④-实现InitializingBean接口"><a href="#④-实现InitializingBean接口" class="headerlink" title="④. 实现InitializingBean接口"></a>④. 实现InitializingBean接口</h4><p>实现 InitializingBean 接口并重写 afterPropertiesSet 方法，可以在 Spring Bean 初始化完成后执行缓存预热，具体实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachePreloader</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YourCacheManager cacheManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 执行缓存预热业务...</span></span><br><span class="line">        cacheManager.put(<span class="string">"key"</span>, dataList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-有几种获取Request对象的方法"><a href="#9-有几种获取Request对象的方法" class="headerlink" title="9. 有几种获取Request对象的方法"></a>9. 有几种获取Request对象的方法</h3><p>HttpServletRequest 简称 Request，它是一个 Servlet API 提供的对象，用于获取客户端发起的 HTTP 请求信息。例如：获取请求参数、获取请求头、获取 Session 会话信息、获取请求的 IP 地址等信息。</p>
<p>在SpringBoot中，常见的获取Request对象的方法有以下三种：</p>
<ol>
<li>通过请求参数中获取 Request 对象；</li>
<li>通过 RequestContextHolder 获取 Request 对象；</li>
<li>通过自动注入获取 Request 对象。</li>
</ol>
<h4 id="①-通过请求参数获取"><a href="#①-通过请求参数获取" class="headerlink" title="①. 通过请求参数获取"></a>①. 通过请求参数获取</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/index")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">(HttpServletRequest request)</span>{</span><br><span class="line">　　<span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该方法实现的原理是 Controller 开始处理请求时，Spring 会将 Request 对象赋值到方法参数中，我们直接设置到参数中即可得到 Request 对象。</p>
<h4 id="②-通过RequestContextHolder获取"><a href="#②-通过RequestContextHolder获取" class="headerlink" title="②. 通过RequestContextHolder获取"></a>②. 通过RequestContextHolder获取</h4><p>在 Spring Boot 中，RequestContextHolder 是 Spring 框架提供的一个工具类，用于在多线程环境中存储和访问与当前线程相关的请求上下文信息。它主要用于将当前请求的信息存储在线程范围内，以便在不同的组件中共享和访问这些信息，特别是在没有直接传递参数的情况下。 RequestContextHolder 的主要作用有以下几个：</p>
<ol>
<li><strong>访问请求上下文信息</strong>： 在 Web 应用中，每个请求都会触发一个新的线程来处理。RequestContextHolder 允许你在任何地方获取当前请求的上下文信息，比如 HttpServletRequest 对象、会话信息等。</li>
<li><strong>跨层传递信息</strong>： 在多层架构中，比如控制器、服务层、数据访问层，你可能需要在这些层之间传递一些与请求相关的信息，但不想在每个方法中显式传递。通过 RequestContextHolder，你可以在一处设置请求信息，在其他地方获取并使用。</li>
<li><strong>线程安全的上下文共享</strong>： RequestContextHolder 使用线程局部变量来存储请求上下文信息，确保在多线程环境下每个线程访问的上下文信息都是独立的，避免了线程安全问题。</li>
</ol>
<p>因此我们可以使用 RequestContextHolde 获取 Request 对象，实现代码如下:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/index")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">ServletRequestAttributes</span> <span class="variable">servletRequestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">	<span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> servletRequestAttributes.getRequest();</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="③-通过自动注入获取"><a href="#③-通过自动注入获取" class="headerlink" title="③. 通过自动注入获取"></a>③. 通过自动注入获取</h4><p>HttpServletRequest 对象也可以通过自动注入，如属性注入的方式获取，如下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request; <span class="comment">// 自动注入 request 对象</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-拦截器和过滤器"><a href="#10-拦截器和过滤器" class="headerlink" title="10. 拦截器和过滤器"></a>10. 拦截器和过滤器</h3><h4 id="如何实现拦截器"><a href="#如何实现拦截器" class="headerlink" title="如何实现拦截器"></a>如何实现拦截器</h4><p>在 Spring Boot 中拦截器的实现分为两步：</p>
<ol>
<li><strong>创建一个普通的拦截器，实现 HandlerInterceptor 接口，并重写接口中的相关方法</strong>；</li>
<li>将上一步创建的<strong>拦截器加入到 Spring Boot 的配置文件中，并配置拦截规则</strong>。</li>
</ol>
<p><strong>一、实现自定义拦截器</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        System.out.println(<span class="string">"拦截器：执行 preHandle 方法。"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        System.out.println(<span class="string">"拦截器：执行 postHandle 方法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        System.out.println(<span class="string">"拦截器：执行 afterCompletion 方法。"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>boolean preHandle</strong>(HttpServletRequest request, HttpServletResponse response, Object handle)：在请求方法执行前被调用，也就是调用目标方法之前被调用。比如我们在操作数据之前先要验证用户的登录信息，就可以在此方法中实现，如果验证成功则返回 true，继续执行数据操作业务；否则就返回 false，后续操作数据的业务就不会被执行了。</p>
<p><strong>void postHandle</strong>(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)：<strong>调用请求方法之后执行，但它会在 DispatcherServlet 进行渲染视图之前被执行。</strong></p>
<p><strong>void afterCompletion</strong>(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)：会在整个请求结束之后再执行，也就是在 DispatcherServlet 渲染了对应的视图之后再执行。</p>
<p><strong>二、配置拦截规则</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入拦截器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestInterceptor testInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> {</span><br><span class="line">        registry.addInterceptor(testInterceptor) <span class="comment">// 添加拦截器</span></span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>); <span class="comment">// 拦截所有地址</span></span><br><span class="line">        		.excludePathPatterns(<span class="string">"/login"</span>); <span class="comment">// 放行接口</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="如何实现过滤器"><a href="#如何实现过滤器" class="headerlink" title="如何实现过滤器"></a>如何实现过滤器</h4><p>过滤器可以使用 Servlet 3.0 提供的 <strong>@WebFilter 注解，配置过滤的 URL 规则</strong>，然后再实现 Filter 接口，重写接口中的 doFilter 方法，具体实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = "/*")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException {</span><br><span class="line">        System.out.println(<span class="string">"过滤器：执行 init 方法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">                         ServletResponse servletResponse,</span></span><br><span class="line"><span class="params">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        System.out.println(<span class="string">"过滤器：开始执行 doFilter 方法。"</span>);</span><br><span class="line">        <span class="comment">// 请求放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        System.out.println(<span class="string">"过滤器：结束执行 doFilter 方法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"过滤器：执行 destroy 方法。"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>void init(FilterConfig filterConfig)：容器启动（初始化 Filter）时会被调用，整个程序运行期只会被调用一次。用于实现 Filter 对象的初始化。</p>
<p>void doFilter(ServletRequest request, ServletResponse response,FilterChain chain)：具体的过滤功能实现代码，通过此方法对请求进行过滤处理，<strong>其中 FilterChain 参数是用来调用下一个过滤器或执行下一个流程</strong>。</p>
<p>void destroy()：用于 Filter 销毁前完成相关资源的回收工作。</p>
<h4 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h4><p>拦截器和过滤器的区别主要体现在以下 5 点：</p>
<ol>
<li><strong>出身不同：</strong> 过滤器来自Servlet, 而拦截器来自Spring框架</li>
<li><strong>触发机制不同：</strong> 求的执行顺序是：<strong>请求进入容器 &gt; 进入过滤器 &gt; 进入 Servlet &gt; 进入拦截器 &gt; 执行控制器（Controller）</strong>，所以过滤器和拦截器的执行时机，是过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法；</li>
<li><strong>底层实现不同：</strong> 过滤器是基于方法回调实现的，拦截器是基于动态代理（底层是反射）实现的；</li>
<li><strong>支持项目于类型不同：</strong> <strong>过滤器是 Servlet 规范中定义的</strong>，所以过滤器要依赖 Servlet 容器，<strong>它只能用在 Web 项目中</strong>；而拦截器是 Spring 中的一个组件，因此拦截器既可以用在 Web 项目中，同时还可以用在 Application 或 Swing 程序中；</li>
<li><strong>使用场景不同：</strong> 因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：登录判断、权限判断、日志记录等业务；而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能。</li>
</ol>
<h4 id="拦截器和动态代理的区别"><a href="#拦截器和动态代理的区别" class="headerlink" title="拦截器和动态代理的区别"></a>拦截器和动态代理的区别</h4><p><strong>拦截器（Interceptor）准确来说在 Spring MVC 中的一个很重要的组件，用于拦截 Controller 的请求。</strong> 它的主要作用有以下几个：</p>
<ol>
<li><strong>权限验证</strong>：验证用户是否登录、是否有权限访问某个接口。</li>
<li><strong>日志记录</strong>：记录请求信息的日志，如请求参数，响应信息等。</li>
<li><strong>性能监控</strong>：监控系统的运行性能，如慢查询接口等。</li>
<li><strong>通用行为</strong>：插入一些通用的行为，比如开发环境忽略某些请求。</li>
</ol>
<p><strong>拦截器实现原理</strong></p>
<p>Spring Boot 拦截器是基于 Java 的 Servlet 规范实现的，<strong>通过实现 HandlerInterceptor 接口来实现拦截器功能</strong>。</p>
<p>在 Spring Boot 框架的执行流程中，<strong>拦截器被注册在 DispatcherServlet 的 doDispatch() 方法中</strong>，该方法是 Spring Boot 框架的核心方法，用于处理请求和响应。</p>
<p>程序每次执行时都会调用 doDispatch() 方法时，并验证拦截器（链），之后再根据拦截器返回的结果，进行下一步的处理。如果返回的是 true，那么继续调用目标方法，反之则会直接返回验证失败给前端。</p>
<p>在开始执行 Controller 之前，会先调用 <strong>预处理方法 applyPreHandle</strong>（在doDispatch()方法中），然后再applyPreHandle 中会获取所有的拦截器HandlerInterceptor 并执行拦截器中的 preHandle 方法</p>
<p><strong>动态代理是一种设计模式，它是指在运行时提供代理对象，来扩展目标对象的功能。</strong> 在 Spring 中的，动态代理的实现手段有以下两种:</p>
<ol>
<li><strong>JDK 动态代理</strong>：通过反射机制生成代理对象，目标对象必须实现接口。</li>
<li><strong>CGLIB 动态代理</strong>：通过生成目标类的子类来实现代理，不要求目标对象实现接口。</li>
</ol>
<p>动态代理的主要作用包括：</p>
<ol>
<li><strong>扩展目标对象的功能</strong>：如添加日志、验证参数等。</li>
<li><strong>控制目标对象的访问</strong>：如进行权限控制。</li>
<li><strong>延迟加载目标对象</strong>：在需要时才实例化目标对象。</li>
<li><strong>远程代理</strong>：将请求转发到远程的目标对象上。</li>
</ol>
<p>【区别】</p>
<ul>
<li><strong>使用范围不同</strong>：拦截器通常用于 Spring MVC 中，主要用于拦截 Controller 请求。动态代理可以使用在 Bean 中，主要用于提供 bean 的代理对象，实现对 bean 方法的拦截。0</li>
<li><strong>实现原理不同</strong>：拦截器是通过 HandlerInterceptor 接口来实现的，主要是通过 afterCompletion、postHandle、preHandle 这三个方法在请求前后进行拦截处理。动态代理主要有 JDK 动态代理和 CGLIB 动态代理，JDK 通过反射生成代理类；CGLIB 通过生成被代理类的子类来实现代理。</li>
<li><strong>加入时机不同</strong>：拦截器是在运行阶段动态加入的；动态代理是在编译期或运行期生成的代理类。</li>
<li><strong>使用难易程度不同</strong>：拦截器相对简单，通过实现接口即可使用。动态代理稍微复杂，需要了解动态代理的实现原理，然后通过相应的 api 实现。</li>
</ul>
<h4 id="拦截器和过滤器的执行顺序"><a href="#拦截器和过滤器的执行顺序" class="headerlink" title="拦截器和过滤器的执行顺序"></a>拦截器和过滤器的执行顺序</h4><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240812203123726" style="zoom:50%;">



<p><strong>执行顺序</strong>：<code>china.doFilter()——&gt;Interceptor的preHandle——&gt;Controller——&gt;Interceptor的postHandle——&gt;页面显示——&gt;Interceptor的afterCompletion——&gt;china.doFileter()</code></p>
<h3 id="11-Spring事务"><a href="#11-Spring事务" class="headerlink" title="11. Spring事务"></a>11. Spring事务</h3><p> Spring 中，事务的实现方式分为两种：编程式事务和声明式事务，又因为编程式事务实现相对麻烦，而声明式事务实现极其简单，所以在日常项目中，我们都会使用声明式事务 @Transactional 来实现事务。</p>
<h4 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h4><p>@Transactional 使用极其简单，只需要在类上或方法上添加 @Transactional 关键字，就可以实现事务的自动开启、提交或回滚了，它的基础用法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span> </span><br><span class="line"><span class="meta">@RequestMapping("/add")</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(UserInfo userInfo)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userService.add(userInfo);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>@Transactional 会在方法执行前，会自动开启事务；在方法成功执行完，会自动提交事务；如果方法在执行期间，出现了异常，那么它会自动回滚事务。</strong></p>
<h4 id="Transactional-失效的场景"><a href="#Transactional-失效的场景" class="headerlink" title="@Transactional 失效的场景"></a>@Transactional 失效的场景</h4><ul>
<li>非public修饰的方法</li>
<li>timeout超时</li>
<li>代码中有try/catch: 在前面 @Transactional 的执行流程中，我们提到：当方法中出现了异常之后，事务会自动回滚。然而，如果在程序中加了 try/catch 之后，@Transactional 就不会自动回滚事务了</li>
<li>调用类内部@Transactional方法</li>
<li>数据库不支持事务</li>
</ul>
<h4 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h4><p>Spring 提供了七种事务传播行为，可分为以下两类：</p>
<ol>
<li>支持当前事务： <ol>
<li><strong>REQUIRED</strong> 是最常用的传播行为，它表示当前方法必须在一个事务内执行，如果当前没有事务，则创建一个新的事务。</li>
<li><strong>SUPPORTS</strong> 表示当前方法支持事务，但不强制要求，如果当前没有事务，则以非事务方式执行。</li>
<li><strong>MANDATORY</strong> 表示当前方法必须在一个事务内执行，如果当前没有事务，则抛出异常。</li>
<li><strong>NESTED</strong> 表示当前方法必须在一个<strong>嵌套事务</strong>内执行，如果当前没有事务，则创建一个新的事务。</li>
</ol>
</li>
<li>不支持当前事务： <ol>
<li>REQUIRESNEW 表示当前方法必须创建一个新的事务，如果当前存在事务，则挂起该事务。</li>
<li>NOTSUPPORTED 表示当前方法以非事务方式执行，如果当前存在事务，则挂起该事务。NEVER 表示当前方法以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ol>
</li>
</ol>
<p><strong>加入事务和嵌套事务有什么区别</strong></p>
<p><strong>Propagation.REQUIRED：表示如果当前存在事务，则在当前事务中执行；如果当前没有事务，则创建一个新的事务并在其中执行。</strong>即，方法被调用时会尝试加入当前的事务，如果不存在事务，则创建一个新的事务。如果外部事务回滚，那么内部事务也会被回滚。</p>
<p><strong>Propagation.NESTED：表示如果当前存在事务，则在嵌套事务中执行；如果当前没有事务，则创建一个新的事务并在其中执行。</strong>嵌套事务是独立于外部事务的子事务，<strong>它具有自己的保存点</strong>，并且可以独立于外部事务进行回滚。如果嵌套事务发生异常并回滚，它将会回滚到自己的保存点，而不影响外部事务。</p>
<h3 id="5-SpringMVC的核心组件有哪些"><a href="#5-SpringMVC的核心组件有哪些" class="headerlink" title="5. SpringMVC的核心组件有哪些"></a>5. SpringMVC的核心组件有哪些</h3><p><strong>DispatcherServlet</strong>: <strong>核心的中央处理器，负责接受请求，分片，并给与客户端响应</strong></p>
<p><strong>HandlerMapper：处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p>
<p><strong>HandlerAdapter: 处理器适配器</strong>，根据HandlerMapper找到的Handler,适配执行对应的Handler</p>
<p><strong>Handler: 请求处理器，处理实际请求的处理器</strong></p>
<p><strong>ViewResolver: 视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</p>
<h3 id="6-SpringMVC工作流程"><a href="#6-SpringMVC工作流程" class="headerlink" title="6. SpringMVC工作流程"></a>6. SpringMVC工作流程</h3><p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240501091209217.png" alt="image-20240501091209217"></p>
<ol>
<li>客户端（浏览器）发送请求，**<code>DispatcherServlet</code>拦截请求**</li>
<li><strong><code>DispatcherServlet</code>根据请求信息调用<code>HandlerMapper</code><strong>。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，</strong>并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</strong></li>
<li><strong><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code></strong> 。</li>
<li><strong><code>Handler</code>完成对用户请求的处理后，会返回一个<code>ModelAndView</code>对象给<code>DispatchServlet</code></strong>, <code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li>**<code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>**。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h3 id="7-SpringMVC中的重定向和转发分别是如何实现的"><a href="#7-SpringMVC中的重定向和转发分别是如何实现的" class="headerlink" title="7. SpringMVC中的重定向和转发分别是如何实现的"></a>7. SpringMVC中的重定向和转发分别是如何实现的</h3><p>使用**forward:**对当前请求进行转发</p>
<p>使用**redirect:**对当前请求进行重定向</p>
<p>当SpringMVC接收到一个请求后，会先处理请求，如果后续方法要进行转发，就会利用RequestDispatcher将当前请求转发到指定地址，这种情况下，一直是同一个请求，只不过两次请求的路径不一样，并且转发对于浏览器而言是透明的</p>
<p>而如果SpringMVC接收到一个请求，并进行处理后，发现要进行重定向，此时SpringMVC会向浏览器响应303，同时会告诉浏览器要重定向的路径，表示告诉浏览器要访问另外一个路径，由浏览器自己来访问，所以重定向是需要浏览器参与的，是不同的两个请求</p>
<h1 id="数据库基础和原理"><a href="#数据库基础和原理" class="headerlink" title="数据库基础和原理"></a>数据库基础和原理</h1><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions.html">https://javaguide.cn/cs-basics/network/other-network-questions.html</a></p>
<h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h3><p><a target="_blank" rel="noopener" href="https://javabetter.cn/cs/wangluo.html#osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">https://javabetter.cn/cs/wangluo.html#osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B</a></p>
<p><strong>物理层</strong> —- </p>
<h3 id="2-TCP-IP模型"><a href="#2-TCP-IP模型" class="headerlink" title="2. TCP/IP模型"></a>2. TCP/IP模型</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/osi-and-tcp-ip-model.html#tcp-ip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B">https://javaguide.cn/cs-basics/network/osi-and-tcp-ip-model.html#tcp-ip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B</a></p>
<p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<p><strong>应用层 —- 传输层 —- 网络层 —- 网络接口层</strong></p>
<p><strong>应用层</strong>：<strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240818101832396.png" alt="image-20240818101832396"></p>
<p><strong>传输层：</strong> <strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p>​	主要包含TCP协议和UDP协议</p>
<p><strong>网络层</strong>： <strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240818103000572.png" alt="image-20240818103000572"></p>
<p><strong>网络接口层</strong>：等价于数据链路层和物理层</p>
<h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h4><p>TCP/IP（Transmission Control Protocol/Internet Protocol）协议是计算机网络中最重要的协议之一，它是一组用于实现互联网通信的协议。</p>
<p>TCP/IP 协议包括两个部分：<strong>传输控制协议（TCP）和互联网协议（IP）</strong>。IP 协议负责数据包在网络中的传输，而TCP协议则负责在数据传输过程中对数据的可靠性进行保证，确保数据能够被正确地传输到目的地。</p>
<h4 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h4><ol>
<li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：<strong>TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重</strong></li>
<li><strong>校验和丢弃</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>重传机制</strong>：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：<strong>基于计时器的重传</strong>（也就是超时重传）、<strong>快速重传</strong>（基于接收端的反馈信息来引发重传）、<strong>SACK</strong>（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、<strong>D-SACK</strong>（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。关于重传机制的详细介绍，可以查看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101702312">详解 TCP 超时与重传机制open in new window</a>这篇文章。</li>
<li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li>
</ol>
<h4 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。<strong>通信双方的发送窗口和接收窗口的要求相同</strong>。</p>
<p><strong>TCP 发送窗口可以划分成四个部分</strong>：</p>
<ol>
<li>已经发送并且确认的 TCP 段（已经发送并确认）；</li>
<li>已经发送但是没有确认的 TCP 段（已经发送未确认）；</li>
<li>未发送但是接收方准备接收的 TCP 段（可以发送）；</li>
<li>未发送并且接收方也并未准备接受的 TCP 段（不可发送）。</li>
</ol>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240818142539553" style="zoom:67%;">

<p>​		<strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code></p>
<p><strong>TCP 接收窗口可以划分成三个部分</strong>：</p>
<ol>
<li>已经接收并且已经确认的 TCP 段（已经接收并确认）；</li>
<li>等待接收且允许发送方发送 TCP 段（可以接收未确认）；</li>
<li>不可接收且不允许发送方发送 TCP 段（不可接收）。</li>
</ol>
<img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结/undefined" alt="image-20240818142639622" style="zoom:50%;">

<p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p>
<h4 id="TCP的拥塞控制是怎么实现的"><a href="#TCP的拥塞控制是怎么实现的" class="headerlink" title="TCP的拥塞控制是怎么实现的"></a>TCP的拥塞控制是怎么实现的</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>、 <strong>拥塞避免</strong>、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>
<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<p><strong>停止等待ARQ协议</strong></p>
<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong>：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong>：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<p><strong>连续ARQ协议</strong></p>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h4 id="超时重传如何实现？超时重传时间怎么确定"><a href="#超时重传如何实现？超时重传时间怎么确定" class="headerlink" title="超时重传如何实现？超时重传时间怎么确定"></a>超时重传如何实现？超时重传时间怎么确定</h4><p>当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。</p>
<ul>
<li>RTT（Round Trip Time）：往返时间，也就是数据包从发出去到收到对应 ACK 的时间。</li>
<li>RTO（Retransmission Time Out）：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。</li>
</ul>
<p>RTO 的确定是一个关键问题，因为它直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此，RTO 应该根据网络的实际状况，动态地进行调整。</p>
<p>RTT 的值会随着网络的波动而变化，所以 TCP 不能直接使用 RTT 作为 RTO。为了动态地调整 RTO，TCP 协议采用了一些算法，如加权移动平均（EWMA）算法，Karn 算法，Jacobson 算法等，这些算法都是根据往返时延（RTT）的测量和变化来估计 RTO 的值</p>
<h3 id="3-常见网络协议"><a href="#3-常见网络协议" class="headerlink" title="3. 常见网络协议"></a>3. 常见网络协议</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li><strong>HTTP：</strong>超文本传输协议是一种用于传输超文本和多媒体内容的协议。HTTP 协议基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</li>
<li>Websocket: WebSocket 是一种基于 TCP 连接的<strong>全双工通信协议</strong>，即客户端和服务器可以同时发送和接收数据。<strong>客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</strong><br>常见应用场景：视频弹幕，试试消息推送，实时游戏对战，多用户协同编辑，社交聊天<br>建立 WebSocket 连接之后，<strong>通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。</strong></li>
<li>SMTP：简单邮件传输协议，用于在邮件客户端和邮件服务器之间传输邮件，支持发送邮件和接收邮件。</li>
<li>POP3：邮局协议版本3，用于在邮件客户端和邮件服务器之间接收邮件，支持邮件下载、存储和删除等操作。</li>
<li>IMAP：互联网消息访问协议，与 POP3 类似，但支持在服务器上管理邮件，并允许用户在多个设备上同步邮件。</li>
<li><strong>FTP</strong>：文件传输协议，用于在客户端和服务器之间传输文件，支持上传、下载、删除等操作。</li>
<li>Telnet：远程终端协议，用于在客户端和服务器之间建立远程连接，允许用户在远程计算机上执行命令和操作。</li>
<li>SSH：安全外壳协议，与 Telnet 类似，但提供加密和安全认证功能，保护用户的数据和隐私。</li>
<li>DNS：域名系统，用于将域名转换成IP地址，使得用户可以通过易于记忆的域名来访问 Web 站点等。</li>
</ul>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul>
<li>TCP</li>
<li>UDP</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>IP</li>
<li>ARP 地址解析协议</li>
<li>ICMP</li>
<li>NAT</li>
<li>OSPF</li>
<li>RIP</li>
<li>BGP</li>
</ul>
<h3 id="4-从输入URL到页面展示发生了什么"><a href="#4-从输入URL到页面展示发生了什么" class="headerlink" title="4. 从输入URL到页面展示发生了什么"></a>4. 从输入URL到页面展示发生了什么</h3><ol>
<li>在浏览器中输入指定网页的URL</li>
<li>浏览器通过<strong>DNS协议，获取域名对应的IP地址</strong></li>
<li>浏览器<strong>根据IP地址和端口号，向目标服务器发起一个TCP请求连接</strong></li>
<li>浏览器在TCP连接上，向服务器<strong>发送一个HTTP请求报文，请求获取网页的内容</strong></li>
<li>服务器收到HTTP请求报文后，<strong>处理请求，并返回HTTP响应报文给浏览器</strong></li>
<li><strong>浏览器收到HTTP响应报文后，解析响应体中的HTML代码，渲染网页的结构和样式，同时根据HTML中的其他资源的URL（如图片、CSS、JS等），再次发起HTTP请求，获取这些资源的内容，直到网页完全加载显示</strong></li>
<li>浏览器在不需要和服务器通信时，可以主动关闭TCP连接，或者等待服务器的关闭请求</li>
</ol>
<h3 id="4-1-HTTP协议的结构"><a href="#4-1-HTTP协议的结构" class="headerlink" title="4-1. HTTP协议的结构"></a>4-1. HTTP协议的结构</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Zhan-W/p/11123802.html">https://www.cnblogs.com/Zhan-W/p/11123802.html</a></p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>请求报文的组成</strong>：<strong>请求行；请求头；请求体</strong></p>
<p>请求行的格式如下：<strong>Method[分隔符]Request - URL[分隔符]HTTP-Version CRLF</strong> </p>
<ul>
<li>Method 表示完成Request - URL的方法，该字段是大小写敏感的，据<a target="_blank" rel="noopener" href="http://dl.dbank.com/c05bnl6946">RFC2616</a>标准（现行的HTTP/1.1）得知，通常有以下8种方法</li>
<li>[分隔符]为空格</li>
<li>Request - URL： 遵循URL格式，此字段为星号（*）时，说明请求并不用于某个特定的资源地址，而是用于服务本身。</li>
<li>HTTP-Version：表示支持的HTTP版本，如HTTP/1.1</li>
<li>CRLF：表示换行回车符</li>
</ul>
<p><strong>HTTP的头包括通用的信息头、请求头、响应头、实体头4部分</strong>，每个头域由一个域名、冒号和值域3部分组成。域名是大小写无关的；域值前可以添加任何数量的空格，每个HTTP请求可以包含多个HTTP头域。</p>
<p>HTTP报文主体则包含了HTTP请求的内容，对于get方法，报文主体为空，对于post方法，报文主体则包含需要发送给服务器的数据。</p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240818134407226.png" alt="image-20240818134407226"></p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><strong>响应报文的组成</strong>：<strong>响应行；响应头；响应体</strong></p>
<p><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240818135521986.png" alt="image-20240818135521986"></p>
<p>状态行由状态码和原因分析两部分组成，其中，状态码由3位数字组成，表示请求是否被理解或被满足，用来支持自动操作；原因分析是对原文的状态码作简单的描述，用于供用户使用。</p>
<p>无论是请求报文还是响应报文，虽然分别由以上五个部分组成，但是在一定情况下有些并不是必须要的，但是对于：General-header(通用头部)、请求头（客户端-&gt;服务器[Request  Header])、响应头(服务端-&gt;客户端[Response Header]) 这三部分是必须要有的。于是我那一个实例来对这三部分的内容进行说明记录：</p>
<p><strong>General-header(通用头部)</strong></p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="title class_">Request</span> <span class="attr">URL</span>: <span class="attr">http</span>:<span class="comment">//115.148.141.110:8980/v1/purchase/list   　 # 请求的URL地址（包含请求类型、请求域名、请求端口、请求地址）</span></span><br><span class="line"><span class="number">2</span> <span class="title class_">Request</span> <span class="title class_">Method</span>: <span class="variable constant_">POST</span>            　　　　　　　　　　　　　　　　　　 # 请求方式</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="title class_">Status</span> <span class="title class_">Code</span>: <span class="number">200</span> <span class="variable constant_">OK</span>                                            # 响应的状态码、结果 </span><br><span class="line"><span class="number">4</span> <span class="title class_">Remote</span> <span class="title class_">Address</span>: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8899</span>                                 # 请求的远程地址       </span><br><span class="line"><span class="number">5</span> <span class="title class_">Referrer</span> <span class="title class_">Policy</span>: no-referrer-when-downgrade                    # referrer策略（五种方法）</span><br></pre></td></tr></tbody></table></figure>

<p><strong>请求头（客户端-&gt;服务器[Request Header])</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /v1/purchase/list HTTP/1.1        　　　　　　　　　　　　　　# 请求方式、请求地址、请求所使用的协议和版本</span><br><span class="line">Host: 115.157.151.673:8180            　　　　　　　　　　　　　　 # 目标主机地址和端口号</span><br><span class="line">Connection: keep-alive                       　　　　　　　　　　 # 维护客户端和服务端的连接关系</span><br><span class="line">Content-Length: 68                            　　　　　　　　　　# 描述HTTP消息实体的传输长度</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01         # 发送端（客户端）希望接受的数据类型、q 是权重系数，范围 0 =&lt; q &lt;= 1，q 值越大，请求越倾向于获得其“;”之前的类型表示的内容</span><br><span class="line">Origin: http://apptest.zhidianlife.com:8007　　　　　　　　　　　　# 浏览器在referrer字段中只显示源网站的源地址（即协议、域名、端口），而不包括完整的路径</span><br><span class="line">Authorization: c81e7286507f4aa4b6179f4c381b4c64　　　　　　　　　 # 请求所需的认证信息</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64)      AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36          # 客户端版本号的名字</span><br><span class="line">Content-Type: application/json   　　　　　　　　　　　　　　　　　　# 请求实体，文档类型</span><br><span class="line">Referer: http://apptest.zhidianlife.com:8007/procurement/order?_t=756512&amp;_winid=w9290         #  从来于哪里</span><br><span class="line">Accept-Encoding: gzip, deflate        　　　　　　　　　　　　　　  # 客户端接收编码类型，一些网络压缩格式： gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9    　　　　　　　　　　　　　　　　  # 客户端接收的语言类型 、中文</span><br></pre></td></tr></tbody></table></figure>

<p><strong>响应头(服务端-&gt;客户端[Response Header])</strong></p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span>                    　　　　　　　　　　　　　　　　　　　# 请求协议以及本版、请求状态码</span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Tue</span>, <span class="number">02</span> <span class="title class_">Jul</span> <span class="number">2019</span> <span class="number">14</span>:<span class="number">07</span>:<span class="number">31</span> <span class="variable constant_">GMT</span>    　 　　　　　　　　　　　　　　　# 服务端响应客户端的内容过期时间</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json; charset=utf-<span class="number">8</span>        　　　　　　  　# 服务端发送的类型及采用的编码方式</span><br><span class="line"><span class="title class_">Server</span>: <span class="title class_">Kestrel</span>         　　　　　　　　　　　　　　　　　　　　　　　　 　# <span class="variable constant_">WEB</span> 服务器 服务端的<span class="title class_">Web</span>服务端名</span><br><span class="line"><span class="title class_">Vary</span>: <span class="title class_">Origin</span>    　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 　# <span class="variable constant_">WEB</span>服务器用该头部的内容告诉 <span class="title class_">Cache</span> 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span>　　　　　　　　　　　　　　　　　 # 允许运行客户端携带证书式访问</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//apptest.zhidianlife.com:8007</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">33310</span>　　　　　　　　　　　　　　　　　　　　　　　　　　   # 允许指定的域名、地址访问</span><br></pre></td></tr></tbody></table></figure>

<h4 id="GET与POST请求过程"><a href="#GET与POST请求过程" class="headerlink" title="GET与POST请求过程"></a>GET与POST请求过程</h4><p><strong>POST请求的过程</strong>：</p>
<ul>
<li><p>浏览器请求tcp连接（第一次握手）</p>
</li>
<li><p>服务器答应进行tcp连接（第二次握手）</p>
</li>
<li><p>浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</p>
</li>
<li><p>服务器返回100 Continue响应</p>
</li>
<li><p>浏览器发送数据</p>
</li>
<li><p>服务器返回200 OK响应</p>
</li>
</ul>
<p><strong>GET请求的过程</strong>：</p>
<ul>
<li>浏览器请求tcp连接（第一次握手）</li>
<li>服务器答应进行tcp连接（第二次握手）</li>
<li>浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li>服务器返回200OK响应</li>
</ul>
<h4 id="HTTP协议的不足"><a href="#HTTP协议的不足" class="headerlink" title="HTTP协议的不足"></a>HTTP协议的不足</h4><ul>
<li><strong>通信使用明文（不加密），内容可能被窃听</strong></li>
</ul>
<p>　　由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送。</p>
<p>　　HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。</p>
<ul>
<li><strong>无法证明报文的完整性，所以可能遭篡改</strong></li>
</ul>
<p>　　所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br>　　换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。</p>
<ul>
<li><strong>不验证通信方的身份，因此有可能遭遇伪装</strong></li>
</ul>
<p>　　HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）</p>
<p>　　HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。</p>
<p><font color="blue"><strong>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</strong></font></p>
<p>HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。</p>
<p>TLS/SSL 的功能实现主要依赖于三类基本算法：<strong>散列函数 、对称加密和非对称加密</strong>，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p>
<p><strong>对称加密算法：</strong>这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。以对称加密方式加密时必须将密钥也发给对方。容易被截取</p>
<p><strong>非对称加密算法：</strong> 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>
<p>非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。</p>
<p>这种方式有以下缺点：</p>
<ul>
<li>公钥是公开的，<strong>所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容</strong>；</li>
<li>公钥并不包含服务器的信息，<strong>使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险</strong>，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；</li>
<li>使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率；</li>
</ul>
<p><strong>HTTPS采用对称加密+非对称加密</strong>：使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。</p>
<p><strong>解决报文可能遭篡改问题——数字签名</strong>。数字签名有两种功效：</p>
<ul>
<li>能<strong>确定消息确实是由发送方签名并发出来的</strong>，因为别人假冒不了发送方的签名。</li>
<li><strong>数字签名能确定消息的完整性</strong>,证明数据是否未被篡改过。</li>
</ul>
<p><strong>解决通信身份可能被伪装的问题——数字证书</strong></p>
<ul>
<li>服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li>
<li>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li>
<li>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;</li>
<li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li>
<li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li>
<li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</li>
</ul>
<h3 id="5-HTTP状态码"><a href="#5-HTTP状态码" class="headerlink" title="5. HTTP状态码"></a>5. HTTP状态码</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" alt="常见 HTTP 状态码"></p>
<h3 id="6-HTTP和HTTPS有什么区别"><a href="#6-HTTP和HTTPS有什么区别" class="headerlink" title="6. HTTP和HTTPS有什么区别"></a>6. HTTP和HTTPS有什么区别</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-vs-https.png" alt="HTTP 和 HTTPS 对比"></p>
<p><strong>端口号： HTTP：80    HTTPS：443</strong></p>
<p><strong>URL前缀：</strong>http//     https//</p>
<p><strong>安全性和资源消耗</strong>：</p>
<p>在HTTPS出现之前，所有请求都是以明文方式送出的，那么如果有人在传输途中偷听或者抓包的话，你的所有通信内容都会泄漏。比较安全的方法是将通信内容加密在发送给对方。加密方法有两种，<strong>对称加密和非对称加密</strong>。</p>
<p><strong>对称加密</strong>指的是加密和解密用同一个密钥。但是在通信之前，客户端和服务端是不会有这样同一把密钥的。需要其中一方将密钥发送给对方。在整个传输过程没有任何验证操作，所以黑客也可以截取到这把密钥从而破译出加密的内容。所以纯对称加密是不安全的。</p>
<p>非对称加密指的是加密和解密用不同的密钥。可以是用私钥加密，公钥解密，也可以是用公钥加密，私钥解密。但是会有这种情况。服务端拥有私钥和公钥，将公钥发给客户端。既然客户端可以获得公钥，黑客也可以获得公钥。那么服务端发送给客户端的所有内容黑客也是可以解读的。客户端用公钥加密发送给服务端不受影响，因为黑客手上没有服务器的私钥。所以纯非对称加密也是不安全的。</p>
<p><strong>HTTPS是可靠的，因为它解决了三个问题</strong></p>
<ol>
<li><strong>加密通信</strong>，即使别人获取到了信息也没法复原成原来的信息。</li>
<li>防止中间人攻击。黑客没法冒充服务端。因为<strong>在第2步，服务端给了客户端一个CA证书</strong>。<ol>
<li>如果客户端验证了这个证书，说明这个证书和公钥是由服务端发来的且真实可靠。</li>
<li>如果客户端验证不了这个证书，就说明这个证书不可靠，有可能是假的。</li>
</ol>
</li>
<li>CA证书的公信力。CA证书需要由公司或者个人发出申请，再通过邮箱验证等方法验证域名存在。避免了黑客冒充网站获取证书的可能。</li>
</ol>
<p><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。<strong>使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</strong></p>
<h3 id="7-HTTP-1-0-和HTTP-1-1有什么区别"><a href="#7-HTTP-1-0-和HTTP-1-1有什么区别" class="headerlink" title="7. HTTP/1.0 和HTTP/1.1有什么区别"></a>7. HTTP/1.0 和HTTP/1.1有什么区别</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.0-vs-http1.1.png" alt="HTTP/1.0 和 HTTP/1.1 对比"></p>
<p><strong>连接方式</strong> : <strong>HTTP/1.0 为短连接，HTTP/1.1 支持长连接</strong>。HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</p>
<p><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>
<p><strong>缓存机制</strong> : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>
<p><strong>带宽</strong>：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，<strong>并且不支持断点续传功能</strong>，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>Host 头（Host Header）处理</strong> :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，<strong>从而支持虚拟主机的功能。</strong>而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。</p>
<h3 id="8-HTTP-1-1-和HTTP-2-0有什么区别"><a href="#8-HTTP-1-1-和HTTP-2-0有什么区别" class="headerlink" title="8. HTTP/1.1 和HTTP/2.0有什么区别"></a>8. HTTP/1.1 和HTTP/2.0有什么区别</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.1-vs-http2.0.png" alt="HTTP/1.0 和 HTTP/1.1 对比"></p>
<p><strong>多路复用（Multiplexing）</strong>：<strong>HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰</strong>。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。</p>
<p><strong>二进制帧（Binary Frames）</strong>：<strong>HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文</strong>。<strong>二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</strong></p>
<p><strong>头部压缩（Header Compression）</strong>：HTTP/1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。<strong>HTTP/2.0 支持对<code>Header</code>压缩，使用了专门为<code>Header</code>压缩而设计的 HPACK 算法，减少了网络开销。</strong></p>
<p><strong>服务器推送（Server Push）</strong>：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源.</p>
<h3 id="9-HTTP-2-0-和HTTP-3-0有什么区别"><a href="#9-HTTP-2-0-和HTTP-3-0有什么区别" class="headerlink" title="9. HTTP/2.0 和HTTP/3.0有什么区别"></a>9. HTTP/2.0 和HTTP/3.0有什么区别</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http2.0-vs-http3.0.png" alt="HTTP/2.0 和 HTTP/3.0 对比"></p>
<p><strong>传输协议</strong>：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</p>
<p><strong>连接建立</strong>：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p>
<p><strong>队头阻塞</strong>：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
<p><strong>错误恢复</strong>：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。</p>
<p><strong>安全性</strong>：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</p>
<h3 id="10-HTTP时不保存状态的协议，如何保存用户状态？"><a href="#10-HTTP时不保存状态的协议，如何保存用户状态？" class="headerlink" title="10. HTTP时不保存状态的协议，如何保存用户状态？"></a>10. HTTP时不保存状态的协议，如何保存用户状态？</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 <strong>HTTP 协议自身不对请求和响应之间的通信状态进行保存。</strong>那么我们如何保存用户状态呢？<strong>Session 机制</strong>的存在就是为了解决这个问题，<strong>Session 的主要作用就是通过服务端记录用户的状态</strong>。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<h3 id="11-URI和URL的区别是什么"><a href="#11-URI和URL的区别是什么" class="headerlink" title="11. URI和URL的区别是什么"></a>11. URI和URL的区别是什么</h3><p>URI(Uniform Resource Identifier) 是<strong>统一资源标志符，可以唯一标识一个资源。</strong></p>
<p>URL(Uniform Resource Locator) 是<strong>统一资源定位符，可以提供该资源的路径。</strong>它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p>
<h3 id="12-Cookie、Session和Token有什么区别"><a href="#12-Cookie、Session和Token有什么区别" class="headerlink" title="12. Cookie、Session和Token有什么区别"></a>12. Cookie、Session和Token有什么区别</h3><p>Cookie、Session 和 Token 通常都是用来保存用户登录信息的技术，但三者有很大的区别，简单来说 <strong>Cookie 适用于简单的状态管理，Session 适用于需要保护用户敏感信息的场景，而 Token 适用于状态无关的身份验证和授权。</strong></p>
<p><strong>存储位置不同</strong>：<strong>Cookie 存储在客户端</strong>，即浏览器中的文本文件，通过在 HTTP 头中传递给服务器来进行通信；<strong>Session 是服务器端的存储方式</strong>，通常存储在服务器的内存或数据库中；<strong>Token 也是存储在客户端</strong>，但是通常以<strong>加密</strong>的方式存储<strong>在客户端的 localStorage 或 sessionStorage</strong> 中。</p>
<p><strong>数据安全性不同</strong>：Cookie 存储在客户端，<strong>可能会被窃取或篡改</strong>，因此对敏感信息的存储需要进行加密处理；<strong>Session 存储在服务器端，通过一个 Session ID 在客户端和服务器之间进行关联，可以避免敏感数据直接暴露；</strong> <strong>Token 通常使用加密算法生成，有效期较短且单向不可逆，可以提供较高的安全性。</strong></p>
<p><strong>跨域支持不同</strong>：为了防止安全事故，<strong>因此 Cookie 是不支持跨域传输</strong>的，也就是不同域名下的 Cookie 是不能相互访问的；而 <strong>Session 机制通常是通过 Cookie 来保存 Session ID</strong> 的，因此 <strong>Session ID 默认情况下也是不支持跨域</strong>的；但 <strong>Token 可以轻松实现跨域</strong>，因为 Token 是存储在客户端的 localStorage 或者作为请求头的一部分发送到服务器的，所以不同的域名 Token 信息传输通常是不受影响的。</p>
<p><strong>状态管理不同</strong>：Cookie 是应用程序通过在客户端存储临时数据，用于实现状态管理的一种机制；Session 是服务器端记录用户状态的方式，服务器会为每个会话分配一个唯一的 Session ID，并将其与用户状态相关联；Token 是一种用于认证和授权的一种机制，通常表示用户的身份信息和权限信息。</p>
<h4 id="Cookie和Session有什么关系"><a href="#Cookie和Session有什么关系" class="headerlink" title="Cookie和Session有什么关系"></a>Cookie和Session有什么关系</h4><p><strong>Session</strong> 是<strong>基于Cookie 实现</strong>的另一种记录服务端和客户端会话状态的机制。<strong>Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中。</strong></p>
<p>Session 机制的实现流程如下：</p>
<ol>
<li><strong>会话创建</strong>：通常情况下，当用户登录成功后，服务器会为该用户创建一个新的会话。在创建会话过程中，服务器会为该会话生成一个唯一的标识符，通常称为 <strong>Session ID。</strong></li>
<li><strong>Session ID 传递</strong>：<strong>服务器将生成的 Session ID 通过响应的方式发送给客户端</strong>，使用 SetCookie 命令，<strong>将用户的 Session ID 保存在 Cookie 中</strong>，通常是一个名为 JSESSIONID 的 Cookie。</li>
<li><strong>Session 数据存储</strong>：<strong>在服务器端，Session 数据会被存储在一个能够关联 Session ID 的数据结构中</strong>（例如内存、数据库或者文件存储等）。常用的方式是将 Session ID 作为键，与对应的 Session 用户身份数据进行关联。</li>
<li><strong>Session ID 验证与检索</strong>：<strong>当用户发送一个新的请求时，客户端会将之前存储的 Session ID 携带在请求的 Cookie 或请求头中发送给服务器</strong>。服务器会根据 Session ID 找到对应的 Session 数据，从而获得用户的状态信息。</li>
<li><strong>Session 数据使用</strong>：服务器在获取到 Session 数据后，可以根据具体需求读取、修改或删除其中保存的状态信息。<strong>服务器可以通过 Session 来管理用户的登录状态、购物车内容、用户配置等。</strong></li>
<li><strong>Session 过期与销毁</strong>：<strong>Session 有一个有效期限，一般通过设置一个固定的时间，或者在一定时间内没有用户活动时会将 Session 标记为过期。</strong>当 Session 过期时，服务器会销毁对应的 Session 数据，释放内存或其他资源。</li>
</ol>
<p>【注】<strong>默认情况下禁用 Cookie 后，Session 是无法正常使用的</strong>。可以通过<strong>URL中携带SessionID</strong>或者<strong>隐藏表单字段传递SessionID</strong>绕过Cookie继续运行Session.</p>
<h3 id="13-GET和POST的区别"><a href="#13-GET和POST的区别" class="headerlink" title="13. GET和POST的区别"></a>13. GET和POST的区别</h3><p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：</p>
<ul>
<li><strong>语义（主要区别）</strong>：<strong>GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</strong></li>
<li><strong>幂等</strong>：<strong>GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</strong></li>
<li><strong>格式：</strong> <strong>GET 请求的参数通常放在 URL 中，形成查询字符串</strong>（querystring），而 <strong>POST 请求的参数通常放在请求体（body）中，可以有多种编码格式</strong>，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。</li>
<li><strong>缓存：</strong> <strong>由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</strong></li>
<li><strong>安全性：</strong>GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，<strong>GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中</strong>。</li>
</ul>
<h3 id="14-WebSocket和HTTP的区别"><a href="#14-WebSocket和HTTP的区别" class="headerlink" title="14. WebSocket和HTTP的区别"></a>14. WebSocket和HTTP的区别</h3><ul>
<li><strong>WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。</strong>并且，<strong>HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。</strong></li>
<li><strong>WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀</strong>，HTTP 使用 http:// 或 https:// 作为协议前缀。</li>
<li>WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。</li>
<li><strong>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大</strong>（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。</li>
</ul>
<h3 id="15-WebSocket的工作过程时怎么样的"><a href="#15-WebSocket的工作过程时怎么样的" class="headerlink" title="15. WebSocket的工作过程时怎么样的"></a>15. WebSocket的工作过程时怎么样的</h3><h3 id="16-PING"><a href="#16-PING" class="headerlink" title="16. PING"></a>16. PING</h3><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p>
<p>PING 基于网络层的 <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p>
<h3 id="17-DNS"><a href="#17-DNS" class="headerlink" title="17. DNS"></a>17. DNS</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions2.html">https://javaguide.cn/cs-basics/network/other-network-questions2.html</a></p>
<h3 id="18-TCP和UDP的区别"><a href="#18-TCP和UDP的区别" class="headerlink" title="18. TCP和UDP的区别"></a>18. TCP和UDP的区别</h3><ul>
<li><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
</ul>
<p><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。<strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录。</p>
<h3 id="19-TCP的三次握手和四次挥手-star2-star2-star2"><a href="#19-TCP的三次握手和四次挥手-star2-star2-star2" class="headerlink" title="19. TCP的三次握手和四次挥手:star2::star2::star2:"></a>19. TCP的三次握手和四次挥手:star2::star2::star2:</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html">https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html</a></p>
<h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结" alt="TCP 三次握手图解" style="zoom:50%;">



<p><strong>一次握手</strong>: <strong>客户端发送带有 SYN（SEQ=x） 标志的数据包</strong> -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务端的确认；</p>
<p><strong>二次握手</strong>: <strong>服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包</strong> –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态；</p>
<p><strong>三次握手</strong>: 客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</p>
<h4 id="什么是半连接队列和全连接队列"><a href="#什么是半连接队列和全连接队列" class="headerlink" title="什么是半连接队列和全连接队列"></a>什么是半连接队列和全连接队列</h4><p><strong>半连接队列</strong>（也称 SYN Queue）：当服务端收到客户端的 SYN 请求时，此时双方还没有完全建立连接，它会把半连接状态的连接放在半连接队列。</p>
<p><strong>全连接队列</strong>（也称 Accept Queue）：<strong>当服务端收到客户端对 ACK 响应时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。</strong>如果未收到客户端的 ACK 响应，会进行重传，重传的等待时间通常是指数增长的。如果重传次数超过系统规定的最大重传次数，系统将从半连接队列中删除该连接信息。</p>
<h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p>三次握手的目的是<strong>建立可靠的通信信道</strong>，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</p>
<ul>
<li><strong>第一次握手</strong>：Client 什么都不能确	认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ul>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<h4 id="第二次握手传回了ACK，为什么还要传回SYN？"><a href="#第二次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="第二次握手传回了ACK，为什么还要传回SYN？"></a>第二次握手传回了ACK，为什么还要传回SYN？</h4><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务端之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务端使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务端之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务端之间传递。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="三次握手过程中可以携带数据嘛？"><a href="#三次握手过程中可以携带数据嘛？" class="headerlink" title="三次握手过程中可以携带数据嘛？"></a>三次握手过程中可以携带数据嘛？</h4><p>在 TCP 三次握手过程中，<strong>第三次握手是可以携带数据的</strong>(客户端发送完 ACK 确认包之后就进入 ESTABLISHED 状态了)，这一点在 RFC 793 文档中有提到。也就是说，一旦完成了前两次握手，TCP 协议允许数据在第三次握手时开始传输。</p>
<p>如果第三次握手的 ACK 确认包丢失，但是客户端已经开始发送携带数据的包，那么服务端在收到这个携带数据的包时，如果该包中包含了 ACK 标记，服务端会将其视为有效的第三次握手确认。这样，连接就被认为是建立的，服务端会处理该数据包，并继续正常的数据传输流程。</p>
<h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h4><img src="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/08/22/Java基础常见面试题总结" alt="TCP 四次挥手图解" style="zoom:50%;">

<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ol>
<li><strong>第一次挥手</strong>：<strong>客户端发送一个 FIN（SEQ=x） 标志的数据包-&gt;服务端，用来关闭客户端到服务端的数据传送。</strong>然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong>：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li>
<li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK=y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<h4 id="为什么不把服务端发送的ACK和FIN合并起来，变成三次挥手"><a href="#为什么不把服务端发送的ACK和FIN合并起来，变成三次挥手" class="headerlink" title="为什么不把服务端发送的ACK和FIN合并起来，变成三次挥手"></a>为什么不把服务端发送的ACK和FIN合并起来，变成三次挥手</h4><p>因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送。</p>
<h4 id="如果第二次挥手时服务端的ACK没有哦送达客户端，会怎么样"><a href="#如果第二次挥手时服务端的ACK没有哦送达客户端，会怎么样" class="headerlink" title="如果第二次挥手时服务端的ACK没有哦送达客户端，会怎么样"></a>如果第二次挥手时服务端的ACK没有哦送达客户端，会怎么样</h4><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h4 id="为什么第四次挥手客户端需要等待2-MSL（报文段最长寿命）时间后才会进入CLOSED状态？"><a href="#为什么第四次挥手客户端需要等待2-MSL（报文段最长寿命）时间后才会进入CLOSED状态？" class="headerlink" title="为什么第四次挥手客户端需要等待2*MSL（报文段最长寿命）时间后才会进入CLOSED状态？"></a>为什么第四次挥手客户端需要等待2*MSL（报文段最长寿命）时间后才会进入CLOSED状态？</h4><p>第四次挥手时，客户端发送给服务端的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="20-TCP如何保证传输的可靠性"><a href="#20-TCP如何保证传输的可靠性" class="headerlink" title="20. TCP如何保证传输的可靠性"></a>20. TCP如何保证传输的可靠性</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html">https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html</a></p>
<h4 id="TCP如何保证传输的可靠性-1"><a href="#TCP如何保证传输的可靠性-1" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h4><p><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</p>
<p><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</p>
<p><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p><strong>重传机制</strong> : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。</p>
<p><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</p>
<p><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</p>
<h4 id="TCP如何实现流量控制-1"><a href="#TCP如何实现流量控制-1" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<h4 id="TCP的拥塞控制是怎么实现的-1"><a href="#TCP的拥塞控制是怎么实现的-1" class="headerlink" title="TCP的拥塞控制是怎么实现的"></a>TCP的拥塞控制是怎么实现的</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>、 <strong>拥塞避免</strong>、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<h3 id="21-IP"><a href="#21-IP" class="headerlink" title="21. IP"></a>21. IP</h3><h4 id="IP协议的作用是什么"><a href="#IP协议的作用是什么" class="headerlink" title="IP协议的作用是什么"></a>IP协议的作用是什么</h4><p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>
<h4 id="什么是IP地址？IP寻址如何工作"><a href="#什么是IP地址？IP寻址如何工作" class="headerlink" title="什么是IP地址？IP寻址如何工作"></a>什么是IP地址？IP寻址如何工作</h4><p>每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 <strong>IP 地址（Internet Protocol address）</strong>，作为唯一标识符。每个 IP 地址都是一个字符序列，如 192.168.1.1（IPv4）、2001:0db8:85a3:0000:0000:8a2e:0370:7334（IPv6） 。</p>
<p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。</p>
<p>网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p>
<p>这种基于 IP 地址的寻址方式是互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现了全球范围内的网络互联互通。IP 地址的唯一性和全局性保证了网络中的每个设备都可以通过其独特的 IP 地址进行标识和寻址。</p>
<h3 id="22-NAT的作用是什么"><a href="#22-NAT的作用是什么" class="headerlink" title="22. NAT的作用是什么?"></a>22. NAT的作用是什么?</h3><p><strong>NAT（Network Address Translation，网络地址转换）</strong> <strong>主要用于在不同网络之间转换 IP 地址</strong>。它允许<strong>将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射</strong>，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>
<p>NAT 不光可以缓解 IPv4 地址资源短缺的问题，<strong>还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性.</strong></p>
<h3 id="22-请求转发和请求重定向有什么区别？"><a href="#22-请求转发和请求重定向有什么区别？" class="headerlink" title="22. 请求转发和请求重定向有什么区别？"></a>22. 请求转发和请求重定向有什么区别？</h3><p><font color="blue"><strong>定义不同</strong></font></p>
<p><strong>请求转发（Forward）：</strong>发生在<strong>服务端程序内部</strong>，当服务器端收到一个客户端的请求之后，会先将请求，转发给目标地址，再将目标地址返回的结果转发给客户端。 </p>
<p><strong>请求重定向（Redirect）：</strong>请求重定向指的是<strong>服务器端接收到客户端</strong>的请求之后，会给客户端返回了一个临时响应头，这个临时响应头中记录了，客户端需要再次发送请求（重定向）的 URL 地址，客户端再收到了地址之后，会将请求发送到新的地址上，这就是请求重定向。</p>
<p><strong><font color="blue">请求方不同</font></strong></p>
<p><strong>请求转发是服务器端的行为</strong>，服务器端代替客户端发送请求，并将结果返回给客户端；而<strong>请求重定向是客户端的行为</strong></p>
<p><font color="blue"><strong>数据共享不同</strong></font></p>
<p><strong>请求转发</strong>是服务器端实现的，所以整个执行流程中，<strong>客户端（浏览器端）只需要发送一次请求</strong>，因此整个交互过程中使用的都是同一个 Request 请求对象和一个 Response 响应对象，所以整个请求过程中，请求和返回的数据是共享的；而<strong>请求重定向客户端发送两次完全不同的请求</strong>，所以两次请求中的数据是不同的。</p>
<p><font color="blue"><strong>最终URL地址不同</strong></font></p>
<p><strong>请求转发</strong>是服务器端代为请求，再将结果返回给客户端的，所以<strong>整个请求的过程中 URL 地址是不变的</strong>；而请求重定向是服务器端告诉客户端，“你去另一个地访问去”，所以浏览器会重新再发送一次请求，因此客户端最终显示的 URL 也为最终跳转的地址，而非刚开始请求的地址，所以 <strong>URL 地址发生了改变</strong>(重定向)。</p>
<h3 id="23-ARP协议"><a href="#23-ARP协议" class="headerlink" title="23. ARP协议"></a>23. ARP协议</h3><p><strong>每个主机都会有自己的ARP缓冲区建立一个ARP缓冲列表，以表示IP地址和MAC地址之间的对应关系。</strong></p>
<p>当源主机要发送数据时，<strong>首先检测ARP列表</strong>中是否对应IP地址的目的主机的MAC地址，<strong>如果有，直接发送数据，如果没有就向本网段所有主机发送ARP数据包。</strong></p>
<p>当本网络的所有主机收到该ARP数据包时，首先会检查数据包中的IP地址是否是自己的IP地址，如果不是则忽略该数据包，如果是则首先从数据包中取出源主机的IP地址和MAC地址写入ARP列表，如果存在，则覆盖然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是他想要找的MAC地址。</p>
<p>源主机收到ARP相应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据，如果源主机一直没收到ARP响应数据包，表示ARP查询失败。</p>
<p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，<strong>它解决的是网络层地址和链路层地址之间的转换问题。</strong>因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
<h3 id="24-数字签名"><a href="#24-数字签名" class="headerlink" title="24. 数字签名"></a>24. 数字签名</h3><p>数字签名是<strong>一种利用非对称加密算法，通过私钥对原始数据进行加密生成签名，然后使用公钥对签名进行解密验证的技术。</strong>其核心目的是<strong>验证数字信息的完整性和真实性。</strong>在数字签名的过程中，私钥只有签名者自己知道，公钥可以公开，这样就能够确保签名的唯一性和真实性。</p>
<p>数字签名基于非对称加密算法，主要包括以下步骤：</p>
<ol>
<li><p><strong>签名者使用私钥对原始数据进行加密，生成数字签名。</strong>私钥只有签名者自己知道，因此只有签名者能够生成数字签名。</p>
</li>
<li><p><strong>签名者将数字签名附加到原始数据中，形成完整的数字签名数据。</strong></p>
</li>
<li><p><strong>接收者使用公钥对数字签名进行解密验证。</strong>公钥是公开的，任何人都可以使用公钥来验证数字签名的有效性。</p>
</li>
<li><p><strong>验证过程中，如果解密成功且得到的数字摘要与原始数据的数字摘要一致，则认为数字签名有效，</strong>原始数据的完整性和真实性得到了验证。</p>
<ol>
<li><p>将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者</p>
<p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。</p>
<p>如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
</li>
</ol>
</li>
</ol>
<h3 id="25-加密算法"><a href="#25-加密算法" class="headerlink" title="25. 加密算法"></a>25. 加密算法</h3><p>加密算法分<strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密密钥相同，非对称加密算法的加密密钥与解密密钥不同，此外，还有一类不需要密钥的<strong>散列算法</strong>。</p>
<p>常见的 <strong>对称加密</strong> 算法主要有 <code>DES</code>、<code>3DES</code>、<code>AES</code> 等，常见的 <strong>非对称算法</strong> 主要有 <code>RSA</code>、<code>DSA</code> 等，<strong>散列算法</strong> 主要有 <code>SHA-1</code>、<code>MD5</code> 等</p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>在 <strong>对称加密算法</strong> 中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行 <strong>加密</strong> 和 <strong>解密</strong>。</p>
<ul>
<li>数据加密过程：在对称加密算法中，数据发送方 将 <strong>明文</strong> (原始数据) 和 <strong>加密密钥</strong> 一起经过特殊 <strong>加密处理</strong>，生成复杂的 <strong>加密密文</strong> 进行发送。</li>
<li>数据解密过程：<strong>数据接收方</strong> 收到密文后，若想读取原数据，则需要使用 <strong>加密使用的密钥</strong> 及相同算法的 <strong>逆算法</strong> 对加密的密文进行解密，才能使其恢复成 <strong>可读明文</strong>。</li>
</ul>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p><strong>非对称加密算法</strong>，它需要两个密钥，一个称为 <strong>公开密钥</strong> (<code>public key</code>)，即 <strong>公钥</strong>，另一个称为 <strong>私有密钥</strong> (<code>private key</code>)，即 <strong>私钥</strong>。</p>
<p>因为 <strong>加密</strong> 和 <strong>解密</strong> 使用的是两个不同的密钥，所以这种算法称为 <strong>非对称加密算法</strong>。</p>
<ol>
<li>如果使用 <strong>公钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>私钥</strong> 才能 <strong>进行解密</strong>。</li>
<li>如果使用 <strong>私钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>公钥</strong> 才能 <strong>进行解密</strong>。</li>
</ol>
<h3 id="26-JWT"><a href="#26-JWT" class="headerlink" title="26. JWT"></a>26. JWT</h3><p>JWT （<strong>JSON Web Token</strong>） 是目前最流行的跨域认证解决方案，是<strong>一种基于 Token 的认证授权机制</strong>。从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。</p>
<p>JWT 自身包含了身份验证所需要的所有信息，因此，<strong>我们的服务器不需要存储 Session 信息。</strong>这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p>
<p>使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。</p>
<h4 id="JWT有哪些部分组成"><a href="#JWT有哪些部分组成" class="headerlink" title="JWT有哪些部分组成"></a>JWT有哪些部分组成</h4><p>JWT 本质上就是一组字串，通过（<code>.</code>）切分成三个为 Base64 编码的部分：</p>
<ul>
<li><strong>头部(Header)：</strong>描述 JWT 的元数据，<strong>定义了生成签名的算法以及 <code>Token</code> 的类型。</strong>Header 被 Base64Url 编码后成为 JWT 的第一部分。</li>
<li><strong>Payload(载荷)：</strong> 用来存放实际需要传递的数据，包含声明（Claims），如<code>sub</code>（subject，主题）、<code>jti</code>（JWT ID）。Payload 被 Base64Url 编码后成为 JWT 的第二部分。</li>
<li><strong>Signature(签名)：</strong> <strong>服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成</strong>。生成的签名会成为 JWT 的第三部分。</li>
</ul>
<p><strong>Header 和 Payload 都是 JSON 格式的数据，Signature 由 Payload、Header 和 Secret(密钥)通过特定的计算公式和加密算法得到。</strong></p>
<p>【注】Signature 部分是对前两部分的签名，作用是防止 JWT（主要是 payload） 被篡改。</p>
<h4 id="如何基于JWT进行身份验证"><a href="#如何基于JWT进行身份验证" class="headerlink" title="如何基于JWT进行身份验证"></a>如何基于JWT进行身份验证</h4><p>在基于 JWT 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。</p>
<ul>
<li>用户向服务器发送用户名、密码以及验证码用于登陆系统。</li>
<li>如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。</li>
<li>用户以后每次向后端发请求都在 Header 中带上这个 JWT 。</li>
<li>服务端检查 JWT 并从中获取用户相关信息。</li>
</ul>
<p>【注】建议将 JWT 存放在 localStorage 中，放在 Cookie 中会有 CSRF 风险。</p>
<p>请求服务端并携带 JWT 的常见做法是将其放在 HTTP Header 的 <code>Authorization</code> 字段中（<code>Authorization: Bearer Token</code>）</p>
<h4 id="如何防止JWT被篡改"><a href="#如何防止JWT被篡改" class="headerlink" title="如何防止JWT被篡改"></a>如何防止JWT被篡改</h4><p>有了签名之后，即使 JWT 被泄露或者截获，黑客也没办法同时篡改 Signature、Header、Payload。</p>
<p>这是为什么呢？因为服务端拿到 JWT 之后，会解析出其中包含的 Header、Payload 以及 Signature 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 Signature 和 JWT 中的 Signature 作对比，如果一样就说明 Header 和 Payload 没有被修改。</p>
<p>不过，如果服务端的秘钥也被泄露的话，黑客就可以同时篡改 Signature、Header、Payload 了。黑客直接修改了 Header 和 Payload 之后，再重新生成一个 Signature 就可以了。</p>
<p><strong>密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。</strong></p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p><a target="_blank" rel="noopener" href="https://www.javacn.site/interview/springcloud/">https://www.javacn.site/interview/springcloud/</a></p>
<h3 id="1-微服务通讯方式有哪些"><a href="#1-微服务通讯方式有哪些" class="headerlink" title="1. 微服务通讯方式有哪些"></a>1. 微服务通讯方式有哪些</h3><p>微服务的通讯方式主要有以下几种：</p>
<ol>
<li><strong>RESTful API</strong>：基于 HTTP 协议的 RESTful API 是最常用的微服务通讯方式之一。服务之间通过 HTTP 请求和响应进行通讯，实现数据交换。这种方式简单、通用，适用于各种场景，但可能不适合对实时性要求非常高的场景。</li>
<li><strong>RPC（远程过程调用）</strong>：RPC 允许一个服务像调用本地方法一样调用另一个服务的方法。它通过将方法调用封装成网络数据包并在不同的进程之间传输，实现不同服务之间的互相调用。<strong>RPC 方式可以提高调用的效率和性能，但可能需要更多的配置和管理工作。</strong></li>
<li><strong>消息队列通讯</strong>：如 RabbitMQ、Kafka、RocketMQ 等，服务之间不直接调用，而是通过消息队列进行异步消息传递，实现服务之间的解耦和异步处理。</li>
<li><strong>事件驱动通讯</strong>：服务之间通过事件触发通讯，一旦某个服务发生了某个事件，就会触发其他服务的响应。这种方式可以实现服务的松耦合和事件的实时处理，典型的实现如 Event Bus。</li>
<li><strong>WebSocket（长连接通信）</strong>：使用 WebSocket 实现双向通信，常用于实时推送场景，服务间可以维持长期的 TCP 连接进行数据交换。</li>
</ol>
<p>其中，RESTful API 和 RPC 是微服务间最常用的通讯方式，但它们的使用场景又略有不同：</p>
<ul>
<li>RESTful API 通常用于外部接口或第三方接口通讯。</li>
<li>RPC 通常用于内部微服务之间的方法调用。</li>
</ul>
<h4 id="RESTful-API-vs-RPC"><a href="#RESTful-API-vs-RPC" class="headerlink" title="RESTful API vs RPC"></a>RESTful API vs RPC</h4><p><strong>功能和用途不同</strong>： </p>
<ol>
<li>RESTful API <strong>常用于浏览器和服务器之间的通信，第三方接口通讯等</strong>，它可以实现基于请求-响应模式的通信，支持无状态和有状态的交互。</li>
<li>RPC 是一种用于远程过程调用的协议，用于不同计算节点之间的通信，<strong>多用于微服务内部间的调用</strong>。它允许应用程序通过网络调用远程服务，并像调用本地方法一样轻松实现分布式系统的集成。</li>
</ol>
<p><strong>数据格式不同</strong>： </p>
<ol>
<li>RESTful API 使用文本格式来传输数据，通常使用 JSON 或 XML 进行序列化。</li>
<li>RPC 通常使用二进制格式来传输数据，例如 Protocol Buffers（ProtoBuf）或 Apache Thrift。</li>
</ol>
<p><strong>性能不同</strong>：RPC 通常比 RESTful API 更高效。这是因为 RPC 的协议设计更加轻量级，并且它可以对传输的数据进行二进制压缩，使得请求报文体积更小，从而提高传输效率。而 RESTful API 基于 HTTP 协议，其报文头等信息可能使得传输的数据量相对较大，传输效率较低。</p>
<h4 id="RESTful-API-通讯实现"><a href="#RESTful-API-通讯实现" class="headerlink" title="RESTful API 通讯实现"></a>RESTful API 通讯实现</h4><p>RESTful API 目前主流的实现方式有以下两种：</p>
<ul>
<li><strong>RestTemplate</strong>：Spring 内置的用于执行 HTTP 请求的类。</li>
<li><strong>Spring Cloud OpenFegin</strong>：OpenFeign 是 Spring Cloud 对 Feign 库的封装，提供声明式的 HTTP 客户端，简化了服务调用的编码工作。</li>
</ul>
<p><strong>RestTemplate使用</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callOtherService</span><span class="params">(String serviceName)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">"http://"</span> + serviceName + <span class="string">"/api/path"</span>;</span><br><span class="line">    ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Spring Cloud OpenFegin 使用</strong></p>
<p>OpenFegin 引入到项目之后，需要先在 Spring Boot 启动类上添加 @EnableFeignClients 注解.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@FeignClient(name = "service-provider")</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceProviderClient</span> {  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping("/api/hello")</span>  </span><br><span class="line">    String <span class="title function_">hello</span><span class="params">()</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="RestTemplate底层实现及执行流程"><a href="#RestTemplate底层实现及执行流程" class="headerlink" title="RestTemplate底层实现及执行流程"></a>RestTemplate底层实现及执行流程</h4><p><code>RestTemplate</code> 是Spring提供的用于同步client-side HTTP访问的工具。它简化了与http服务的通信并强化了REST原则。</p>
<p><strong>底层实现：</strong></p>
<ul>
<li><strong>HttpMessageConverter</strong>: <code>RestTemplate</code> 使用 <code>HttpMessageConverter</code> 接口的实现来转换HTTP请求和响应。不同的实现可以处理不同的数据格式，比如JSON、XML等。</li>
<li><strong>ClientHttpRequestFactory</strong>: 它负责创建 <code>ClientHttpRequest</code> 对象，用于发送HTTP请求。你可以通过设置不同的 <code>ClientHttpRequestFactory</code> 实现来改变底层的HTTP客户端库，例如使用JDK自带的 <code>HttpURLConnection</code>、Apache的 <code>HttpClient</code> 或OkHttp。</li>
<li><strong>Interceptors</strong>: <code>RestTemplate</code> 支持拦截器（<code>ClientHttpRequestInterceptor</code>），可以在请求发送前或收到响应后进行一些处理。</li>
</ul>
<p><strong>执行流程：</strong></p>
<ol>
<li>创建 <code>RestTemplate</code> 实例。</li>
<li>通过 <code>RestTemplate</code> 发起请求（如 <code>getForObject</code>, <code>postForObject</code> 等）。</li>
<li><code>RestTemplate</code> 使用 <code>HttpMessageConverter</code> 将请求对象转换成合适的HTTP请求格式。</li>
<li>通过 <code>ClientHttpRequestFactory</code> 创建 <code>ClientHttpRequest</code>。</li>
<li>发送HTTP请求到服务器。</li>
<li>服务器返回响应。</li>
<li><code>RestTemplate</code> 使用 <code>HttpMessageConverter</code> 将响应转换成目标对象。</li>
</ol>
<h4 id="OpenFegin底层实现及执行流程"><a href="#OpenFegin底层实现及执行流程" class="headerlink" title="OpenFegin底层实现及执行流程"></a>OpenFegin底层实现及执行流程</h4><p><strong>底层实现</strong></p>
<p><code>Spring Cloud OpenFeign</code> 是基于 <code>Feign</code> 的一个Spring Cloud组件，它通过少量的注解，使得编写Web服务客户端变得更加容易。以下是它的底层实现关键点：</p>
<ol>
<li><strong>动态代理</strong>：<code>OpenFeign</code> 使用Java的动态代理机制，为定义的接口创建代理实例。</li>
<li><strong>注解解析</strong>：<code>OpenFeign</code> 解析接口上的注解，如 <code>@FeignClient</code>，以及方法上的注解，如 <code>@RequestMapping</code>，来构建HTTP请求的详细信息。</li>
<li><strong>请求构建</strong>：根据注解信息构建HTTP请求，包括URL、请求方法、请求头、请求体等。</li>
<li><strong>编码器（Encoder）</strong>：用于将请求对象转换为HTTP请求体。</li>
<li><strong>解码器（Decoder）</strong>：用于将HTTP响应体转换为响应对象。</li>
</ol>
<p><strong>执行流程</strong></p>
<p>以下是 <code>Spring Cloud OpenFeign</code> 的执行流程：</p>
<ol>
<li><strong>定义Feign客户端</strong>：开发者定义一个接口，并使用 <code>@FeignClient</code> 注解标记该接口，指定服务名和其他配置。</li>
<li><strong>扫描与注册</strong>：在应用启动时，<code>OpenFeign</code> 会扫描所有标记了 <code>@FeignClient</code> 的接口，并为每个接口创建一个代理工厂。</li>
<li><strong>创建代理实例</strong>：当第一次调用这些接口时，<code>OpenFeign</code> 会使用代理工厂创建一个动态代理实例。</li>
<li><strong>方法调用</strong>：当调用接口方法时，实际上是通过代理实例进行调用。</li>
<li><strong>构建请求</strong>：代理实例根据接口方法上的注解信息构建HTTP请求，包括请求的URL、方法、头部和体。</li>
<li><strong>发送请求</strong>：代理实例使用底层的HTTP客户端库（如Apache HttpClient或OkHttp）发送HTTP请求到远程服务。</li>
<li><strong>处理响应</strong>：远程服务返回响应后，<code>OpenFeign</code> 使用解码器将响应体转换为Java对象。</li>
<li><strong>返回结果</strong>：将转换后的对象返回给调用者。</li>
<li><strong>异常处理</strong>：如果在请求过程中发生异常，<code>OpenFeign</code> 会使用错误解码器（<code>ErrorDecoder</code>）来处理异常情况。</li>
</ol>
<h4 id="RPC通讯实现"><a href="#RPC通讯实现" class="headerlink" title="RPC通讯实现"></a>RPC通讯实现</h4><p>RPC 目前主流的通讯方式有以下两种：</p>
<ul>
<li><strong>Dubbo</strong>：阿里巴巴公司开源的一个 Java 高性能优秀的服务框架，它基于 TCP 或 HTTP 的 RPC 远程过程调用，支持负载均衡和容错，自动服务注册和发现。</li>
<li><strong>gRPC</strong>：Google 开发的高性能、通用的开源 RPC 框架，它主要面向移动应用开发并基于 HTTP/2 协议标准设计。gRPC 使用 ProtoBuf（Protocol Buffers）作为序列化工具和接口定义语言，要求在调用前需要先定义好接口契约，并使用工具生成代码，然后在代码中调用这些生成的类进行服务调用。</li>
</ul>
<h3 id="2-Gateway过滤器的分类有哪些？"><a href="#2-Gateway过滤器的分类有哪些？" class="headerlink" title="2. Gateway过滤器的分类有哪些？"></a>2. Gateway过滤器的分类有哪些？</h3><p>在 Spring Cloud Gateway 中，过滤器是在请求到达目标服务之前或之后，执行某些特定操作的一种机制。例如，它可以实现对传入的请求进行验证、修改、日志记录、身份验证、流量控制等各种功能。</p>
<p><strong>核心组件</strong></p>
<p>Route：一个 Route 由路由 ID，转发 URI，多个 Predicates 以及多个 Filters 构成。Gateway 上可以配置多个 Routes。处理请求时会按优先级排序，找到第一个满足所有 Predicates 的 Route；<br>Predicate：表示路由的匹配条件，可以用来匹配请求的各种属性，如请求路径、方法、header 等。一个 Route 可以包含多个子 Predicates，多个子 Predicates 最终会合并成一个；<br>Filter：过滤器包括了处理请求和响应的逻辑，可以分为 pre 和 post 两个阶段。多个 Filter 在 pre 阶段会按优先级高到低顺序执行，post 阶段则是反向执行。Gateway 包括两类 Filter。</p>
<ul>
<li>全局 Filter：每种全局 Filter 全局只会有一个实例，会对所有的 Route 都生效。内置全局过滤去和全局过滤器。</li>
<li>局部Filter：路由 Filter 是针对 Route 进行配置的，不同的 Route 可以使用不同的参数，因此会创建不同的实例。</li>
</ul>
<h3 id="3-限流的算法有哪些"><a href="#3-限流的算法有哪些" class="headerlink" title="3. 限流的算法有哪些"></a>3. 限流的算法有哪些</h3><h4 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h4><p>计数器算法是在一定的时间间隔里，记录请求次数，当请求次数超过该时间限制时，就把计数器清零，然后重新计算。当请求次数超过间隔内的最大次数时，拒绝访问。计数器算法的实现比较简单，但<strong>存在“突刺现象”</strong>。突刺现象是指，比如限流 QPS（每秒查询率）为 100，算法的实现思路就是从第一个请求进来开始计时，在接下来的 1 秒内，每来一个请求，就把计数加 1，如果累加的数字达到了 100，后续的请求就会被全部拒绝。等到 1 秒结束后，把计数恢复成 0，重新开始计数。如果在单位时间 1 秒内的前 10 毫秒处理了 100 个请求，那么后面的 990 毫秒会请求拒绝所有的请求，我们把这种现象称为“突刺现象”。</p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>漏桶算法的实现思路是，有一个固定容量的漏桶，水流（请求）可以按照任意速率先进入到漏桶里，但漏桶总是以固定的速率匀速流出，当流入量过大的时候（超过桶的容量），则多余水流（请求）直接溢出。</p>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌按固定的速率被放入令牌桶中，桶中最多存放 N 个令牌（Token），当桶装满时，新添加的令牌被丢弃或拒绝。当请求到达时，将从桶中删除 1 个令牌。令牌桶中的令牌不仅可以被移除，还可以往里添加，所以为了保证接口随时有数据通过，必须不停地往桶里加令牌。由此可见，往桶里加令牌的速度就决定了数据通过接口的速度。我们通过控制往令牌桶里加令牌的速度从而控制接口的流量。 </p>
<p>【注】漏桶算法VS令牌桶算法</p>
<p>漏桶算法是按照常量固定速率流出请求的，流入请求速率任意，当流入的请求数累积到漏桶容量时，新流入的请求被拒绝。令牌桶算法是按照固定速率往桶中添加令牌的，请求是否被处理需要看桶中的令牌是否足够，当令牌数减为零时，拒绝新的请求。令牌桶可以应对流量突增。</p>
<h3 id="3-Sentinel如何实现限流"><a href="#3-Sentinel如何实现限流" class="headerlink" title="3. Sentinel如何实现限流"></a>3. Sentinel如何实现限流</h3><p>限流是一种通过控制系统对外提供的资源、服务或接口的访问数量或速率，以保护系统免受过载的一种策略。它的目的是确保系统能够在承受范围内提供稳定和可靠的服务，避免因过多的请求而导致系统崩溃、资源耗尽或响应延迟过高的情况发生。</p>
<p>在 Sentinel 中，实现限流的方法有以下两种：</p>
<ol>
<li><strong>通过代码方法实现限流。</strong></li>
<li><strong>通过 Sentinel 控制台设置实现限流。</strong></li>
</ol>
<h4 id="通过代码限流"><a href="#通过代码限流" class="headerlink" title="通过代码限流"></a>通过代码限流</h4><ol>
<li>定义资源</li>
</ol>
<p>通过代码定义资源，SphU.entry(“resourceName”) 来定义资源</p>
<p>通过注解定义资源，<strong>通过注解 @SentinelResource 也可以实现资源的定义</strong></p>
<ol start="2">
<li>定义限流规则</li>
</ol>
<p>在 Spring Boot 项目中，只需要将限流规则添加到项目启动时执行即可</p>
<h3 id="4-网关如何实现限流"><a href="#4-网关如何实现限流" class="headerlink" title="4. 网关如何实现限流"></a>4. 网关如何实现限流</h3><h4 id="限流的常见策略"><a href="#限流的常见策略" class="headerlink" title="限流的常见策略"></a>限流的常见策略</h4><p><strong>请求速率限流</strong>：限制单位时间内系统可以接受的最大请求数量。例如，每秒最多处理 100 个请求。当请求超过限制时，可以选择拒绝或延迟处理这些请求。</p>
<p><strong>并发请求数限流</strong>：限制同时处理的请求数量。例如，限制系统只能同时处理100个并发请求。当并发请求数超过限制时，可以选择拒绝或排队等待。</p>
<p><strong>用户级别限流</strong>：根据用户进行限流，限制每个用户的请求频率或数量。例如，限制每个用户每分钟只能发送 10 个请求。当用户请求超过限制时，可以选择拒绝或延迟处理。</p>
<p><strong>API 级别限流</strong>：根据 API 接口进行限流，限制每个接口的请求频率或数量。例如，限制某个接口每秒只能处理 50 个请求。当接口请求超过限制时，可以选择拒绝或延迟处理。</p>
<h4 id="如何实现限流"><a href="#如何实现限流" class="headerlink" title="如何实现限流"></a>如何实现限流</h4><p>Spring Cloud Gateway 实现限流的方式有两种：</p>
<ol>
<li>使用内置 Filter（过滤器）实现限流。</li>
<li>使用限流组件 Spring Cloud Alibaba Sentinel 或者 Spring Cloud Netflix Hystrix 实现限流。</li>
</ol>
<p>Spring Cloud Gateway 内置的限流器为 RequestRateLimiter GatewayFilter Factory。</p>
<p><strong>Spring Cloud Gateway 支持和 Redis 一起来实现限流功能，它的实现步骤如下：</strong></p>
<ol>
<li><strong>在网关项目中添加 Redis 框架依赖</strong></li>
<li><strong>创建限流规则</strong></li>
<li><strong>配置限流过滤器</strong></li>
</ol>
<p><font color="blue">Spring Cloud Gateway 内置限流功能使用的算法是<strong>令牌桶限流算法</strong>。</font></p>
<h4 id="限流实现原理"><a href="#限流实现原理" class="headerlink" title="限流实现原理"></a>限流实现原理</h4><p>从图中可以看出，所有的请求来了之后，会先走过滤器，只有过滤器通过之后，才能调用后续的内部微服务，这样我们就可以通过过滤器来控制微服务的调用，从而实现限流功能了。</p>
<h3 id="5-限流的实现方式有哪些"><a href="#5-限流的实现方式有哪些" class="headerlink" title="5. 限流的实现方式有哪些"></a>5. 限流的实现方式有哪些</h3><p>在 Java 中，限流的实现方式有很多种，例如以下这些：</p>
<ol>
<li><strong>单机限流</strong>：使用 JUC 下的 Semaphore 限流，或一些常用的框架，例如 Google 的 Guava 框架进行限流，但这种限流方式都是基于 JVM 层面的内存级别的单台机器限流。</li>
<li><strong>网关层限流</strong>：单机限流往往不适用于分布式系统，而分布式系统可以在网关层限流，如 Spring Cloud Gateway 通过 Sentinel、Hystrix 对整个集群进行限流。</li>
<li><strong>Nginx 限流</strong>：通常在网关层的上游，我们会使用 Nginx 一起来配合使用，也就是用户请求会先到 Nginx（或 Nginx 集群），然后再将请求转发给网关，网关再调用其他的微服务，从而实现整个流程的请求调用，因此 Nginx 限流也是分布式系统中常用的限流手段。</li>
</ol>
<h4 id="单机层面限流"><a href="#单机层面限流" class="headerlink" title="单机层面限流"></a>单机层面限流</h4><p>JVM 层面多线程级别的限流可以使用 JUC 下的 Semaphore。想要实现更平滑的单机限流，可以考虑 Google 提供的 Guava 框架</p>
<h4 id="网关层限流"><a href="#网关层限流" class="headerlink" title="网关层限流"></a>网关层限流</h4><p>在 Spring Cloud Gateway 网关层限流，可以借助 Sentinel 等限流框架来实现。</p>
<h4 id="Nginx限流"><a href="#Nginx限流" class="headerlink" title="Nginx限流"></a>Nginx限流</h4><p>Nginx 提供了两种限流手段：</p>
<ul>
<li>通过控制速率来实现限流。</li>
<li>通过控制并发连接数来实现限流。</li>
</ul>
<p><strong>控制速率实现限流</strong></p>
<p>我们需要使用 limit_req_zone 用来限制单位时间内的请求数，即速率限制。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;</span><br><span class="line">server {</span><br><span class="line">  location / {</span><br><span class="line">    limit_req zone=mylimit;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>控制并发数实现限流</strong></p>
<p>利用 limit_conn_zone 和 limit_conn 两个指令即可控制并发数，示例配置如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone=perip:10m;</span><br><span class="line">limit_conn_zone $server_name zone=perserver:10m;</span><br><span class="line">server {</span><br><span class="line">  ...</span><br><span class="line">  limit_conn perip 10;</span><br><span class="line">  limit_conn perserver 100;</span><br><span class="line">}</span><br><span class="line">其中 limit_conn perip 10 表示限制单个 IP 同时最多能持有 10 个连接；limit_conn perserver 100 表示 server 同时能处理并发连接的总数为 100 个。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-如何实现分布式锁"><a href="#6-如何实现分布式锁" class="headerlink" title="6. 如何实现分布式锁"></a>6. 如何实现分布式锁</h3><p>分布式锁通常需要满足以下几个要求</p>
<ol>
<li>互斥性：在任意时刻只能有一个客户端持有锁。</li>
<li>不会发生死锁：即使持有锁的客户端发生了故障，也能保证锁最终会被释放。</li>
<li>具有容错性：分布式锁需要能够容忍节点故障等异常情况，保证系统的稳定性。</li>
</ol>
<p>实现分布式锁的方案：</p>
<ol>
<li><strong>基于数据库实现分布式锁：</strong>可以通过数据库的乐观锁或悲观锁实现分布式锁，但是由于数据库的 IO 操作比较慢，不适合高并发场景。</li>
<li><strong>基于ZooKeeper实现分布式锁：</strong>ZooKeeper 是一个高可用性的分布式协调服务，可以通过它来实现分布式锁。但是使用 ZooKeeper 需要部署额外的服务，增加了系统复杂度。</li>
<li><strong>基于Redis实现的分布式锁：</strong>Redis 是一个高性能的内存数据库，支持分布式部署，可以通过Redis的原子操作实现分布式锁，而且具有高性能和高可用性</li>
</ol>
<p><strong>Zookeeper VS Redis</strong></p>
<p>Redis 和 ZooKeeper 都可以用来实现分布式锁，它们在实现分布式锁的机制和原理上有所不同，具体区别如下：</p>
<ol>
<li><strong>数据存储方式</strong>：<strong>Redis 将锁信息存储在内存中，而 ZooKeeper 将锁信息存储在 ZooKeeper 的节点上</strong>，因此 ZooKeeper 需要更多的磁盘空间。</li>
<li><strong>锁的释放</strong>：<strong>Redis 的锁是通过设置锁的过期时间来自动释放的，而 ZooKeeper 的锁需要手动释放</strong>，如果锁的持有者出现宕机或网络中断等情况，需要等待锁的超时时间才能自动释放。</li>
<li><strong>锁的竞争机制</strong>：<strong>Redis 使用的是单机锁，即所有请求都直接连接到同一台 Redis 服务器，容易发生单点故障</strong>；<strong>而 ZooKeeper 使用的是分布式锁，即所有请求都连接到 ZooKeeper 集群，具有较好的可用性和可扩展性。</strong></li>
<li><strong>一致性</strong>：Redis 的锁是<strong>非严格意义下的分布式锁</strong>，因为在多台机器上运行多个进程时，由于 Redis 的主从同步可能会存在数据不一致的问题；而 ZooKeeper 是<strong>强一致性的分布式系统</strong>，保证了数据的一致性。</li>
<li><strong>性能</strong>：Redis 的性能比 ZooKeeper 更高，因为 Redis 将锁信息存储在内存中，而 ZooKeeper 需要进行磁盘读写操作。</li>
</ol>
<h3 id="7-常见的负载均衡策略有哪些"><a href="#7-常见的负载均衡策略有哪些" class="headerlink" title="7. 常见的负载均衡策略有哪些"></a>7. 常见的负载均衡策略有哪些</h3><p>负载均衡分为<strong>服务器端负载均衡</strong>和<strong>客户端负载均衡</strong>。</p>
<p>服务器端负载均衡指的是存放在服务器端的负载均衡器，例如 Nginx、HAProxy、F5 等。</p>
<p>客户端负载均衡指的是嵌套在客户端的负载均衡器，例如 Ribbon。</p>
<p><strong>常见负载均衡策略</strong></p>
<p>但无论是服务器端负载均衡和客户端负载均衡，它们的负载均衡策略都是相同的，因为负载均衡策略本质上是一种思想。</p>
<p>常见的负载均衡策略有以下几个：</p>
<p><strong>轮询；随机选择；最少连接；加权轮询；IP哈希；加权随机选择；最短响应时间</strong></p>
<ol>
<li><strong>轮询（Round Robin）</strong>：轮询策略按照顺序将每个新的请求分发给后端服务器，依次循环。这是一种最简单的负载均衡策略，适用于后端服务器的性能相近，且每个请求的处理时间大致相同的情况。</li>
<li><strong>随机选择（Random）</strong>：随机选择策略随机选择一个后端服务器来处理每个新的请求。这种策略适用于后端服务器性能相似，且每个请求的处理时间相近的情况，但不保证请求的分发是均匀的。</li>
<li><strong>最少连接（Least Connections）</strong>：最少连接策略将请求分发给当前连接数最少的后端服务器。这可以确保负载均衡在后端服务器的连接负载上均衡，但需要维护连接计数。</li>
<li><strong>IP 哈希（IP Hash）</strong>：IP 哈希策略使用客户端的 IP 地址来计算哈希值，然后将请求发送到与哈希值对应的后端服务器。这种策略可用于确保来自同一客户端的请求都被发送到同一台后端服务器，适用于需要会话保持的情况。</li>
<li><strong>加权轮询（Weighted Round Robin）</strong>：加权轮询策略给每个后端服务器分配一个权重值，然后按照权重值比例来分发请求。这可以用来处理后端服务器性能不均衡的情况，将更多的请求分发给性能更高的服务器。</li>
<li><strong>加权随机选择（Weighted Random）</strong>：加权随机选择策略与加权轮询类似，但是按照权重值来随机选择后端服务器。这也可以用来处理后端服务器性能不均衡的情况，但是分发更随机。</li>
<li><strong>最短响应时间（Least Response Time）</strong>：最短响应时间策略会测量每个后端服务器的响应时间，并将请求发送到响应时间最短的服务器。这种策略可以确保客户端获得最快的响应，适用于要求低延迟的应用。</li>
</ol>
<h3 id="8-分布式事务二阶段和三阶段"><a href="#8-分布式事务二阶段和三阶段" class="headerlink" title="8. 分布式事务二阶段和三阶段"></a>8. 分布式事务二阶段和三阶段</h3><h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>两阶段提交（Two-Phase Commit，简称 2PC）是一种分布式事务协议，确保所有参与者在提交或回滚事务时都处于一致的状态。2PC 协议包含以下两个阶段：</p>
<ol>
<li><strong>准备阶段（prepare phase）</strong>：在这个阶段，事务协调者（Transaction Coordinator）向所有参与者（Transaction Participant）发出准备请求，询问它们是否准备好提交事务。参与者执行所有必要的操作，并回复协调者是否准备好提交事务。如果所有参与者都回复准备好提交事务，协调者将进入下一个阶段。如果任何参与者不能准备好提交事务，协调者将通知所有参与者回滚事务。</li>
<li><strong>提交阶段（commit phase）</strong>：在这个阶段，如果所有参与者都已准备好提交事务，则协调者向所有参与者发送提交请求。参与者执行所有必要的操作，并将其结果记录在持久性存储中。一旦所有参与者都已提交事务，协调者将向它们发送确认请求。如果任何参与者未能提交事务，则协调者将通知所有参与者回滚事务。</li>
</ol>
<p>2PC 协议可以确保分布式事务的原子性和一致性，但是其效率较低，可能会出现阻塞等问题。因此，在实际应用中，可以使用其他分布式事务协议，如 3PC（Three-Phase Commit）或 Paxos 协议来代替。</p>
<p><strong>二阶段提交存在的问题</strong></p>
<ol>
<li><strong>同步阻塞问题：</strong>执行过程中，<strong>所有参与节点都是事务阻塞型的</strong>。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。也就是说从投票阶段到提交阶段完成这段时间，资源是被锁住的。</li>
<li><strong>单点故障：</strong>由于协调者的重要性，<strong>一旦协调者发生故障，参与者会一直阻塞下去。</strong>尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。</li>
<li><strong>数据不一致问题：</strong>在 2PC 最后提交阶段中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交，于是整个分布式系统便出现了数据不一致性的现象。</li>
</ol>
<h4 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h4><p>三阶段提交（Three-Phase Commit，简称3PC）是在 2PC 协议的基础上添加了一个额外的阶段来解决 2PC 协议可能出现的阻塞问题。 3PC 协议包含三个阶段：</p>
<ol>
<li><strong>CanCommit 阶段（询问阶段）</strong>：在这个阶段，<strong>事务协调者（Transaction Coordinator）向所有参与者（Transaction Participant）发出 CanCommit 请求，询问它们是否准备好提交事务。</strong>参与者执行所有必要的操作，并回复协调者它们是否可以提交事务。</li>
<li><strong>PreCommit 阶段（准备阶段）</strong>：<strong>如果所有参与者都回复可以提交事务，则协调者将向所有参与者发送PreCommit 请求，通知它们准备提交事务。</strong>参与者执行所有必要的操作，并回复协调者它们是否已经准备好提交事务。</li>
<li><strong>DoCommit 阶段（提交阶段）</strong>：<strong>如果所有参与者都已经准备好提交事务，则协调者将向所有参与者发送DoCommit 请求，通知它们提交事务。</strong>参与者执行所有必要的操作，并将其结果记录在持久性存储中。<strong>一旦所有参与者都已提交事务，协调者将向它们发送确认请求。如果任何参与者未能提交事务，则协调者将通知所有参与者回滚事务。</strong></li>
</ol>
<p>与 2PC 协议相比，3PC 协议将 CanCommit 阶段（询问阶段）添加到协议中，使参与者能够在 CanCommit 阶段发现并解决可能导致阻塞的问题。这样，3PC 协议能够更快地执行提交或回滚事务，并减少不必要的等待时间。需要注意的是，与 2PC 协议相比，3PC 协议仍然可能存在阻塞的问题。</p>
<h4 id="二阶段提交-VS-三阶段提交"><a href="#二阶段提交-VS-三阶段提交" class="headerlink" title="二阶段提交 VS 三阶段提交"></a>二阶段提交 VS 三阶段提交</h4><p>2PC 和 3PC 是分布式事务中两种常见的协议，3PC 可以看作是 2PC 协议的改进版本，相比于 2PC 它有两点改进：</p>
<ol>
<li><strong>引入了超时机制，同时在协调者和参与者中都引入超时机制</strong>（2PC 只有协调者有超时机制）；</li>
<li><strong>3PC 相比于 2PC 增加了 CanCommit 阶段，可以尽早的发现问题，从而避免了后续的阻塞和无效操作。</strong></li>
</ol>
<p>也就是说，3PC 相比于 2PC，因为引入了超时机制，所以发生阻塞的几率变小了；同时 3PC 把之前 2PC 的准备阶段一分为二，变成了两步，这样就多了一个缓冲阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<h4 id="数据一致性问题和解决方案"><a href="#数据一致性问题和解决方案" class="headerlink" title="数据一致性问题和解决方案"></a>数据一致性问题和解决方案</h4><p>3PC 虽然可以减少同步阻塞问题和单点故障问题，但依然存在数据一致性问题（概率很小），而解决数据一致性问题的方案有很多，比如 <strong>Paxos 算法</strong>或<strong>柔性事物机制</strong>等。</p>
<h5 id="Paxos算法-—-共识算法"><a href="#Paxos算法-—-共识算法" class="headerlink" title="Paxos算法 —- 共识算法"></a>Paxos算法 —- 共识算法</h5><p>Paxos 算法是一种分布式共识算法，用于在分布式系统中实现数据的一致性和共识，保证分布式系统中不同节点之间的数据同步和一致性。 <strong>Paxos 算法由三个角色组成：提议者、接受者和学习者。当一个节点需要发起一个提议时，它会向其他节点发送一个提议，接受者会接收到这个提议，并对其进行处理，可能会拒绝提议，也可能会接受提议。如果有足够多的节点接受了该提议，那么提议就会被确定下来，并且通知给所有学习者，最终所有节点都会达成共识。</strong> Paxos 算法看起来很简单，但它实际上是非常的复杂。 Paxos 算法应用的产品也很多，比如以下几个：</p>
<p>Redis：Redis 是一个内存数据库，使用 Paxos 算法实现了分布式锁服务和主从复制等功能。</p>
<p>MySQL：MySQL 5.7 推出的用来取代传统的主从复制的 MySQL Group Replication 等。</p>
<p>ZooKeeper：ZooKeeper 是一个分布式协调服务，使用 Paxos 算法实现了分布式锁服务和数据一致性等功能。</p>
<h5 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h5><p>柔性事务机制：允许一定时间内不同节点的数据不一致，但要求最终一致的机制。 柔性事物有 TCC 补偿事务、可靠消息事物（MQ 事物）等。</p>
<p>【总结】在分布式事务中，通常使用两阶段或三阶段提交协议来保障分布式事务的正常执行。两阶段协议包含准备阶段和提交阶段，然而它存在同步阻塞问题、单点故障和数据一致性问题。</p>
<p>而三阶段协议可以看作是两阶段协议的改进版，它将两阶段的准备阶段一分为二，多了一个询问阶段，保证了提交阶段之前各参与节点的状态是一致的，同时引入了超时机制，减少了同步阻塞问题发生的几率。但 2PC 和 3PC 都存在数据一致性问题，此时可以采用 Paxos 算法或柔性事务机制等方案来解决事务一致性问题。</p>
<h3 id="9-Nacos"><a href="#9-Nacos" class="headerlink" title="9. Nacos"></a>9. Nacos</h3><p>Nacos 作为目前主流的微服务中间件，包含了两个顶级的微服务功能：<strong>配置中心和注册中心。</strong></p>
<h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><p>配置中心是一种集中化管理配置的服务，通俗易懂的说就是将本地配置文件“云端化”。 这样做的好处有以下几个:</p>
<ol>
<li><strong>集中管理配置信息</strong>：配置中心将不同服务的配置信息集中放在一起进行管理，实现了配置信息的集中存储。</li>
<li><strong>动态更新配置</strong>：配置中心中的配置信息可以通过操作界面或 API 进行动态更新，无需重启服务就可以应用最新的配置信息。</li>
<li><strong>配置信息共享</strong>：将配置集中在配置中心中，不同的服务实例可以共享同一套配置信息。</li>
<li><strong>配置信息安全</strong>：配置中心可以对配置信息提供安全管理、权限控制等管理功能。</li>
<li><strong>信息追溯</strong>：支持配置版本管理、历史记录等管理功能</li>
</ol>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>注册中心（Registry）是一种用于服务发现和服务注册的分布式系统组件。它是在微服务架构中起关键作用的一部分，用于管理和维护服务实例的信息以及它们的状态。注册中心充当了服务之间的中介和协调者，它的主要功能有以下这些：</p>
<ol>
<li><p><strong>服务注册</strong>：服务提供者将自己的服务实例信息（例如 IP 地址、端口号、服务名称等）注册到注册中心。通过注册中心，服务提供者可以将自己的存在告知其他服务。</p>
</li>
<li><p><strong>服务发现</strong>：服务消费者通过向注册中心查询服务信息，获取可用的服务实例列表。通过注册中心，服务消费者可以找到并连接到需要调用的服务。</p>
</li>
<li><p><strong>健康检查与负载均衡</strong>：注册中心可以定期检查注册的服务实例的健康状态，并从可用实例中进行负载均衡，确保请求可以被正确地转发到可用的服务实例。</p>
</li>
<li><p><strong>动态扩容与缩容</strong>：在注册中心中注册的服务实例信息可以方便地进行动态的增加和减少。当有新的服务实例上线时，可以自动地将其注册到注册中心。当服务实例下线时，注册中心会将其从服务列表中删除。</p>
</li>
</ol>
<p>使用注册中心有一下优势和好处：</p>
<p><strong>服务自动发现和负载均衡</strong>：服务消费者无需手动配置目标服务的地址，而是通过注册中心动态获取可用的服务实例，并通过负载均衡算法选择合适的实例进行调用。</p>
<p><strong>服务弹性和可扩展性</strong>：新的服务实例可以动态注册，并在发生故障或需要扩展时快速提供更多的实例，从而提供更高的服务弹性和可扩展性。</p>
<p><strong>中心化管理和监控</strong>：注册中心提供了中心化的服务管理和监控功能，可以对服务实例的状态、健康状况和流量等进行监控和管理。</p>
<p><strong>降低耦合和提高灵活性</strong>：服务间的通信不再直接依赖硬编码的地址，而是通过注册中心进行解耦，使得服务的部署和变更更加灵活和可控。</p>
<h4 id="Nacos注册中心有几种调用方式"><a href="#Nacos注册中心有几种调用方式" class="headerlink" title="Nacos注册中心有几种调用方式"></a>Nacos注册中心有几种调用方式</h4><p>当 Nacos 中注册了 Restful 接口时（一种软件架构风格，它是基于标准的 HTTP 协议和 URI 的一组约束和原则），其调用方式主要有以下两种：</p>
<ol>
<li><strong>使用 RestTemplate + Spring Cloud LoadBalancer</strong><ol>
<li>添加依赖：nacos + loadbalancer</li>
<li>设置配置文件</li>
<li>编写调用代码<ol>
<li>给 RestTemplate 增加 LoadBalanced 支持</li>
<li>使用 RestTemplate 调用接口</li>
</ol>
</li>
</ol>
</li>
<li><strong>使用 OpenFeign + Spring Cloud LoadBalancer</strong><ol>
<li>添加依赖：nacos + openfeign + loadbalancer</li>
<li>设置配置文件</li>
<li>开启 openfeign 支持</li>
<li>编写 service 代码</li>
<li>调用 service 代码</li>
</ol>
</li>
</ol>
<h4 id="客户端与服务端负载均衡"><a href="#客户端与服务端负载均衡" class="headerlink" title="客户端与服务端负载均衡"></a>客户端与服务端负载均衡</h4><p>客户端负载均衡器通常位于服务的消费者端，主要负责将请求合理地分发给不同的服务提供者。工作原理是客户端在发起请求前，通过负载均衡算法选择一个合适的服务实例进行请求。客户端根据服务实例的健康度、负载状况等指标来决定选择哪个服务实例。<strong>常见的客户端负载均衡器有 Ribbon、Feign 等。</strong></p>
<p>服务端负载均衡器通常被称为反向代理服务器或负载均衡器，它位于服务的提供者端，接收客户端的请求，并根据一定的负载均衡策略将请求分发给后端的多个服务实例。工作原理是将客户端的请求集中到负载均衡器，由负载均衡器将请求分发给多台服务提供者。<strong>常见的服务器端负载均衡器有 Nginx、HAProxy 等。</strong></p>
<p><strong>客户端负载均衡 VS 服务端负载均衡</strong></p>
<ul>
<li>客户端负载均衡器的优点是可以实现本地的负载均衡算法，避免了对注册中心的频繁调用，降低了网络开销。它的缺点是每个客户端都需要集成负载均衡器，导致代码冗余和维护复杂性。</li>
<li>服务器负载均衡器的优点是可以集中管理请求流量，提供一致的负载均衡策略和配置，对客户端透明。它的缺点是服务器端负载均衡器通常需要独立部署和配置，增加了系统的复杂性和维护成本。并且它很可能成为整个系统的瓶颈（因为客户端需要频繁的调用），所以此时需要考虑其性能和可靠性等问题。</li>
</ul>
<p><strong>Nacos内置了两种负载均衡策略</strong>：</p>
<ol>
<li><strong>基于权重的负载均衡策略</strong></li>
<li><strong>基于第三方 CMDB（地域就近访问）标签的负载均衡策略</strong></li>
</ol>
<h3 id="10-服务熔断"><a href="#10-服务熔断" class="headerlink" title="10. 服务熔断"></a>10. 服务熔断</h3><p>服务熔断是一种微服务架构中的设计模式，用于在服务之间的通信出现故障时，防止故障的蔓延，保护系统的稳定性和可靠性。熔断器会监控对特定服务的调用情况，当调用失败率达到一定阈值时，熔断器会打开，停止向该服务发起请求，直接返回错误响应，避免等待超时或者无效响应。</p>
<p>服务熔断的核心思想是通过监控服务调用情况，及时发现服务故障，尽早响应，避免服务雪崩效应。在实际应用中，可以通过设置熔断器的阈值、超时时间、熔断器状态等参数来控制熔断的条件和行为。</p>
<h3 id="11-框架源码"><a href="#11-框架源码" class="headerlink" title="11. 框架源码"></a>11. 框架源码</h3><h4 id="Spring-Boot源码"><a href="#Spring-Boot源码" class="headerlink" title="Spring Boot源码"></a>Spring Boot源码</h4><p>Spring Boot 在收到请求之后，<strong>会先执行前端控制器 DispatcherServlet，并调用其父类 FrameworkServlet 中的 service 方法</strong>，其核心源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override the parent class implementation in order to intercept PATCH requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpMethod</span> <span class="variable">httpMethod</span> <span class="operator">=</span> HttpMethod.resolve(request.getMethod());</span><br><span class="line">    <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="literal">null</span>) {</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">super</span>.service(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>继续往下看，<strong>processRequest</strong> 实现源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line"> <span class="comment">// 省略一堆初始化配置</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">// 真正执行逻辑的方法</span></span><br><span class="line">       doService(request, response);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">catch</span> (ServletException | IOException ex) {</span><br><span class="line">       ...</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>doService 实现源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></tbody></table></figure>

<p>doService 是抽象方法，由<strong>其子类 DispatcherServlet 来重写实现</strong>，其核心源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// 省略初始化过程...</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">		<span class="comment">// 省略其他...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时就进入到了 DispatcherServlet 中的 doDispatch 方法了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// 获取原生请求</span></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="comment">// 获取Handler执行链</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 是否为文件上传请求, 默认为false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 检查是否为文件上传请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">// 获取能处理此请求的Handler</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) {</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            <span class="comment">// 获取适配器</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) {</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 执行拦截器（链）的前置处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 真正的执行对应方法</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 忽略其他...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上述的源码我们可以看到，<strong>请求的核心代码都在 doDispatch 中</strong>，他里面包含的主要执行流程有以下这些：</p>
<ol>
<li><strong>调用 HandlerExecutionChain 获取处理器</strong>：DispatcherServlet 首先调用 getHandler 方法，通过 HandlerMapping 获取请求对应的 HandlerExecutionChain 对象，包含了处理器方法和拦截器列表。</li>
<li><strong>调用 HandlerAdapter 执行处理器方法</strong>：DispatcherServlet 使用 HandlerAdapter 来执行处理器方法。根据 HandlerExecutionChain 中的处理器方法类型不同，选择对应的 HandlerAdapter 进行处理。常用的适配器有 RequestMappingHandlerAdapter 和 HttpRequestHandlerAdapter。</li>
<li><strong>解析请求参数</strong>：DispatcherServlet 调用 HandlerAdapter 的 handle 方法，解析请求参数，并将解析后的参数传递给处理器方法执行。</li>
<li><strong>调用处理器方法</strong>：DispatcherServlet 通过反射机制调用处理器方法，执行业务逻辑。</li>
<li><strong>处理拦截器</strong>：在调用处理器方法前后，DispatcherServlet 会调用拦截器的 preHandle 和 postHandle方法进行相应的处理。</li>
<li><strong>渲染视图</strong>：处理器方法执行完成后，DispatcherServlet 会通过 ViewResolver 解析视图名称，找到对应的 View 对象，并将模型数据传递给 View 进行渲染。</li>
<li><strong>生成响应</strong>：View 会将渲染后的视图内容生成响应数据。</li>
</ol>
<h3 id="12-如何解决跨域问题"><a href="#12-如何解决跨域问题" class="headerlink" title="12. 如何解决跨域问题"></a>12. 如何解决跨域问题</h3><p>跨域问题是浏览器为了保护用户的信息安全，实施了同源策略（Same-Origin Policy），即只允许页面请求同源（相同协议、域名和端口）的资源，当 JavaScript 发起的请求跨越了同源策略，即请求的目标与当前页面的域名、端口、协议不一致时，浏览器会阻止请求的发送或接收。</p>
<p><strong>如何解决跨域问题</strong></p>
<ol>
<li><strong>应用层面解决</strong>：例如 Spring Boot 项目中解决跨域问题。</li>
<li><strong>反向代理解决</strong>：例如 Nginx 中解决跨域问题。</li>
<li><strong>网关中解决</strong>：例如 Spring Cloud Gateway 中解决跨域问题。</li>
</ol>
<h4 id="Spring-Boot-中解决跨域问题"><a href="#Spring-Boot-中解决跨域问题" class="headerlink" title="Spring Boot 中解决跨域问题"></a>Spring Boot 中解决跨域问题</h4><ol>
<li>使用 @CrossOrigin 注解实现跨域【局域类跨域】</li>
</ol>
<p>使用 @CrossOrigin 注解可以轻松的实现跨域，此注解既可以修饰类，也可以修饰方法。当修饰类时，表示此类中的所有接口都可以跨域；当修饰方法时，表示此方法可以跨域，它的实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin(origins = "*")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> {</span><br><span class="line">    <span class="meta">@RequestMapping("/test")</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;() {{</span><br><span class="line">            put(<span class="string">"state"</span>, <span class="number">200</span>);</span><br><span class="line">            put(<span class="string">"data"</span>, <span class="string">"success"</span>);</span><br><span class="line">            put(<span class="string">"msg"</span>, <span class="string">""</span>);</span><br><span class="line">        }};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用此方式只能实现局部跨域，当一个项目中存在多个类的话，使用此方式就会比较麻烦（需要给所有类上都添加此注解）。</strong></p>
<ol start="2">
<li>通过配置文件实现跨域【全局跨域】</li>
</ol>
<p>通过设置配置文件的方式就可以实现全局跨域了，它的实现步骤如下：</p>
<ul>
<li>创建一个新配置文件。</li>
<li>添加 @Configuration 注解，实现 WebMvcConfigurer 接口。</li>
<li>重写 addCorsMappings 方法，设置允许跨域的代码。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 一定不要忽略此注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> {</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>) <span class="comment">// 所有接口</span></span><br><span class="line">        .allowCredentials(<span class="literal">true</span>) <span class="comment">// 是否发送 Cookie</span></span><br><span class="line">        .allowedOriginPatterns(<span class="string">"*"</span>) <span class="comment">// 支持域</span></span><br><span class="line">        .allowedMethods(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>}) <span class="comment">// 支持方法</span></span><br><span class="line">        .allowedHeaders(<span class="string">"*"</span>)</span><br><span class="line">        .exposedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><p>通过 CorsFilter 对象实现跨域【全局跨域】</p>
</li>
<li><p>通过 Response 对象实现跨域【局域方法跨域】</p>
</li>
</ol>
<p>此方式是解决跨域问题最原始的方式，但它可以支持任意的 Spring Boot 版本（早期的 Spring Boot 版本也是支持的）。但此方式也是局部跨域，它应用的范围最小，设置的是方法级别的跨域，它的具体实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> {</span><br><span class="line">    <span class="meta">@RequestMapping("/test")</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title function_">test</span><span class="params">(HttpServletResponse response)</span> {</span><br><span class="line">        <span class="comment">// 设置跨域</span></span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;() {{</span><br><span class="line">            put(<span class="string">"state"</span>, <span class="number">200</span>);</span><br><span class="line">            put(<span class="string">"data"</span>, <span class="string">"success"</span>);</span><br><span class="line">            put(<span class="string">"msg"</span>, <span class="string">""</span>);</span><br><span class="line">        }};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="5">
<li>通过实现 ResponseBodyAdvice 实现跨域【全局跨域】</li>
</ol>
<h4 id="Nginx中解决跨域"><a href="#Nginx中解决跨域" class="headerlink" title="Nginx中解决跨域"></a>Nginx中解决跨域</h4><p> 在Nginx服务器的配置文件中添加以下代码：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  your_domain.com;</span><br><span class="line">    location /api {</span><br><span class="line">        # 允许跨域请求的域名，* 表示允许所有域名访问</span><br><span class="line">        add_header 'Access-Control-Allow-Origin' '*';</span><br><span class="line"></span><br><span class="line">        # 允许跨域请求的方法</span><br><span class="line">        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';</span><br><span class="line"></span><br><span class="line">        # 允许跨域请求的自定义 Header</span><br><span class="line">        add_header 'Access-Control-Allow-Headers' 'Origin, X-Requested-With, Content-Type, Accept';</span><br><span class="line"></span><br><span class="line">        # 允许跨域请求的 Credential</span><br><span class="line">        add_header 'Access-Control-Allow-Credentials' 'true';</span><br><span class="line"></span><br><span class="line">        # 预检请求的存活时间，即 Options 请求的响应缓存时间</span><br><span class="line">        add_header 'Access-Control-Max-Age' 3600;</span><br><span class="line"></span><br><span class="line">        # 处理预检请求</span><br><span class="line">        if ($request_method = 'OPTIONS') {</span><br><span class="line">            return 204;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    # 其他配置...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>location /api 代表配置针对 /api 路径的请求进行跨域设置。可以根据具体需要修改 location 的值和其他相关参数。配置中的 add_header 指令用于设置响应头部，常用的响应头部包括以下这些：</p>
<ul>
<li><strong>Access-Control-Allow-Origin</strong>：用于指定允许跨域的域名，可以设置为 * 表示允许所有域名访问。</li>
<li><strong>Access-Control-Allow-Methods</strong>：用于指定允许的跨域请求的方法，例如 GET、POST、OPTIONS 等。</li>
<li><strong>Access-Control-Allow-Headers</strong>：用于指定允许的跨域请求的自定义 Header。</li>
<li><strong>Access-Control-Allow-Credentials</strong>：用于指定是否允许跨域请求发送和接收 Cookie。</li>
<li><strong>Access-Control-Max-Age</strong>：用于设置预检请求（OPTIONS 请求）的响应缓存时间。</li>
</ul>
<h4 id="网关中解决跨域"><a href="#网关中解决跨域" class="headerlink" title="网关中解决跨域"></a>网关中解决跨域</h4><p>Spring Cloud Gateway 中解决跨域问题可以通过以下两种方式实现：</p>
<ol>
<li><strong>通过在配置文件中配置跨域实现。</strong></li>
<li><strong>通过在框架中添加 CorsWebFilter 来解决跨域问题。</strong></li>
</ol>
<p>在 application.yml 或 application.properties 中添加以下配置：</p>
<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">'[/**]'</span><span class="string">:</span> <span class="comment"># 这里的'/**'表示对所有路由生效，可以根据需要调整为特定路径</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="string">"*"</span> <span class="comment"># 允许所有的源地址，也可以指定具体的域名</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的 HTTP 方法类型</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">OPTIONS</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">"*"</span> <span class="comment"># 允许所有的请求头，也可以指定具体的请求头</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带凭证（cookies）</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">3600</span> <span class="comment"># CORS预检请求的有效期（秒）</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>allowedOrigins</strong>: 设置允许访问的来源域名列表，”*” 表示允许任何源。</p>
<p><strong>allowedMethods</strong>: 指定哪些HTTP方法可以被用于跨域请求。</p>
<p><strong>allowedHeaders</strong>: 客户端发送的请求头列表，”*” 表示允许任何请求头。</p>
<p><strong>allowCredentials</strong>: 当设为 true 时，允许浏览器在发起跨域请求时携带认证信息（例如 cookies）。</p>
<p><strong>maxAge</strong>: 预检请求的结果可以在客户端缓存的最大时间。</p>
<p>通过这样的配置，Spring Cloud Gateway 网关将自动处理所有经过它的跨域请求，并添加相应的响应头，从而允许前端应用执行跨域请求。</p>
<p><strong>添加CorsWebFilter来解决跨域问题</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalCorsConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">// 这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改</span></span><br><span class="line">        config.addAllowedOriginPattern(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 放行的请求头</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 放行的请求类型，有 GET, POST, PUT, DELETE, OPTIONS</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">"*"</span>); </span><br><span class="line">        <span class="comment">// 暴露头部信息</span></span><br><span class="line">        config.addExposedHeader(<span class="string">"*"</span>); </span><br><span class="line">        <span class="comment">// 是否允许发送 Cookie</span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>); </span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>【总结】跨域问题可以在网关层、反向代理层或应用层来解决，而它们的使用优先级是：<strong>网关层 &gt; 代理层 &gt; 应用层</strong>。因为越靠前覆盖范围就越大，解决跨域问题就越容易。</p>
<h3 id="13-如何实现全链路灰度发布"><a href="#13-如何实现全链路灰度发布" class="headerlink" title="13. 如何实现全链路灰度发布"></a>13. 如何实现全链路灰度发布</h3><p>灰度发布（Gray Release，也称为灰度发布或金丝雀发布）是指在软件或服务发布过程中，将新版本的功能或服务以较小的比例引入到生产环境中，仅向部分用户或节点提供新功能的一种发布策略。</p>
<p>在传统的全量发布中，新版本的功能会一次性全部部署到所有的用户或节点上。然而，这种方式潜在的风险是，如果新版本存在缺陷或问题，可能会对所有用户或节点产生严重的影响，导致系统崩溃或服务不可用。</p>
<p>相比之下，灰度发布采用较小的规模，并逐步将新版本的功能引入到生产环境中，仅向一小部分用户或节点提供新功能。通过持续监测和评估，可以在发现问题时及时回滚或修复。这种逐步引入新版本的方式可以降低风险，并提高系统的稳定性和可靠性。</p>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h1 id="7-30"><a href="#7-30" class="headerlink" title="7.30"></a>7.30</h1><h3 id="Copy-On-Write-技术"><a href="#Copy-On-Write-技术" class="headerlink" title="Copy On Write 技术"></a>Copy On Write 技术</h3><p><strong>Copy On Write (写时复制) 是一种延迟复制的技术，用于再多个线程或进程之间共享资源时减少内存复制成本。</strong></p>
<p>基本思想：在创建拷贝或修改资源之前，不会真正的进行复制操作（懒汉模式），而是共享同一份资源的只读副本，直到某个线程（或进程）试图修改资源时，才会对资源进行复制操作。 这种延迟复制的策略可以减少资源复制的开销，一定程度提高了性能和效率。</p>
<p>:blue_book: <strong>Java中的Copy On Write</strong></p>
<p>Java 中使用 COW 技术是在并发容器中，这种技术的实现容器有两个：<strong>CopyOnWriteArrayList 和 CopyOnWriteArraySet</strong>。 适合多读少写的场景</p>
<p>这两个集合是这样使用 COW 技术的，<strong>当有数据写入操作时，会先复制一个新数组进行操作，等写完之后，再将原数组的地址赋值成新数组</strong></p>
<p><strong>在添加的时候也会使用锁，如果不使用锁的话，在多线程写入时，可能会出现多个副本。</strong>而加锁之后，会先复制一个新数组，进行写入操作，之后再将原数组指向新数组，整个添加操作执行完了。</p>
<p>:blue_book: <strong>Redis中的Copy On Write</strong></p>
<p>单线程的 Redis 想要解决一边响应主线程的任务，一边持久化数据，依靠的就是 COW 技术，具体来说就是依赖系统的 fork 函数的 COW 实现的。</p>
<p>COW 技术的使用过程是这样的：</p>
<ol>
<li><strong>在执行 RDB 持久化时，Redis 进程会 fork 一个子进程来执行持久化，该过程是阻塞的。</strong></li>
<li>当 fork 过程完成后，父进程会继续接收客户端的命令。</li>
<li><strong>此时子进程与 Redis 主进程共享内存中的数据，但是子进程并不会修改内存中的数据，而是不断的遍历读取并写入数据到磁盘，也就是持久化数据的过程。</strong></li>
<li>然而 Redis 主进程则不一样，它需要响应客户端的命令，<strong>如果收到写入数据的操作请求，主进程就会使用 COW 机制将数据先复制再修改</strong>。</li>
<li>而此时，子进程使用的数据页并不会发生任何改变，依然是 fork 时的数据，继续进行持久化。</li>
</ol>
<h3 id="CAS算法（比较与交换）"><a href="#CAS算法（比较与交换）" class="headerlink" title="CAS算法（比较与交换）"></a>CAS算法（比较与交换）</h3><p>CAS是一个原子操作（即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，知道操作成功），<strong>一共有三个操作数：用一个预期值E和要更新的变量值V进行比较，两值相等才会用新值N来更新V的值，如果不等，说明已经有其他线程更新了V，则当前线程放弃更新。</strong>失败的线程可以放弃操作也可以再次尝试。</p>
<p>CAS算法存在什么问题：</p>
<ol>
<li><strong>ABA问题</strong>：解决思路，<strong>追加版本号或者时间戳</strong></li>
<li><strong>循环时间长开销大：</strong>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功，会给 CPU 带来非常大的执行开销。</li>
<li>只能保证一个共享变量的原子操作：从JDK 1.5 开始，提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</li>
</ol>
<h1 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h1><h3 id="1-JWT"><a href="#1-JWT" class="headerlink" title="1. JWT"></a>1. JWT</h3><h4 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h4><p>JWT 由三部分组成：<strong>头部（Header）、载荷（Payload）和签名（Signature）</strong></p>
<ol>
<li><p><strong>头部（Header）</strong>：包含了关于<strong>生成该 JWT 的信息</strong>以及<strong>所使用的算法类型</strong>。</p>
</li>
<li><p><strong>载荷（Payload）</strong>：包含了要传递的数据，例如身份信息和其他附属数据。JWT 官方规定了 <strong>7 个字段</strong>，可供使用： </p>
<p>iss (Issuer)：签发者；sub (Subject)：主题；aud (Audience)：接收者；exp (Expiration time)：过期时间。</p>
<p>nbf (Not Before)：生效时间；iat (Issued At)：签发时间；jti (JWT ID)：编号。</p>
</li>
<li><p><strong>签名（Signature）</strong>：使用密钥对头部和载荷进行签名，以验证其完整性。</p>
</li>
</ol>
<h4 id="JWT工作原理"><a href="#JWT工作原理" class="headerlink" title="JWT工作原理"></a>JWT工作原理</h4><p>JWT 工作原理包含三部分：<strong>生成JWT;传输JWT；验证JWT</strong>。</p>
<p><strong>1.生成JWT：</strong>在用户登录时，当服务器端验证了用户名和密码的正确性后，会根据用户的信息，如用户 ID 和用户名称，加上服务器端存储的 JWT 秘钥一起来生成一个 JWT 字符串，也就是我们所说的 Token，这个 Token 是 Encoded 编码过的，类似于：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></tbody></table></figure>

<p>Decoded 解码后会得到三部分内容：<strong>头部（Header）+载荷（Payload）+签名（Signature）</strong>。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头部（Header）：包含了关于生成该 JWT 的信息以及所使用的算法类型。</span><br><span class="line">载荷（Payload）：包含了要传递的数据，例如身份信息和其他附属数据。</span><br><span class="line">签名（Signature）：使用密钥对头部和载荷进行签名，以验证其完整性。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2.传输JWT</strong>: <strong>JWT 通常存储在客户端的 Cookie、LocalStorage、SessionStorage 等位置</strong>，客户端在每次请求时把 JWT <strong>放在 Authorization 头中或作为参数传递给服务器端.</strong></p>
<p><strong>3.验证JWT</strong></p>
<ol>
<li><p>服务器端接收到 JWT 的 Token 后，<strong>会先将 Token Decoded 解码</strong>，之后会<strong>得到头部（Header）+载荷（Payload）+签名（Signature）</strong>。</p>
</li>
<li><p>然后服务器端会使用它本地存储的秘钥，以及头部（Header）中的加密算法和载荷（Payload）中的信息<strong>进行重新加密，得到一个新的签名。</strong></p>
</li>
<li><p>最后会判断 Token 的真伪，<strong>用上一步新生成的签名和 Decoded 解码得到的签名（Signature）进行判断，如果二者一致，则说明当前的 Token 有效性的、完整的，可以执行后续的操作了</strong>，否则则返回 Token 错误。当然在这一步判断时，我们通常也要看载荷（Payload）中的过期时间是否有效，如果无效，则需要提示用户重新登录</p>
</li>
</ol>
<h4 id="JWT优势"><a href="#JWT优势" class="headerlink" title="JWT优势"></a>JWT优势</h4><p>JWT 相较于传统的基于会话（Session）的认证机制，具有以下优势：</p>
<ol>
<li><strong>无需服务器存储状态</strong>：传统的基于会话的认证机制需要服务器在会话中存储用户的状态信息，包括用户的登录状态、权限等。而使用 JWT，服务器无需存储任何会话状态信息，所有的认证和授权信息都包含在 JWT 中，使得系统可以更容易地进行水平扩展。</li>
<li><strong>跨域支持</strong>：由于 JWT 包含了完整的认证和授权信息，因此可以轻松地在多个域之间进行传递和使用，实现跨域授权。</li>
<li><strong>适应微服务架构</strong>：在微服务架构中，很多服务是独立部署并且可以横向扩展的，这就需要保证认证和授权的无状态性。使用 JWT 可以满足这种需求，每次请求携带 JWT 即可实现认证和授权。</li>
<li><strong>自包含</strong>：JWT 包含了认证和授权信息，以及其他自定义的声明，这些信息都被编码在 JWT 中，在服务端解码后使用。JWT 的自包含性减少了对服务端资源的依赖，并提供了统一的安全机制。</li>
<li><strong>扩展性</strong>：JWT 可以被扩展和定制，可以按照需求添加自定义的声明和数据，灵活性更高。</li>
</ol>
<p>使用 JWT 相较于传统的基于会话的认证机制，<strong>可以减少服务器存储开销和管理复杂性，实现跨域支持和水平扩展，并且更适应无状态和微服务架构。</strong></p>
<h4 id="JWT如何实现自动续期？"><a href="#JWT如何实现自动续期？" class="headerlink" title="JWT如何实现自动续期？"></a>JWT如何实现自动续期？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_54187478/article/details/136962924">https://blog.csdn.net/m0_54187478/article/details/136962924</a></p>
<h3 id="2-如何优化大表的查询速度"><a href="#2-如何优化大表的查询速度" class="headerlink" title="2. 如何优化大表的查询速度"></a>2. 如何优化大表的查询速度</h3><h4 id="分库分表的实现"><a href="#分库分表的实现" class="headerlink" title="分库分表的实现"></a>分库分表的实现</h4><p>目前市面上分库分表的主要实现技术有以下几个：</p>
<ol>
<li><strong>ShardingSphere</strong>：ShardingSphere 是一个功能丰富的开源分布式数据库中间件，提供了完整的分库分表解决方案。它支持主流关系型数据库（如 MySQL、Oracle、SQL Server 等），提供了分片、分布式事务、读写分离、数据治理等功能。ShardingSphere 具有灵活的配置和扩展性，支持多种分片策略，使用简单方便，项目地址：<a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/">https://shardingsphere.apache.orgopen in new window</a></li>
<li><strong>MyCAT</strong>：MyCAT（MySQL Clustering and Advancement Toolkit）是一个开源的分布式数据库中间件，特别适合于大规模的分库分表应用。它支持 MySQ L和 MycatSQL，提供了分片、读写分离、分布式事务等功能。MyCAT 具有高性能、高可用性、可扩展性和易用性的特点，广泛应用于各种大型互联网和电商平台，项目地址：<a target="_blank" rel="noopener" href="https://github.com/MyCATApache/Mycat2">https://github.com/MyCATApache/Mycat2open in new window</a></li>
<li><strong>TDDL</strong>：TDDL（Taobao Distributed Data Layer）是阿里巴巴开源的分库分表中间件。它为开发者提供了透明的分库分表解决方案，可以将数据按照指定的规则分布到不同的数据库和表中。TDDL 支持 MyISAM 和 InnoDB 引擎，提供了读写分离、动态扩容、数据迁移等功能，项目地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/tb_tddl">https://github.com/alibaba/tb_tddlopen in new window</a></li>
<li><strong>Vitess</strong>：Vitess 是一个由 YouTube 开发和维护的分布式数据库集群中间件，支持 MySQL 作为后端存储系统。Vitess 提供了水平拆分、弹性缩放、负载均衡、故障恢复等功能，可以在大规模的数据集和高并发访问场景下提供高性能和可扩展性，项目地址：<a target="_blank" rel="noopener" href="https://vitess.io/zh/">https://vitess.io/zh/</a></li>
</ol>
<h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h3 id="1-如何设计一个秒杀系统"><a href="#1-如何设计一个秒杀系统" class="headerlink" title="1. 如何设计一个秒杀系统"></a>1. 如何设计一个秒杀系统</h3><p>秒杀系统本质上就是一个满足大并发、高性能和高可用的分布式系统。</p>
<p><strong>数据要尽量少</strong>—<strong>请求数要尽量少</strong>—<strong>路径尽量短</strong>—<strong>依赖要尽量少</strong>—<strong>不要有单点</strong></p>
<h3 id="2-Redis程序设计中，上百万的新闻，如何实时展示最热点的top10条呢"><a href="#2-Redis程序设计中，上百万的新闻，如何实时展示最热点的top10条呢" class="headerlink" title="2. Redis程序设计中，上百万的新闻，如何实时展示最热点的top10条呢"></a>2. Redis程序设计中，上百万的新闻，如何实时展示最热点的top10条呢</h3><ol>
<li>使用有序集合（Sorted Set）</li>
</ol>
<p>Redis的有序集合（Sorted Set）是一个非常适合用来实现这种功能的数据结构。它可以存储不重复的字符串元素，并为每个元素关联一个分数（score），通过分数来为集合中的元素进行排序。</p>
<h4 id="1-实现步骤："><a href="#1-实现步骤：" class="headerlink" title="1. 实现步骤："></a>1. 实现步骤：</h4><ol>
<li><strong>存储新闻数据</strong>：<ul>
<li>新闻发布时，<strong>将新闻ID和其热度分数（可以是基于点击量、分享量、评论量等）作为元素和分数添加到有序集合中</strong>。</li>
<li><strong>使用<code>ZADD</code>命令</strong>，例如：<code>ZADD news:hot 1000 newsId1</code>，其中<code>1000</code>是新闻<code>newsId1</code>的热度分数。</li>
</ul>
</li>
<li><strong>获取热点新闻</strong>：<ul>
<li>实时获取最热点的top10条新闻，可以<strong>使用<code>ZREVRANGE</code>命令，该命令按照分数从高到低返回元素。</strong></li>
<li>例如：**<code>ZREVRANGE news:hot 0 9 WITHSCORES</code>，这将返回分数最高的10条新闻及其分数。**</li>
</ul>
</li>
<li><strong>更新热度分数</strong>：<ul>
<li>当新闻的热度分数发生变化时（如用户点击、评论等），使用<code>ZADD</code>命令更新分数。</li>
<li>例如：<code>ZADD news:hot 1100 newsId1</code>，将<code>newsId1</code>的新闻热度分数更新为<code>1100</code>。</li>
</ul>
</li>
</ol>
<h4 id="2-优化策略"><a href="#2-优化策略" class="headerlink" title="2. 优化策略"></a>2. 优化策略</h4><h5 id="a-分页查询"><a href="#a-分页查询" class="headerlink" title="a. 分页查询"></a>a. 分页查询</h5><ul>
<li>如果用户需要查看更多热点新闻，可以实现分页查询，使用<code>ZREVRANGE</code>命令结合<code>LIMIT</code>参数。</li>
</ul>
<h5 id="b-热度分数更新策略"><a href="#b-热度分数更新策略" class="headerlink" title="b. 热度分数更新策略"></a>b. 热度分数更新策略</h5><ul>
<li>热度分数更新可以是实时的，也可以是批量更新的，以减少对Redis的压力。</li>
<li>可以使用定时任务或者消息队列来异步更新分数。</li>
</ul>
<h5 id="c-数据持久化"><a href="#c-数据持久化" class="headerlink" title="c. 数据持久化"></a>c. 数据持久化</h5><ul>
<li>配置Redis的持久化策略（RDB或AOF），确保数据不会因为故障而丢失。</li>
</ul>
<h5 id="d-高并发处理"><a href="#d-高并发处理" class="headerlink" title="d. 高并发处理"></a>d. 高并发处理</h5><ul>
<li>使用Redis集群来分散请求，提高并发处理能力。</li>
<li>设置合理的超时时间，防止Redis因为过长的查询而阻塞。</li>
</ul>
<h5 id="e-内存优化"><a href="#e-内存优化" class="headerlink" title="e. 内存优化"></a>e. 内存优化</h5><ul>
<li>由于新闻数据量巨大，需要注意Redis内存的使用情况，避免内存溢出。</li>
<li>可以设置新闻内容的过期时间，只保留热点新闻的ID和分数在有序集合中。</li>
</ul>
<h3 id="3-大文件上传，如何做到秒传"><a href="#3-大文件上传，如何做到秒传" class="headerlink" title="3. 大文件上传，如何做到秒传"></a>3. 大文件上传，如何做到秒传</h3><p><strong>什么是秒传</strong></p>
<p>通俗的说，你把要上传的东西上传，服务器会先做 MD5 校验，如果服务器上有同样的东西，它就直接给你个新地址，其实你下载的都是服务器上的同一个文件，想要不秒传，其实只要让 MD5 改变，就是对文件本身做一下修改（改名字就行），例如一个文本文件，你多加几个字，MD5 就变了，就不会秒传了.</p>
<p><strong>秒传的核心逻辑</strong></p>
<p>利用 redis 的 set 方法存放文件上传状态，其中 key 为文件上传的 md5，value 为是否上传完成的标志位；</p>
<p>当标志位为 true 表示上传已经完成，此时如果有相同文件上传，则进入秒传逻辑。如果标志位为 false，则说明还没上传完成，此时需要再调用 set 方法，保存块号文件记录的路径，其中 key 为上传文件的 md5 + 一个固定前缀，value 为块号文件的记录路径</p>
<h4 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h4><p><strong>什么是分片上传</strong></p>
<p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为 Part）来进行上传，上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。</p>
<p><strong>分片上传的场景</strong></p>
<p>1.大文件上传；2.网络环境环境不好，存在需要重传风险的场景</p>
<h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p><strong>什么是断点续传</strong></p>
<p>断点续传是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传或者下载未完成的部分，而没有必要从头开始上传或者下载。</p>
<p><strong>核心逻辑</strong></p>
<p>在分片上传的过程中，如果因为系统崩溃或者网络中断等异常因素导致上传中断，这时候客户端需要记录上传的进度。在之后支持再次上传时，可以继续从上次上传中断的地方进行继续上传。</p>
<p>为了避免客户端在上传之后的进度数据被删除而导致重新开始从头上传的问题，服务端也可以提供相应的接口便于客户端对已经上传的分片数据进行查询，从而使客户端知道已经上传的分片数据，从而从下一个分片数据开始继续上传。</p>
<p><strong>实现流程</strong></p>
<ul>
<li>前端（客户端）需要根据固定大小对文件进行分片，<strong>请求后端（服务端）时要带上分片序号和大小</strong></li>
<li>服务端创建 conf 文件用来记录分块位置，conf 文件长度为总分片数，每上传一个分块即向 conf 文件中写入一个 127，那么没上传的位置就是默认的 0,已上传的就是 Byte.MAX_VALUE 127（这步是实现断点续传和秒传的核心步骤）</li>
<li>服务器按照请求数据中给的分片序号和每片分块大小（分片大小是固定且一样的）算出开始位置，与读取到的文件片段数据，写入文件。</li>
</ul>
<h3 id="4-电商平台中订单未支付过期如何实现自动关闭"><a href="#4-电商平台中订单未支付过期如何实现自动关闭" class="headerlink" title="4. 电商平台中订单未支付过期如何实现自动关闭"></a>4. 电商平台中订单未支付过期如何实现自动关闭</h3><p>优惠卷的失效，下单后自动发消息</p>
<h4 id="①-定时任务"><a href="#①-定时任务" class="headerlink" title="①. 定时任务"></a>①. 定时任务</h4><p><strong>通过定时任务关闭订单，是一种成本很低，实现也很容易的方案。</strong></p>
<p>优点：实现容易，成本低，基本不依赖其他组件</p>
<p>缺点：<strong>时间可能不够精确</strong>，由于定时任务扫描的间隔是固定的，所以可能造成一些订单已经过期了一段时间才被扫描到，订单关闭的时间比正常时间晚一些；<strong>增加数据库的压力</strong>，随着订单的数量越来越多，扫描的成本也会越来越大，执行时间也会被拉长，可能导致某些应该被关闭的订单迟迟没有被关闭。</p>
<p>总结：采用定时任务的方案比较适合<strong>对时间要求不是很敏感，并且数据量不太多的业务场景</strong>。</p>
<h4 id="②-JDK延迟队列DelayQueue"><a href="#②-JDK延迟队列DelayQueue" class="headerlink" title="②. JDK延迟队列DelayQueue"></a>②. JDK延迟队列DelayQueue</h4><p>DelayQueue是JDK提供的一个无界队列，我们可以看到，<strong>DelayQueue队列中的元素需要实现Delayed，它只提供了一个方法，就是获取过期时间。</strong></p>
<p>用户的订单生成以后，设置过期时间比如30分钟，放入定义好的DelayQueue，然后创建一个线程，在线程中通过while(true)不断的从DelayQueue中获取过期的数据。</p>
<p>优点：不依赖任何第三方组件，连数据库也不需要了，实现起来也方便。</p>
<p>缺点：因为DelayQueue是一个<strong>无界队列，如果放入的订单过多，会造成JVM OOM</strong>；DelayQueue基于JVM内存，如果JVM重启了，那所有数据就丢失了。</p>
<p><strong>总结:</strong> <strong>DelayQueue适用于数据量较小，且丢失也不影响主业务的场景，</strong>比如内部系统的一些非重要通知，就算丢失，也不会有太大影响。</p>
<h4 id="③-Redis过期监听"><a href="#③-Redis过期监听" class="headerlink" title="③. Redis过期监听"></a>③. Redis过期监听</h4><p>redis是一个高性能的KV数据库，除了用作缓存以外，其实还提供了过期监听的功能。 </p>
<p><strong>在redis.conf中，配置notify-keyspace-events Ex即可开启此功能。</strong> </p>
<p>然后在代码中<strong>继承KeyspaceEventMessageListener，实现onMessage就可以监听过期的数据量。</strong></p>
<p>通过源码，我们可以发现，<strong>其本质也是注册一个listener，利用redis的发布订阅，当key过期时，发布过期消息（key）到Channel ：<code>keyevent@*:expired</code>中。</strong> </p>
<p>在实际的业务中，我们可以将订单的过期时间设置比如30分钟，然后放入到redis。30分钟之后，就可以消费这个key，然后做一些业务上的后置动作，比如检查用户是否支付。</p>
<p>优点：由于redis的高性能，所以我们在设置key，或者消费key时，速度上是可以保证的。</p>
<p>缺点：<strong>由于redis的key过期策略原因，当一个key过期时，redis无法保证立刻将其删除，自然我们的监听事件也无法第一时间消费到这个key，所以会存在一定的延迟。</strong>另外，在redis5.0之前，订阅发布中的消息并没有被持久化，自然也没有所谓的确认机制。所以一旦消费消息的过程中我们的客户端发生了宕机，这条消息就彻底丢失了。</p>
<h4 id="④-Redisson分布式延迟队列RDelayQueue"><a href="#④-Redisson分布式延迟队列RDelayQueue" class="headerlink" title="④. Redisson分布式延迟队列RDelayQueue"></a>④. Redisson分布式延迟队列RDelayQueue</h4><p>Redisson是一个基于redis实现的Java 驻内存数据网格，它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。 </p>
<p>Redisson除了提供我们常用的分布式锁外，<strong>还提供了一个分布式延迟队列RDelayedQueue，他是一种基于zset结构实现的延迟队列，其实现类是RedissonDelayedQueue。</strong></p>
<p>优点：使用简单，并且其实现类中大量使用lua脚本保证其原子性，不会有并发重复问题。</p>
<p>缺点：需要依赖Redis</p>
<p><strong>总结：Redisson是redis官方推荐的JAVA客户端，提供了很多常用的功能，使用简单、高效，推荐大家尝试使用。</strong></p>
<h4 id="⑤-延迟消息"><a href="#⑤-延迟消息" class="headerlink" title="⑤. 延迟消息"></a>⑤. 延迟消息</h4><p><strong>延迟消息，当消息写入到Broker后，不会立刻被消费者消费，需要等待指定的时长后才可被消费处理的消息，称为延时消息。</strong> </p>
<p><strong>在订单创建之后，我们就可以把订单作为一条消息投递到RocketMQ，并将延迟时间设置为30分钟</strong>，这样，30分钟后我们定义的consumer就可以消费到这条消息，然后检查用户是否支付了这个订单。 </p>
<p>通过延迟消息，我们就可以将业务解耦，极大地简化我们的代码逻辑。 </p>
<p>优点：可以使代码逻辑清晰，<strong>系统之间完全解耦，只需关注生产及消费消息即可</strong>。另外其吞吐量极高，最多可以支撑万亿级的数据量。 </p>
<p>缺点：相对来说mq是重量级的组件，引入mq之后，随之而来的消息丢失、幂等性问题等都加深了系统的复杂度。 </p>
<p><strong>总结：通过mq进行系统业务解耦，以及对系统性能削峰填谷已经是当前高性能系统的标配。</strong></p>
<h4 id="⑥-RabbitMQ死信队列"><a href="#⑥-RabbitMQ死信队列" class="headerlink" title="⑥. RabbitMQ死信队列"></a>⑥. RabbitMQ死信队列</h4><p>除了RocketMQ的延迟队列，RabbitMQ的死信队列也可以实现消息延迟功能。 </p>
<p><strong>当RabbitMQ中的一条正常消息，因为过了存活时间（TTL过期）、队列长度超限、被消费者拒绝等原因无法被消费时，就会被当成一条死信消息，投递到死信队列。</strong> </p>
<p>基于这样的机制，<strong>我们可以给消息设置一个ttl，然后故意不消费消息，等消息过期就会进入死信队列，我们再消费死信队列即可。</strong> </p>
<p>通过这样的方式，就可以达到同RocketMQ延迟消息一样的效果。 </p>
<p>优点：同RocketMQ一样，RabbitMQ同样可以使业务解耦，基于其集群的扩展性，也可以实现高可用、高性能的目标。 </p>
<p>缺点：<strong>死信队列本质还是一个队列，队列都是先进先出，如果队头的消息过期时间比较长，就会导致后面过期的消息无法得到及时消费，造成消息阻塞。</strong> </p>
<p><strong>总结：除了增加系统复杂度之外，死信队列的阻塞问题也是需要我们重点关注的。</strong></p>
<h3 id="如何设计一个高并发系统"><a href="#如何设计一个高并发系统" class="headerlink" title="如何设计一个高并发系统"></a>如何设计一个高并发系统</h3><p><strong><a target="_blank" rel="noopener" href="https://www.yuque.com/tulingzhouyu/db22bv/hsr3m7iinrb19g08">https://www.yuque.com/tulingzhouyu/db22bv/hsr3m7iinrb19g08</a></strong></p>
<p><strong>网页静态化</strong>  </p>
<p><strong>CDN(内容分发网络)</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huzongfei.github.io">hzf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huzongfei.github.io/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">https://huzongfei.github.io/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huzongfei.github.io" target="_blank">草莓熊的秘密基地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/24/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/" title="简历相关问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">简历相关问题</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/22/test/" title="test"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">test</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">hzf</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A"><span class="toc-number">1.</span> <span class="toc-text">上</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-SE-vs-Java-EE"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. Java SE vs Java EE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JVM-vs-JDK-vs-JRE"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.JVM vs JDK vs JRE</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JVM"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK%E5%92%8CJRE"><span class="toc-number">1.0.2.0.2.</span> <span class="toc-text">JDK和JRE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. 什么是字节码?采用字节码的好处是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Java-%E8%AF%AD%E8%A8%80%E2%80%9C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%E2%80%9D%EF%BC%9F"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. 为什么说 Java 语言“编译与解释并存”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-AOT-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8-AOT-%E5%91%A2%EF%BC%9F"><span class="toc-number">1.0.5.</span> <span class="toc-text">5. AOT 有什么优点？为什么不全部使用 AOT 呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Java-%E5%92%8C-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.6.</span> <span class="toc-text">6.  Java 和 C++ 的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-continue%E3%80%81break-%E5%92%8C-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.7.</span> <span class="toc-text">7. continue、break 和 return 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.8.</span> <span class="toc-text">8. Java 中的几种基本数据类型了解么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.9.</span> <span class="toc-text">9. 基本类型和包装类型的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.10.</span> <span class="toc-text">10. 包装类型的缓存机制了解么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.11.</span> <span class="toc-text">11. 自动装箱与拆箱了解吗？原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">1.0.12.</span> <span class="toc-text">12. 为什么浮点数运算的时候会有精度丢失的风险？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.0.13.</span> <span class="toc-text">13.如何解决浮点数运算的精度丢失问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.14.</span> <span class="toc-text">14. 成员变量与局部变量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.15.</span> <span class="toc-text">15. 字符型常量和字符串常量的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.16.</span> <span class="toc-text">16. 重载和重写有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.0.16.1.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">1.0.16.2.</span> <span class="toc-text">重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">1.0.17.</span> <span class="toc-text">17. 什么是可变长参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E4%B8%8E-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9FConcurrentHashMap-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.18.</span> <span class="toc-text">HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.18.0.1.</span> <span class="toc-text">HashMap 的实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.18.0.2.</span> <span class="toc-text">ConcurrentHashMap 的实现原理</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD"><span class="toc-number">2.</span> <span class="toc-text">中</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 对象的相等和引用相等的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97"><span class="toc-number">2.0.4.</span> <span class="toc-text">4. 如果一个类没有声明构造方法，该程序能正确执行吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override"><span class="toc-number">2.0.5.</span> <span class="toc-text">5. 构造方法有哪些特点？是否可被 override?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">2.0.6.</span> <span class="toc-text">6. 面向对象三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.0.6.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.0.6.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">2.0.6.3.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.0.7.</span> <span class="toc-text">7. 接口和抽象类有什么共同点和区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">2.0.8.</span> <span class="toc-text">8.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.9.</span> <span class="toc-text">9. Object 类的常见方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.10.</span> <span class="toc-text">10. == 和 equals() 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-hashCode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">2.0.11.</span> <span class="toc-text">11. hashCode() 有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashCode%EF%BC%9F"><span class="toc-number">2.0.12.</span> <span class="toc-text">12. 为什么要有 hashCode？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.0.13.</span> <span class="toc-text">13. 为什么重写 equals() 时必须重写 hashCode() 方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-String%E3%80%81StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.0.14.</span> <span class="toc-text">14. String、StringBuffer、StringBuilder 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">2.0.15.</span> <span class="toc-text">15. String 为什么是不可变的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8%E2%80%9C-%E2%80%9D-%E8%BF%98%E6%98%AF-StringBuilder"><span class="toc-number">2.0.16.</span> <span class="toc-text">16. 字符串拼接用“+” 还是 StringBuilder?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-String-equals-%E5%92%8C-Object-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.0.17.</span> <span class="toc-text">17. String#equals() 和 Object#equals() 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.0.18.</span> <span class="toc-text">18. 字符串常量池的作用了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-String-s1-new-String-%E2%80%9Cabc%E2%80%9D-%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.0.19.</span> <span class="toc-text">19. String s1 = new String(“abc”);这句话创建了几个字符串对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-String-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">2.0.20.</span> <span class="toc-text">20.String.intern() 方法有什么作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-String-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A%E2%80%9C-%E2%80%9D%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.0.21.</span> <span class="toc-text">21.String 类型的变量和常量做“+”运算时发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.0.22.</span> <span class="toc-text">22. 包访问权限</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8B"><span class="toc-number">3.</span> <span class="toc-text">下</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Exception-%E5%92%8C-Error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. Exception 和 Error 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Checked-Exception-%E5%92%8C-Unchecked-Exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. Checked Exception 和 Unchecked Exception 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. Throwable 类常用方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. try-catch-finally 如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-finally-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.5.</span> <span class="toc-text">5. finally 中的代码一定会执行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-try-with-resources-%E4%BB%A3%E6%9B%BFtry-catch-finally%EF%BC%9F"><span class="toc-number">3.1.6.</span> <span class="toc-text">6. 如何使用 try-with-resources 代替try-catch-finally？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-number">3.1.7.</span> <span class="toc-text">7. 异常使用有哪些需要注意的地方？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. 什么是泛型？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 说说你对泛型的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 泛型的使用方式有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">3.2.4.</span> <span class="toc-text">4. 项目中哪里用到了泛型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">3.3.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BD%95%E8%B0%93%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">11. 何谓反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">3.3.2.</span> <span class="toc-text">12. 反射的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">13. 反射的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.4.</span> <span class="toc-text">反射的实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.4.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%95%E8%B0%93%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. 何谓注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. 注解的解析方法有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B0%88%E8%B0%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.3.</span> <span class="toc-text">3. 谈谈自定义注解的场景及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.4.4.</span> <span class="toc-text">4. 序列化和反序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BF%85%E9%A1%BB%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%90%A6%E5%88%99%E6%8A%A5%E9%94%99"><span class="toc-number">4.0.1.</span> <span class="toc-text">数组初始化必须指定初始化长度，否则报错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList"><span class="toc-number">4.0.2.</span> <span class="toc-text">ArrayList和LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8Band%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">4.0.3.</span> <span class="toc-text">向上转型and向下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%845%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">4.0.4.</span> <span class="toc-text">常见的5中运行时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B3%E7%B3%BB"><span class="toc-number">4.0.5.</span> <span class="toc-text">进程、程序、线程的基本概念及关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">4.0.6.</span> <span class="toc-text">IO流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.7.</span> <span class="toc-text">Object类的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.0.8.</span> <span class="toc-text">java创建对象有哪几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BBClass%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">4.0.9.</span> <span class="toc-text">获取一个类Class对象的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-fast"><span class="toc-number">4.0.10.</span> <span class="toc-text">fail-fast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable-%E4%B8%8E-HashMap%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90%E2%AD%90"><span class="toc-number">4.0.11.</span> <span class="toc-text">Hashtable 与 HashMap的区别⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84N%E6%AC%A1%E6%96%B9%E5%91%A2"><span class="toc-number">4.0.12.</span> <span class="toc-text">HashMap的长度为什么是2的N次方呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%8EConcurrentHashMap%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">4.0.13.</span> <span class="toc-text">HashMap与ConcurrentHashMap的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="toc-number">4.0.14.</span> <span class="toc-text">红黑树有哪几个特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Comparator-%E4%B8%8E-Comparable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.15.</span> <span class="toc-text">1. Comparator 与 Comparable 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Integer%E7%BC%93%E5%AD%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.0.16.</span> <span class="toc-text">2. 说说你对Integer缓存的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">4.0.17.</span> <span class="toc-text">5. 如何实现线程的同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%8E%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.18.</span> <span class="toc-text">6.什么是守护线程？与普通线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Java%E4%B8%AD%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.0.19.</span> <span class="toc-text">7. Java中集合框架有哪些核心接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ArrayList%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.20.</span> <span class="toc-text">8. ArrayList和LinkedList有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AFJava%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-number">4.0.21.</span> <span class="toc-text">10. 什么是Java的序列化⭐⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-number">4.0.22.</span> <span class="toc-text">11. 说说你对内部类的理解⭐⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#punch-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.22.1.</span> <span class="toc-text">:punch: 静态内部类和非静态内部类的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.0.23.</span> <span class="toc-text">12. 说说你对lambda表达式的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-notify%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.24.</span> <span class="toc-text">13. notify和notifyAll()有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8ECGLIB%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.25.</span> <span class="toc-text">14. JDK动态代理与CGLIB实现的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%9E%84%E9%80%A0%E5%99%A8%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-number">4.0.26.</span> <span class="toc-text">17. 构造器是否可以被重写⭐⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-number">4.0.27.</span> <span class="toc-text">18. 如何实现对象克隆⭐⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-number">4.0.28.</span> <span class="toc-text">19. synchronized关键字⭐⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.0.28.1.</span> <span class="toc-text">synchronized的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">4.0.28.2.</span> <span class="toc-text">synchronized锁优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3-star-star-star-%E2%80%94-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.0.29.</span> <span class="toc-text">20. 谈谈你对ThreadLocal的理解 :star::star::star: — 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.0.29.1.</span> <span class="toc-text">ThreadLocal应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">4.0.29.2.</span> <span class="toc-text">ThreadLocal如何防止内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9CountDownLatch%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.0.30.</span> <span class="toc-text">21. 谈谈你对CountDownLatch的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9CyclicBarrier%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.0.31.</span> <span class="toc-text">22. 谈谈你对CyclicBarrier的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-1"><span class="toc-number">5.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.0.1.</span> <span class="toc-text">1. JVM内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">1. 运行时数据区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">2. 虚拟机栈：线程私有</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E6%A0%88%E5%B8%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E6%88%90"><span class="toc-number">5.0.1.2.1.</span> <span class="toc-text">2.1. 栈帧有哪些组成</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="toc-number">5.0.1.3.</span> <span class="toc-text">3. 本地方法栈：线程私有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="toc-number">5.0.1.4.</span> <span class="toc-text">4. 程序计数器：线程私有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A0%86%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB"><span class="toc-number">5.0.1.5.</span> <span class="toc-text">5. 堆：线程共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB"><span class="toc-number">5.0.1.6.</span> <span class="toc-text">6. 方法区：线程共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. Java内存模型 JMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">5.0.3.</span> <span class="toc-text">3. 类的加载与卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E2%80%94-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F-%E2%80%94-tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">5.0.4.</span> <span class="toc-text">4. 类的加载机制 —- 双亲委派模式 — tomcat类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%8F%AF%E4%BB%A5%E6%89%93%E7%A0%B4%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%EF%BC%9F"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">双亲委派机制可以打破吗？如何打破？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.0.4.2.</span> <span class="toc-text">Tomcat类加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tomcat%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">5.0.4.3.</span> <span class="toc-text">tomcat为什么要自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">5.0.5.</span> <span class="toc-text">10. 分代回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">5.0.6.</span> <span class="toc-text">11. 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">5.0.6.1.</span> <span class="toc-text">1. 垃圾收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.0.6.2.</span> <span class="toc-text">2. 常见垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91FullGC"><span class="toc-number">5.0.6.3.</span> <span class="toc-text">3. 什么时候会触发FullGC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%AF%A2%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">5.0.7.</span> <span class="toc-text">12.多线程环境下，时间片轮询是如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.0.8.</span> <span class="toc-text">13. 堆和栈的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%80%E4%B9%88%E6%98%AFjava%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Java%E8%A2%AB%E7%A7%B0%E4%B8%BA%E6%98%AF%E2%80%9C%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%9D"><span class="toc-number">5.0.9.</span> <span class="toc-text">15. 什么是java虚拟机？为什么Java被称为是“平台无关的编程语言”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">5.0.10.</span> <span class="toc-text">16.对象分配规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E5%8A%A0%E8%BD%BDClass%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">5.0.11.</span> <span class="toc-text">17. 描述一下JVM加载Class文件的原理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">5.0.12.</span> <span class="toc-text">18. java对象创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-java%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">5.0.13.</span> <span class="toc-text">19. java的对象结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-java%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E5%92%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">5.0.14.</span> <span class="toc-text">22. java调优的常见工具和命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">5.0.15.</span> <span class="toc-text">23. 逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E"><span class="toc-number">5.0.16.</span> <span class="toc-text">24. 什么是指针碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">5.0.17.</span> <span class="toc-text">25. 什么是空闲列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BB%80%E4%B9%88%E6%98%AFTLAB"><span class="toc-number">5.0.18.</span> <span class="toc-text">26. 什么是TLAB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Class%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E5%B1%9E%E6%80%A7"><span class="toc-number">5.0.19.</span> <span class="toc-text">27. Class文件的结构属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-JVM%E4%B8%AD%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84GC%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E6%99%8B%E5%8D%87%E5%88%B0%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">5.0.20.</span> <span class="toc-text">28.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-JVM%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.0.21.</span> <span class="toc-text">29.JVM的主要参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O"><span class="toc-number">6.</span> <span class="toc-text">I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">6.1.</span> <span class="toc-text">I/O基础知识总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">6.1.2.</span> <span class="toc-text">2. 字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">6.1.3.</span> <span class="toc-text">3. 字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">6.1.4.</span> <span class="toc-text">4. 字节缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-BufferedInputStream-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">4.1 BufferedInputStream(字节缓冲输入流)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-BufferOutputStream-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">4.2 BufferOutputStream(字节缓冲输出流)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">6.1.5.</span> <span class="toc-text">5. 字符缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">6.1.6.</span> <span class="toc-text">6. 打印流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81"><span class="toc-number">6.1.7.</span> <span class="toc-text">7. 随机访问流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JAVA-IO%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.1.8.</span> <span class="toc-text">1. JAVA IO中的设计模型有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.8.1.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.8.2.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.8.3.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.8.4.</span> <span class="toc-text">观察者模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.2.</span> <span class="toc-text">Java IO模型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD3%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">Java中3种常见的IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO%EF%BC%88Blocking-I-O%EF%BC%89"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">BIO（Blocking I/O）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO-Non-blocking-New-I-O"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">**NIO(Non-blocking/New I/O) **</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO-Asynchronous-I-O"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">AIO(Asynchronous I/O)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">6.2.2.</span> <span class="toc-text">Java NIO 核心知识总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Select-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">Select(选择器)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.2.3.</span> <span class="toc-text">NIO零拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">Java并发常见面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B7%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.0.1.</span> <span class="toc-text">1.请简要描述线程与进程的关系,区别及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">7.0.2.</span> <span class="toc-text">2.程序计数器为什么是私有的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">7.0.3.</span> <span class="toc-text">3.虚拟机栈和本地方法栈为什么是私有的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">7.0.4.</span> <span class="toc-text">4. 简单介绍一下堆和方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.5.</span> <span class="toc-text">5. 并发和并行的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.6.</span> <span class="toc-text">6. 同步和异步的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.0.7.</span> <span class="toc-text">7. 为什么要使用多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">7.0.8.</span> <span class="toc-text">8. 使用多线程可能会带来什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8D%95%E6%A0%B8CPU%E4%B8%8A%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%95%88%E7%8E%87%E4%B8%80%E5%AE%9A%E4%BC%9A%E9%AB%98%E5%90%97%EF%BC%9F"><span class="toc-number">7.0.9.</span> <span class="toc-text">9. 单核CPU上运行多个线程效率一定会高吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.0.10.</span> <span class="toc-text">10. 如何创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">7.0.11.</span> <span class="toc-text">11. 说说线程的生命周期和状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">7.0.12.</span> <span class="toc-text">12. 什么是线程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">7.0.13.</span> <span class="toc-text">13. 什么是线程死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">7.0.14.</span> <span class="toc-text">14.如何预防和避免线程死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-sleep-%E6%96%B9%E6%B3%95%E5%92%8Cwait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">7.0.15.</span> <span class="toc-text">15. sleep()方法和wait()方法对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%B8%BA%E4%BB%80%E4%B9%88wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8Thread%E4%B8%AD%EF%BC%9F"><span class="toc-number">7.0.16.</span> <span class="toc-text">16. 为什么wait()方法不定义在Thread中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8Thread%E7%B1%BB%E7%9A%84run%E6%96%B9%E6%B3%95%E5%98%9B%EF%BC%9F"><span class="toc-number">7.0.17.</span> <span class="toc-text">17. 可以直接调用Thread类的run方法嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.0.18.</span> <span class="toc-text">1.为什么需要多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">7.0.19.</span> <span class="toc-text">2.并发出现问题的根源：并发三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9ACPU%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7"><span class="toc-number">7.0.19.1.</span> <span class="toc-text">可见性：CPU缓存引起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9A%E5%88%86%E6%97%B6%E5%A4%8D%E7%94%A8%E5%BC%95%E8%B5%B7"><span class="toc-number">7.0.19.2.</span> <span class="toc-text">原子性：分时复用引起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7-%E9%87%8D%E6%8E%92%E5%BA%8F%E5%BC%95%E8%B5%B7"><span class="toc-number">7.0.19.3.</span> <span class="toc-text">有序性:重排序引起</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Avolatile%E3%80%81synchronized%E3%80%81final"><span class="toc-number">7.0.20.</span> <span class="toc-text">4.关键字：volatile、synchronized、final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">7.0.20.1.</span> <span class="toc-text">缓存一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.0.20.2.</span> <span class="toc-text">缓存一致性协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E6%9C%89%E5%BA%8F%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.0.20.3.</span> <span class="toc-text">volatile有序性实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.0.20.3.1.</span> <span class="toc-text">Synchronized的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="toc-number">7.0.20.3.2.</span> <span class="toc-text">对象锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E9%94%81"><span class="toc-number">7.0.20.3.3.</span> <span class="toc-text">类锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.21.</span> <span class="toc-text">5. 进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BD%95%E8%B0%83%E7%94%A8start%E8%80%8C%E4%B8%8D%E6%98%AFrun%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.22.</span> <span class="toc-text">6. 启动线程为何调用start而不是run方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84"><span class="toc-number">7.0.23.</span> <span class="toc-text">7. Java线程之间是如何通信的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Java%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.0.24.</span> <span class="toc-text">8. Java中用到的线程调度算法是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.25.</span> <span class="toc-text">9. 死锁与活锁，死锁与饥饿的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">7.0.26.</span> <span class="toc-text">10. 如何避免死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E7%BA%BF%E7%A8%8B%E4%BC%9A%E8%BF%9B%E5%85%A5WAITING%E7%8A%B6%E6%80%81"><span class="toc-number">7.0.27.</span> <span class="toc-text">11. 什么情况线程会进入WAITING状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%AF%B4%E8%AF%B4synchronized%E4%B8%8EReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.28.</span> <span class="toc-text">12. 说说synchronized与ReentrantLock的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.0.29.</span> <span class="toc-text">ReentrantLock的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.29.1.</span> <span class="toc-text">ReentrantLock基本方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">7.0.29.2.</span> <span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">7.0.29.3.</span> <span class="toc-text">公平锁的加锁流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">7.0.29.4.</span> <span class="toc-text">非公平锁的加锁流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS"><span class="toc-number">7.0.30.</span> <span class="toc-text">什么是AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">7.0.31.</span> <span class="toc-text">13. 常见同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89"><span class="toc-number">7.0.31.1.</span> <span class="toc-text">Semaphore（信号量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch-%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">7.0.31.2.</span> <span class="toc-text">CountDownLatch(倒计时器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F"><span class="toc-number">7.0.31.3.</span> <span class="toc-text">CyclicBarrier(循环栅栏)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">7.0.32.</span> <span class="toc-text">14. 悲观锁与乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.0.32.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8"><span class="toc-number">7.0.33.</span> <span class="toc-text">17. 为什么wait和notify方法要在同步块中调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E6%9C%89%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8BT1-T2-T3%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">7.0.34.</span> <span class="toc-text">18. 有三个线程T1,T2,T3，如何保证顺序执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8join-%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.34.1.</span> <span class="toc-text">1. 使用join()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-CountDownLatch"><span class="toc-number">7.0.34.2.</span> <span class="toc-text">2. 使用 CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-LockSupport"><span class="toc-number">7.0.34.3.</span> <span class="toc-text">3. 使用 LockSupport</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">7.0.35.</span> <span class="toc-text">20. 如何确保线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">7.0.36.</span> <span class="toc-text">21. 什么是可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">7.0.37.</span> <span class="toc-text">22. 锁的优化机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AF%B9%E5%86%99%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%B8%AE%E5%8A%A9"><span class="toc-number">7.0.38.</span> <span class="toc-text">23. 什么是不可变对象，对写并发有什么帮助</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.39.</span> <span class="toc-text">1. 实现多线程的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">7.0.39.1.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.0.39.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Callable%E5%92%8CFuture"><span class="toc-number">7.0.39.3.</span> <span class="toc-text">使用Callable和Future</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-notify-and-notifyAll"><span class="toc-number">7.0.40.</span> <span class="toc-text">2. notify() and notifyAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.41.</span> <span class="toc-text">3. sleep() 和 wait() 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-volatile%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E5%98%9B%EF%BC%9F"><span class="toc-number">7.0.42.</span> <span class="toc-text">4. volatile是什么？可以保证有序性嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84-start-%E5%92%8C-run-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.43.</span> <span class="toc-text">5. Thread类中的 start() 和 run() 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify-%E5%92%8C-notifyAll-%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E5%9C%A8Thread%E7%B1%BB%E4%B8%AD"><span class="toc-number">7.0.44.</span> <span class="toc-text">6.为什么wait(), notify() 和 notifyAll()这些方法不在Thread类中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">7.0.45.</span> <span class="toc-text">7. 为什么wait和notify方法要在同步块中调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Java%E4%B8%ADinterrupted-%E5%92%8C-isInterrupted%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.0.46.</span> <span class="toc-text">8. Java中interrupted 和 isInterrupted方法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F-Vertor%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E5%98%9B-%E6%98%AF%E7%9A%84-%EF%BC%9F"><span class="toc-number">7.0.47.</span> <span class="toc-text">12. 什么是线程安全？ Vertor是一个线程安全类嘛(是的)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">7.0.48.</span> <span class="toc-text">13. Thread类中的yield方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-java%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">7.0.49.</span> <span class="toc-text">18. java程序的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">7.0.50.</span> <span class="toc-text">19. 锁的优化机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.51.</span> <span class="toc-text">20. 进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-number">7.0.52.</span> <span class="toc-text">23. 线程安全需要保证几个基本特征？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">7.0.53.</span> <span class="toc-text">24. 线程之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-CSA"><span class="toc-number">7.0.54.</span> <span class="toc-text">25. CSA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.54.1.</span> <span class="toc-text">CAS原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSA%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">7.0.54.2.</span> <span class="toc-text">CSA的缺点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.0.55.</span> <span class="toc-text">27. 引用类型有哪些？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">7.0.56.</span> <span class="toc-text">30. 多线程有什么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81JMM%EF%BC%9F"><span class="toc-number">7.0.57.</span> <span class="toc-text">31. JMM内存模型的理解，为什么需要JMM？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">7.0.57.1.</span> <span class="toc-text">JMM的必要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.0.57.2.</span> <span class="toc-text">JMM的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">7.0.57.3.</span> <span class="toc-text">同步机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">7.0.58.</span> <span class="toc-text">32. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Locking%EF%BC%89"><span class="toc-number">7.0.58.0.0.1.</span> <span class="toc-text">悲观锁（Pessimistic Locking）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Locking%EF%BC%89"><span class="toc-number">7.0.58.0.0.2.</span> <span class="toc-text">乐观锁（Optimistic Locking）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">7.0.58.0.0.3.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%B9%90%E8%A7%82%E9%94%81%E8%BF%98%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9A"><span class="toc-number">7.0.58.0.0.4.</span> <span class="toc-text">选择乐观锁还是悲观锁：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E4%BB%80%E4%B9%88%E6%98%AFDaemon%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">7.0.59.</span> <span class="toc-text">33. 什么是Daemon线程？它有什么意义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">7.0.60.</span> <span class="toc-text">34. 什么是多线程中的上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-CompletableFuture%E7%B1%BB"><span class="toc-number">7.0.61.</span> <span class="toc-text">35.CompletableFuture类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E7%BA%BF%E7%A8%8B%E6%B1%A0-star2-star2-star2-star2-star2"><span class="toc-number">7.0.62.</span> <span class="toc-text">36. 线程池 :star2::star2::star2::star2::star2:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">7.0.62.1.</span> <span class="toc-text">线程池的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.0.62.2.</span> <span class="toc-text">常用的线程池有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.0.62.3.</span> <span class="toc-text">Java线程池中任务队列/阻塞队列常用类型有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">7.0.62.4.</span> <span class="toc-text">线程池原理知道吗？以及核心参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.0.62.5.</span> <span class="toc-text">线程池的拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E5%A4%A7%E5%B0%8F%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.0.62.6.</span> <span class="toc-text">线程池中核心线程数量大小怎么设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88Executor%E6%A1%86%E6%9E%B6%EF%BC%89"><span class="toc-number">7.0.62.7.</span> <span class="toc-text">使用线程池（Executor框架）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsubmit-%E5%92%8C-execute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.62.8.</span> <span class="toc-text">Java线程池中submit() 和 execute()方法有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">7.0.62.9.</span> <span class="toc-text">线程池的状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">8.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.0.1.</span> <span class="toc-text">基本的增删改查语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-delete%E3%80%81drop%E3%80%81truncate%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.2.</span> <span class="toc-text">1. delete、drop、truncate区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E8%8C%83%E5%BC%8F"><span class="toc-number">8.0.3.</span> <span class="toc-text">2. 3范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.0.4.</span> <span class="toc-text">3. 什么是内连接，左外连接，右外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B4%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.0.5.</span> <span class="toc-text">4. 说下数据库事务的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-number">8.0.5.1.</span> <span class="toc-text">事务特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.0.5.2.</span> <span class="toc-text">并发事务带来的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9Fmysql%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F-star"><span class="toc-number">8.0.5.3.</span> <span class="toc-text">事务隔离级别？mysql的默认隔离级别？:star:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-star-star-star"><span class="toc-number">8.0.6.</span> <span class="toc-text">6. 大表如何优化:star::star::star:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8Cid%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-star-star-star"><span class="toc-number">8.0.7.</span> <span class="toc-text">7. 分库分表之后，id主键如何处理 :star::star::star:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-MySql%E4%B8%ADvarchar%E5%92%8Cchar%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.0.8.</span> <span class="toc-text">9.MySql中varchar和char的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-MySql%E4%B8%ADint-11-%E4%B8%AD%E7%9A%8411%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-number">8.0.9.</span> <span class="toc-text">10.MySql中int(11)中的11代表什么含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88select-count-from-table-%E5%9C%A8InnoDB%E6%AF%94MyISAM%E6%85%A2"><span class="toc-number">8.0.10.</span> <span class="toc-text">11. 为什么select count(*) from table 在InnoDB比MyISAM慢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-InnoDB-%E5%92%8CMyISAM%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.11.</span> <span class="toc-text">12. InnoDB 和MyISAM有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-MySQL%E7%B4%A2%E5%BC%95"><span class="toc-number">8.0.12.</span> <span class="toc-text">13. MySQL索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">8.0.12.1.</span> <span class="toc-text">1. 为什么使用索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F-star2-star2-star2"><span class="toc-number">8.0.12.2.</span> <span class="toc-text">2. 什么是索引？索引有哪些优缺点？:star2::star2::star2:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.0.12.3.</span> <span class="toc-text">3. 索引类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">8.0.12.4.</span> <span class="toc-text">4. 什么时候不要使用索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">8.0.12.5.</span> <span class="toc-text">5. 索引失效的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">8.0.12.6.</span> <span class="toc-text">6. 什么是覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">8.0.12.7.</span> <span class="toc-text">7. 什么是索引下推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95VS%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">8.0.12.8.</span> <span class="toc-text">8. 聚簇索引VS非聚簇索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.0.13.</span> <span class="toc-text">14. 快照读和当前读有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFMVCC%EF%BC%9F"><span class="toc-number">8.0.14.</span> <span class="toc-text">15. 说说什么是MVCC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Undo-log%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1%E7%9A%84-star-star-star"><span class="toc-number">8.0.15.</span> <span class="toc-text">16. Undo log是如何回滚事务的 :star::star::star:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-number">8.0.16.</span> <span class="toc-text">17. MySql数据库的锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.0.16.1.</span> <span class="toc-text">锁的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySql%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">8.0.16.2.</span> <span class="toc-text">MySql的锁升级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">8.0.16.3.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-MySQL%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88"><span class="toc-number">8.0.17.</span> <span class="toc-text">18. MySQL如何做到高可用方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E5%BC%95%E6%93%8E%E6%98%AFInnoDB"><span class="toc-number">8.0.18.</span> <span class="toc-text">1. MySQL为什么默认引擎是InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%85%A2SQL"><span class="toc-number">8.0.19.</span> <span class="toc-text">2. 慢SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2SQL-star"><span class="toc-number">8.0.19.1.</span> <span class="toc-text">如何定位慢SQL:star:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2SQL%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E7%9A%84-star"><span class="toc-number">8.0.19.2.</span> <span class="toc-text">慢SQL你是怎么优化的:star:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-UNION-%E4%B8%8EUNION-ALL-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.0.20.</span> <span class="toc-text">3. UNION 与UNION ALL 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-count-1-%E3%80%81count-%E4%B8%8E-count-%E5%88%97%E5%90%8D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.0.21.</span> <span class="toc-text">4. count(1)、count(*) 与 count(列名) 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">8.0.22.</span> <span class="toc-text">5. MySQL主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">8.0.22.1.</span> <span class="toc-text">主从复制原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%B7%B1%E5%88%86%E9%A1%B5-limit-1000000"><span class="toc-number">8.0.23.</span> <span class="toc-text">6. 如何优化深分页 limit 1000000</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3MySQL%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">8.0.24.</span> <span class="toc-text">7. 如何解决MySQL死锁问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-B-%E6%A0%91"><span class="toc-number">8.0.25.</span> <span class="toc-text">8. MySQL索引底层结构为什么使用 B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.0.25.1.</span> <span class="toc-text">为什么不用一般二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.0.25.2.</span> <span class="toc-text">为什么不是平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AFB%E6%A0%91"><span class="toc-number">8.0.25.3.</span> <span class="toc-text">为什么不是B树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.0.25.4.</span> <span class="toc-text">Hash索引和B+树区别是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">8.0.26.</span> <span class="toc-text">9. 数据库的分库分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%91%A2%EF%BC%9F"><span class="toc-number">8.0.27.</span> <span class="toc-text">10. 为什么需要数据库连接池呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%88%86%E8%A1%A8%E5%90%8E%E9%9D%9E%E5%88%86%E7%89%87%E9%94%AE%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%81%E6%8E%92%E5%BA%8F%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">8.0.28.</span> <span class="toc-text">11. 分表后非分片键的查询、排序怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%95%B0%E6%8D%AE%E5%BA%93CPU%E9%A3%99%E5%8D%87%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">8.0.29.</span> <span class="toc-text">12. 数据库CPU飙升如何处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%97%B6%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">8.0.30.</span> <span class="toc-text">13. SQL的执行过程时怎么样的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">8.0.31.</span> <span class="toc-text">14. 自增主键会遇到什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">8.0.32.</span> <span class="toc-text">MySQL性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Explain%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">8.0.32.1.</span> <span class="toc-text">使用Explain进行分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">8.0.32.2.</span> <span class="toc-text">优化数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F"><span class="toc-number">8.0.32.2.1.</span> <span class="toc-text">减少请求的数据量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%89%AB%E6%8F%8F%E7%9A%84%E8%A1%8C%E6%95%B0"><span class="toc-number">8.0.32.2.2.</span> <span class="toc-text">减少服务端扫描的行数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">8.0.32.3.</span> <span class="toc-text">重构查询方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E5%88%86%E5%A4%A7%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.0.32.3.1.</span> <span class="toc-text">切分大查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.0.32.3.2.</span> <span class="toc-text">分解大连接查询</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">9.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E8%BE%83%E5%BF%AB"><span class="toc-number">9.0.1.</span> <span class="toc-text">1. Redis为什么比较快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redis%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD"><span class="toc-number">9.0.2.</span> <span class="toc-text">2. Redis可以实现什么功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.0.3.</span> <span class="toc-text">3. Redis有哪些数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">9.0.4.</span> <span class="toc-text">4. 有序集合底层是如何实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">9.0.4.1.</span> <span class="toc-text">跳跃表底层是如何实现的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">9.0.5.</span> <span class="toc-text">5. Redis如何实现消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.0.5.1.</span> <span class="toc-text">发布订阅和List的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">9.0.6.</span> <span class="toc-text">6. Redis如何实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%97%AE%E9%A2%98%E2%80%94SETNX-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">9.0.6.1.</span> <span class="toc-text">分布式锁问题—SETNX 存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">9.0.6.2.</span> <span class="toc-text">Redisson实现分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedLock-%E7%BA%A2%E9%94%81"><span class="toc-number">9.0.6.3.</span> <span class="toc-text">RedLock 红锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">9.0.7.</span> <span class="toc-text">7. Redis持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">9.0.7.1.</span> <span class="toc-text">为什么需要持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">9.0.7.2.</span> <span class="toc-text">RDB持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">9.0.8.</span> <span class="toc-text">8. Redis的过期删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">9.0.9.</span> <span class="toc-text">9.Redis内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%A7%A6%E5%8F%91%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">9.0.9.1.</span> <span class="toc-text">何时触发内存淘汰策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU%E5%92%8CLFU%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.0.9.2.</span> <span class="toc-text">LRU和LFU的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Redis%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.0.10.</span> <span class="toc-text">10. Redis的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">9.0.10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">9.0.10.2.</span> <span class="toc-text">Redis事务相关命令和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">9.0.10.3.</span> <span class="toc-text">Redis事务执行步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">9.0.10.4.</span> <span class="toc-text">CAS操作实现乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%8D%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A"><span class="toc-number">9.0.10.5.</span> <span class="toc-text">为什么Redis不支持回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Redis%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84ACID"><span class="toc-number">9.0.10.6.</span> <span class="toc-text">如何理解Redis与事务的ACID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.0.10.7.</span> <span class="toc-text">Redis事务其他实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88"><span class="toc-number">9.0.11.</span> <span class="toc-text">11. Redis的集群模式有哪些方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Redis-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">9.0.12.</span> <span class="toc-text">12. Redis - 缓存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">9.0.12.1.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">9.0.12.2.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">9.0.12.3.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%EF%BC%88%E6%88%96%E6%BB%A1%E4%BA%86%EF%BC%89"><span class="toc-number">9.0.12.4.</span> <span class="toc-text">缓存污染（或满了）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">9.0.13.</span> <span class="toc-text">13. 数据库和缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">9.0.13.1.</span> <span class="toc-text">队列+重试机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%AE%A2%E9%98%85binlog%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">9.0.13.2.</span> <span class="toc-text">异步更新缓存（基于订阅binlog的同步机制）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">9.0.14.</span> <span class="toc-text">15. 布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">9.0.14.1.</span> <span class="toc-text">布隆过滤器执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.0.14.2.</span> <span class="toc-text">布隆过滤器使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">9.0.15.</span> <span class="toc-text">16. Redis如何保证高可用性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">9.0.16.</span> <span class="toc-text">17 Redis如何实现延时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">9.0.16.1.</span> <span class="toc-text">Redis过期事件监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson%E5%86%85%E7%BD%AE%E7%9A%84%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">9.0.16.2.</span> <span class="toc-text">Redisson内置的延时队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.0.17.</span> <span class="toc-text">18. Redis 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Redis%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%BC%8F-%E2%80%94-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.0.18.</span> <span class="toc-text">19. Redis消息传递模式 — 发布订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A2%91%E9%81%93%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.0.18.1.</span> <span class="toc-text">基于频道的发布订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.0.18.1.1.</span> <span class="toc-text">如何实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.0.18.2.</span> <span class="toc-text">基于模式的发布订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">9.0.18.2.1.</span> <span class="toc-text">如何实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Redis-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">9.0.19.</span> <span class="toc-text">20. Redis 事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.0.19.1.</span> <span class="toc-text">文件事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.0.19.2.</span> <span class="toc-text">时间事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">9.0.19.3.</span> <span class="toc-text">创建事件管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.0.19.4.</span> <span class="toc-text">创建文件事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">9.0.19.5.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.0.19.6.</span> <span class="toc-text">删除事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Redis-%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">9.0.20.</span> <span class="toc-text">21. Redis - 高可用 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">9.0.20.1.</span> <span class="toc-text">全量复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">9.0.20.2.</span> <span class="toc-text">增量复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">9.0.20.3.</span> <span class="toc-text">当主服务器不进行持久化时复制的安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E4%BB%8E%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%E4%BD%BF%E7%94%A8RDB%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8AOF"><span class="toc-number">9.0.20.4.</span> <span class="toc-text">为什么主从全量复制使用RDB而不使用AOF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89%E6%97%A0%E7%A3%81%E7%9B%98%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.0.20.5.</span> <span class="toc-text">为什么还有无磁盘复制模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E4%BC%9A%E6%9C%89%E4%BB%8E%E5%BA%93%E7%9A%84%E4%BB%8E%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.0.20.6.</span> <span class="toc-text">为什么还会有从库的从库的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E5%85%B6%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">9.0.20.7.</span> <span class="toc-text">读写分离及其中的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Redis-%E9%AB%98%E5%8F%AF%E7%94%A8-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6-Redis-Sentinel"><span class="toc-number">9.0.21.</span> <span class="toc-text">22. Redis - 高可用  哨兵机制(Redis Sentinel)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%9A%84%E7%BB%84%E5%BB%BA"><span class="toc-number">9.0.21.1.</span> <span class="toc-text">哨兵集群的组建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Redis%E5%BA%93"><span class="toc-number">9.0.21.2.</span> <span class="toc-text">哨兵监控Redis库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%BA%93%E4%B8%8B%E7%BA%BF%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">9.0.21.3.</span> <span class="toc-text">主库下线的判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%9A%84%E9%80%89%E4%B8%BE"><span class="toc-number">9.0.21.4.</span> <span class="toc-text">哨兵集群的选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E4%B8%BB%E5%BA%93%E7%9A%84%E9%80%89%E5%87%BA"><span class="toc-number">9.0.21.5.</span> <span class="toc-text">新主库的选出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E7%9A%84%E8%BD%AC%E7%A7%BB"><span class="toc-number">9.0.21.6.</span> <span class="toc-text">故障的转移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Redis-%E5%88%86%E7%89%87%E6%8A%80%E6%9C%AF"><span class="toc-number">9.0.22.</span> <span class="toc-text">23. Redis - 分片技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD-Hash-Slot"><span class="toc-number">9.0.22.1.</span> <span class="toc-text">哈希槽(Hash Slot)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Keys-hash-tags"><span class="toc-number">9.0.22.2.</span> <span class="toc-text">Keys hash tags</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cluster-nodes%E5%B1%9E%E6%80%A7"><span class="toc-number">9.0.22.3.</span> <span class="toc-text">Cluster nodes属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cluster%E6%80%BB%E7%BA%BF"><span class="toc-number">9.0.22.4.</span> <span class="toc-text">Cluster总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%8B%93%E6%89%91"><span class="toc-number">9.0.22.5.</span> <span class="toc-text">集群拓扑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">10.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-IoC"><span class="toc-number">10.0.1.</span> <span class="toc-text">1. IoC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIoC"><span class="toc-number">10.0.1.1.</span> <span class="toc-text">什么是IoC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0IoC"><span class="toc-number">10.0.1.2.</span> <span class="toc-text">如何实现IoC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ioc%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">10.0.1.3.</span> <span class="toc-text">Ioc底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DI%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.0.1.4.</span> <span class="toc-text">DI实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IoC%E7%9A%84DI%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.1.5.</span> <span class="toc-text">IoC的DI的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AOP"><span class="toc-number">10.0.2.</span> <span class="toc-text">2. AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOP"><span class="toc-number">10.0.2.1.</span> <span class="toc-text">什么是AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">10.0.2.2.</span> <span class="toc-text">AOP的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.0.2.3.</span> <span class="toc-text">AOP技术实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.0.2.4.</span> <span class="toc-text">AOP实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.0.2.5.</span> <span class="toc-text">AOP实现技术有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.0.2.6.</span> <span class="toc-text">动态代理的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">10.0.2.6.1.</span> <span class="toc-text">JDK动态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">10.0.2.6.2.</span> <span class="toc-text">CGLIB动态代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.2.7.</span> <span class="toc-text">JDK动态代理和CGLIB动态代理有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Bean"><span class="toc-number">10.0.3.</span> <span class="toc-text">3. Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">10.0.3.1.</span> <span class="toc-text">Bean的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8BBean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.3.2.</span> <span class="toc-text">单例Bean线程安全吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">10.0.3.3.</span> <span class="toc-text">Bean有哪几种注入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%EF%BC%88Field-Injection%EF%BC%89"><span class="toc-number">10.0.3.3.1.</span> <span class="toc-text">属性注入（Field Injection）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Setter%E6%B3%A8%E5%85%A5%EF%BC%88Setter-Injection%EF%BC%89"><span class="toc-number">10.0.3.3.2.</span> <span class="toc-text">Setter注入（Setter Injection）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AutoWired%E5%BA%95%E5%B1%82%E6%97%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">10.0.3.4.</span> <span class="toc-text">@AutoWired底层时如何实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.0.3.5.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FactoryBean%E5%92%8CBeanFactory%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.3.6.</span> <span class="toc-text">FactoryBean和BeanFactory的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BeanFactory"><span class="toc-number">10.0.3.6.1.</span> <span class="toc-text">BeanFactory</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FactoryBean"><span class="toc-number">10.0.3.6.2.</span> <span class="toc-text">FactoryBean</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Autowired%E5%92%8CResource%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.4.</span> <span class="toc-text">4. @Autowired和Resource区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.0.5.</span> <span class="toc-text">5. Spring中使用了哪些设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-SpringBoot%E4%BC%98%E7%82%B9"><span class="toc-number">10.0.6.</span> <span class="toc-text">6. SpringBoot优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">10.0.7.</span> <span class="toc-text">7. SpringBoot自动装配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.0.7.1.</span> <span class="toc-text">①. 自动装配工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">10.0.7.2.</span> <span class="toc-text">②. 自动装配流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-SpringBoot%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">10.0.8.</span> <span class="toc-text">8. SpringBoot中如何实现缓存预热</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%90%AF%E5%8A%A8%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.0.8.1.</span> <span class="toc-text">①. 启动监听事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-PostConstruct"><span class="toc-number">10.0.8.2.</span> <span class="toc-text">② @PostConstruct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-CommandLineRunner%E6%88%96ApplicationRunner"><span class="toc-number">10.0.8.3.</span> <span class="toc-text">③. CommandLineRunner或ApplicationRunner</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-%E5%AE%9E%E7%8E%B0InitializingBean%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.0.8.4.</span> <span class="toc-text">④. 实现InitializingBean接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%89%E5%87%A0%E7%A7%8D%E8%8E%B7%E5%8F%96Request%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.0.9.</span> <span class="toc-text">9. 有几种获取Request对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96"><span class="toc-number">10.0.9.1.</span> <span class="toc-text">①. 通过请求参数获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E9%80%9A%E8%BF%87RequestContextHolder%E8%8E%B7%E5%8F%96"><span class="toc-number">10.0.9.2.</span> <span class="toc-text">②. 通过RequestContextHolder获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E9%80%9A%E8%BF%87%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96"><span class="toc-number">10.0.9.3.</span> <span class="toc-text">③. 通过自动注入获取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">10.0.10.</span> <span class="toc-text">10. 拦截器和过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">10.0.10.1.</span> <span class="toc-text">如何实现拦截器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">10.0.10.2.</span> <span class="toc-text">如何实现过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.10.3.</span> <span class="toc-text">拦截器和过滤器的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.10.4.</span> <span class="toc-text">拦截器和动态代理的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">10.0.10.5.</span> <span class="toc-text">拦截器和过滤器的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Spring%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.0.11.</span> <span class="toc-text">11. Spring事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Transactional"><span class="toc-number">10.0.11.1.</span> <span class="toc-text">@Transactional</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transactional-%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">10.0.11.2.</span> <span class="toc-text">@Transactional 失效的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">10.0.11.3.</span> <span class="toc-text">Spring事务传播机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-SpringMVC%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.0.12.</span> <span class="toc-text">5. SpringMVC的核心组件有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">10.0.13.</span> <span class="toc-text">6. SpringMVC工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-SpringMVC%E4%B8%AD%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E5%88%86%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">10.0.14.</span> <span class="toc-text">7. SpringMVC中的重定向和转发分别是如何实现的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">数据库基础和原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">12.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.0.1.</span> <span class="toc-text">1. OSI七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TCP-IP%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.0.2.</span> <span class="toc-text">2. TCP/IP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">12.0.2.1.</span> <span class="toc-text">TCP/IP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">12.0.2.2.</span> <span class="toc-text">TCP如何保证传输的可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">12.0.2.3.</span> <span class="toc-text">TCP如何实现流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">12.0.2.4.</span> <span class="toc-text">TCP的拥塞控制是怎么实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARQ%E5%8D%8F%E8%AE%AE"><span class="toc-number">12.0.2.5.</span> <span class="toc-text">ARQ协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A"><span class="toc-number">12.0.2.6.</span> <span class="toc-text">超时重传如何实现？超时重传时间怎么确定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">12.0.3.</span> <span class="toc-text">3. 常见网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">12.0.3.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">12.0.3.2.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">12.0.3.3.</span> <span class="toc-text">网络层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">12.0.4.</span> <span class="toc-text">4. 从输入URL到页面展示发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">12.0.5.</span> <span class="toc-text">4-1. HTTP协议的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">12.0.5.1.</span> <span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">12.0.5.2.</span> <span class="toc-text">响应报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GET%E4%B8%8EPOST%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">12.0.5.3.</span> <span class="toc-text">GET与POST请求过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">12.0.5.4.</span> <span class="toc-text">HTTP协议的不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">12.0.6.</span> <span class="toc-text">5. HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HTTP%E5%92%8CHTTPS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.7.</span> <span class="toc-text">6. HTTP和HTTPS有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-HTTP-1-0-%E5%92%8CHTTP-1-1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.8.</span> <span class="toc-text">7. HTTP/1.0 和HTTP/1.1有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-HTTP-1-1-%E5%92%8CHTTP-2-0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.9.</span> <span class="toc-text">8. HTTP/1.1 和HTTP/2.0有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-HTTP-2-0-%E5%92%8CHTTP-3-0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.10.</span> <span class="toc-text">9. HTTP/2.0 和HTTP/3.0有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-HTTP%E6%97%B6%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">12.0.11.</span> <span class="toc-text">10. HTTP时不保存状态的协议，如何保存用户状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.0.12.</span> <span class="toc-text">11. URI和URL的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Cookie%E3%80%81Session%E5%92%8CToken%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.13.</span> <span class="toc-text">12. Cookie、Session和Token有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie%E5%92%8CSession%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">12.0.13.1.</span> <span class="toc-text">Cookie和Session有什么关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.14.</span> <span class="toc-text">13. GET和POST的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-WebSocket%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.15.</span> <span class="toc-text">14. WebSocket和HTTP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-WebSocket%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E6%97%B6%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">12.0.16.</span> <span class="toc-text">15. WebSocket的工作过程时怎么样的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-PING"><span class="toc-number">12.0.17.</span> <span class="toc-text">16. PING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-DNS"><span class="toc-number">12.0.18.</span> <span class="toc-text">17. DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.19.</span> <span class="toc-text">18. TCP和UDP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-star2-star2-star2"><span class="toc-number">12.0.20.</span> <span class="toc-text">19. TCP的三次握手和四次挥手:star2::star2::star2:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">12.0.20.1.</span> <span class="toc-text">三次握手建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">12.0.20.2.</span> <span class="toc-text">什么是半连接队列和全连接队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">12.0.20.3.</span> <span class="toc-text">为什么要三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9ESYN%EF%BC%9F"><span class="toc-number">12.0.20.4.</span> <span class="toc-text">第二次握手传回了ACK，为什么还要传回SYN？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%98%9B%EF%BC%9F"><span class="toc-number">12.0.20.5.</span> <span class="toc-text">三次握手过程中可以携带数据嘛？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">12.0.20.6.</span> <span class="toc-text">四次挥手断开连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">12.0.20.7.</span> <span class="toc-text">为什么要四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E9%80%81%E7%9A%84ACK%E5%92%8CFIN%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">12.0.20.8.</span> <span class="toc-text">为什么不把服务端发送的ACK和FIN合并起来，变成三次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84ACK%E6%B2%A1%E6%9C%89%E5%93%A6%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">12.0.20.9.</span> <span class="toc-text">如果第二次挥手时服务端的ACK没有哦送达客户端，会怎么样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852-MSL%EF%BC%88%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD%EF%BC%89%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E4%BC%9A%E8%BF%9B%E5%85%A5CLOSED%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">12.0.20.10.</span> <span class="toc-text">为什么第四次挥手客户端需要等待2*MSL（报文段最长寿命）时间后才会进入CLOSED状态？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">12.0.21.</span> <span class="toc-text">20. TCP如何保证传输的可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7-1"><span class="toc-number">12.0.21.1.</span> <span class="toc-text">TCP如何保证传输的可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-1"><span class="toc-number">12.0.21.2.</span> <span class="toc-text">TCP如何实现流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84-1"><span class="toc-number">12.0.21.3.</span> <span class="toc-text">TCP的拥塞控制是怎么实现的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-IP"><span class="toc-number">12.0.22.</span> <span class="toc-text">21. IP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.0.22.1.</span> <span class="toc-text">IP协议的作用是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIP%E5%9C%B0%E5%9D%80%EF%BC%9FIP%E5%AF%BB%E5%9D%80%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">12.0.22.2.</span> <span class="toc-text">什么是IP地址？IP寻址如何工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-NAT%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.0.23.</span> <span class="toc-text">22. NAT的作用是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.0.24.</span> <span class="toc-text">22. 请求转发和请求重定向有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-ARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">12.0.25.</span> <span class="toc-text">23. ARP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">12.0.26.</span> <span class="toc-text">24. 数字签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">12.0.27.</span> <span class="toc-text">25. 加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">12.0.27.1.</span> <span class="toc-text">对称加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">12.0.27.2.</span> <span class="toc-text">非对称加密</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-JWT"><span class="toc-number">12.0.28.</span> <span class="toc-text">26. JWT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E6%9C%89%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90"><span class="toc-number">12.0.28.1.</span> <span class="toc-text">JWT有哪些部分组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EJWT%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-number">12.0.28.2.</span> <span class="toc-text">如何基于JWT进行身份验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2JWT%E8%A2%AB%E7%AF%A1%E6%94%B9"><span class="toc-number">12.0.28.3.</span> <span class="toc-text">如何防止JWT被篡改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">13.</span> <span class="toc-text">微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">13.0.1.</span> <span class="toc-text">1. 微服务通讯方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RESTful-API-vs-RPC"><span class="toc-number">13.0.1.1.</span> <span class="toc-text">RESTful API vs RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RESTful-API-%E9%80%9A%E8%AE%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.0.1.2.</span> <span class="toc-text">RESTful API 通讯实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RestTemplate%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">13.0.1.3.</span> <span class="toc-text">RestTemplate底层实现及执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFegin%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">13.0.1.4.</span> <span class="toc-text">OpenFegin底层实现及执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPC%E9%80%9A%E8%AE%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.0.1.5.</span> <span class="toc-text">RPC通讯实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Gateway%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">13.0.2.</span> <span class="toc-text">2. Gateway过滤器的分类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%99%90%E6%B5%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">13.0.3.</span> <span class="toc-text">3. 限流的算法有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95"><span class="toc-number">13.0.3.1.</span> <span class="toc-text">计数器算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.0.3.2.</span> <span class="toc-text">漏桶算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.0.3.3.</span> <span class="toc-text">令牌桶算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Sentinel%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81"><span class="toc-number">13.0.4.</span> <span class="toc-text">3. Sentinel如何实现限流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E9%99%90%E6%B5%81"><span class="toc-number">13.0.4.1.</span> <span class="toc-text">通过代码限流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BD%91%E5%85%B3%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81"><span class="toc-number">13.0.5.</span> <span class="toc-text">4. 网关如何实现限流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5"><span class="toc-number">13.0.5.1.</span> <span class="toc-text">限流的常见策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81"><span class="toc-number">13.0.5.2.</span> <span class="toc-text">如何实现限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">13.0.5.3.</span> <span class="toc-text">限流实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%99%90%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">13.0.6.</span> <span class="toc-text">5. 限流的实现方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%B1%82%E9%9D%A2%E9%99%90%E6%B5%81"><span class="toc-number">13.0.6.1.</span> <span class="toc-text">单机层面限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E5%B1%82%E9%99%90%E6%B5%81"><span class="toc-number">13.0.6.2.</span> <span class="toc-text">网关层限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx%E9%99%90%E6%B5%81"><span class="toc-number">13.0.6.3.</span> <span class="toc-text">Nginx限流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.0.7.</span> <span class="toc-text">6. 如何实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">13.0.8.</span> <span class="toc-text">7. 常见的负载均衡策略有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%92%8C%E4%B8%89%E9%98%B6%E6%AE%B5"><span class="toc-number">13.0.9.</span> <span class="toc-text">8. 分布式事务二阶段和三阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">13.0.9.1.</span> <span class="toc-text">二阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">13.0.9.2.</span> <span class="toc-text">三阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4-VS-%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">13.0.9.3.</span> <span class="toc-text">二阶段提交 VS 三阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">13.0.9.4.</span> <span class="toc-text">数据一致性问题和解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Paxos%E7%AE%97%E6%B3%95-%E2%80%94-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">13.0.9.4.1.</span> <span class="toc-text">Paxos算法 —- 共识算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="toc-number">13.0.9.4.2.</span> <span class="toc-text">柔性事务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Nacos"><span class="toc-number">13.0.10.</span> <span class="toc-text">9. Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">13.0.10.1.</span> <span class="toc-text">配置中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">13.0.10.2.</span> <span class="toc-text">注册中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%9C%89%E5%87%A0%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">13.0.10.3.</span> <span class="toc-text">Nacos注册中心有几种调用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">13.0.10.4.</span> <span class="toc-text">客户端与服务端负载均衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-number">13.0.11.</span> <span class="toc-text">10. 服务熔断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81"><span class="toc-number">13.0.12.</span> <span class="toc-text">11. 框架源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Boot%E6%BA%90%E7%A0%81"><span class="toc-number">13.0.12.1.</span> <span class="toc-text">Spring Boot源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">13.0.13.</span> <span class="toc-text">12. 如何解决跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Boot-%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">13.0.13.1.</span> <span class="toc-text">Spring Boot 中解决跨域问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-number">13.0.13.2.</span> <span class="toc-text">Nginx中解决跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-number">13.0.13.3.</span> <span class="toc-text">网关中解决跨域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83"><span class="toc-number">13.0.14.</span> <span class="toc-text">13. 如何实现全链路灰度发布</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx"><span class="toc-number">14.</span> <span class="toc-text">Nginx</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-30"><span class="toc-number">15.</span> <span class="toc-text">7.30</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-On-Write-%E6%8A%80%E6%9C%AF"><span class="toc-number">15.0.1.</span> <span class="toc-text">Copy On Write 技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%AE%97%E6%B3%95%EF%BC%88%E6%AF%94%E8%BE%83%E4%B8%8E%E4%BA%A4%E6%8D%A2%EF%BC%89"><span class="toc-number">15.0.2.</span> <span class="toc-text">CAS算法（比较与交换）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-1"><span class="toc-number">16.</span> <span class="toc-text">8.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JWT"><span class="toc-number">16.0.1.</span> <span class="toc-text">1. JWT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E7%BB%84%E6%88%90"><span class="toc-number">16.0.1.1.</span> <span class="toc-text">JWT组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">16.0.1.2.</span> <span class="toc-text">JWT工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E4%BC%98%E5%8A%BF"><span class="toc-number">16.0.1.3.</span> <span class="toc-text">JWT优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F%EF%BC%9F"><span class="toc-number">16.0.1.4.</span> <span class="toc-text">JWT如何实现自动续期？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%A4%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6"><span class="toc-number">16.0.2.</span> <span class="toc-text">2. 如何优化大表的查询速度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">16.0.2.1.</span> <span class="toc-text">分库分表的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">17.</span> <span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="toc-number">17.0.1.</span> <span class="toc-text">1. 如何设计一个秒杀系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redis%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%EF%BC%8C%E4%B8%8A%E7%99%BE%E4%B8%87%E7%9A%84%E6%96%B0%E9%97%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E6%97%B6%E5%B1%95%E7%A4%BA%E6%9C%80%E7%83%AD%E7%82%B9%E7%9A%84top10%E6%9D%A1%E5%91%A2"><span class="toc-number">17.0.2.</span> <span class="toc-text">2. Redis程序设计中，上百万的新闻，如何实时展示最热点的top10条呢</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">17.0.2.1.</span> <span class="toc-text">1. 实现步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">17.0.2.2.</span> <span class="toc-text">2. 优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">17.0.2.2.1.</span> <span class="toc-text">a. 分页查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E7%83%AD%E5%BA%A6%E5%88%86%E6%95%B0%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">17.0.2.2.2.</span> <span class="toc-text">b. 热度分数更新策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">17.0.2.2.3.</span> <span class="toc-text">c. 数据持久化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="toc-number">17.0.2.2.4.</span> <span class="toc-text">d. 高并发处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">17.0.2.2.5.</span> <span class="toc-text">e. 内存优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%A7%92%E4%BC%A0"><span class="toc-number">17.0.3.</span> <span class="toc-text">3. 大文件上传，如何做到秒传</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-number">17.0.3.1.</span> <span class="toc-text">分片上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">17.0.3.2.</span> <span class="toc-text">断点续传</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0%E4%B8%AD%E8%AE%A2%E5%8D%95%E6%9C%AA%E6%94%AF%E4%BB%98%E8%BF%87%E6%9C%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD"><span class="toc-number">17.0.4.</span> <span class="toc-text">4. 电商平台中订单未支付过期如何实现自动关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">17.0.4.1.</span> <span class="toc-text">①. 定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-JDK%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97DelayQueue"><span class="toc-number">17.0.4.2.</span> <span class="toc-text">②. JDK延迟队列DelayQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-Redis%E8%BF%87%E6%9C%9F%E7%9B%91%E5%90%AC"><span class="toc-number">17.0.4.3.</span> <span class="toc-text">③. Redis过期监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97RDelayQueue"><span class="toc-number">17.0.4.4.</span> <span class="toc-text">④. Redisson分布式延迟队列RDelayQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-number">17.0.4.5.</span> <span class="toc-text">⑤. 延迟消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5-RabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">17.0.4.6.</span> <span class="toc-text">⑥. RabbitMQ死信队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F"><span class="toc-number">17.0.5.</span> <span class="toc-text">如何设计一个高并发系统</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/test00/" title="test00">test00</a><time datetime="2024-08-22T11:09:02.000Z" title="发表于 2024-08-22 19:09:02">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/test-1/" title="test">test</a><time datetime="2024-08-22T10:57:46.000Z" title="发表于 2024-08-22 18:57:46">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/test/" title="test">test</a><time datetime="2024-08-22T10:52:27.791Z" title="发表于 2024-08-22 18:52:27">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="java常见面试题总结">java常见面试题总结</a><time datetime="2024-08-22T06:18:03.190Z" title="发表于 2024-08-22 14:18:03">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/24/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/" title="简历相关问题">简历相关问题</a><time datetime="2024-07-24T13:12:01.186Z" title="发表于 2024-07-24 21:12:01">2024-07-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By hzf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>