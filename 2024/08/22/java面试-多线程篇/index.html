<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java面试-多线程篇 | 草莓熊的秘密基地</title><meta name="author" content="hzf"><meta name="copyright" content="hzf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 进程和线程的区别及优缺点进程是操作系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间、数据栈和程序计数器。进程的创建、切换和撤销都需要操作系统进行较多的资源操作，如内存分配。进程间通信（IPC）通常需要借助操作系统提供的机制，如管道、消息队列、共享内存等。进程的创建和撤销开销较大，切换速度慢。 线程是进程内的执行单元，是CPU调度和分派的基本单位。一个进程可以有多个线程，它们共">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试-多线程篇">
<meta property="og:url" content="https://huzongfei.github.io/2024/08/22/java%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/index.html">
<meta property="og:site_name" content="草莓熊的秘密基地">
<meta property="og:description" content="1. 进程和线程的区别及优缺点进程是操作系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间、数据栈和程序计数器。进程的创建、切换和撤销都需要操作系统进行较多的资源操作，如内存分配。进程间通信（IPC）通常需要借助操作系统提供的机制，如管道、消息队列、共享内存等。进程的创建和撤销开销较大，切换速度慢。 线程是进程内的执行单元，是CPU调度和分派的基本单位。一个进程可以有多个线程，它们共">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-08-22T12:39:09.951Z">
<meta property="article:modified_time" content="2024-08-22T13:57:54.657Z">
<meta property="article:author" content="hzf">
<meta property="article:tag" content="积少成多">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huzongfei.github.io/2024/08/22/java%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java面试-多线程篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-22 21:57:54'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="草莓熊的秘密基地"><span class="site-name">草莓熊的秘密基地</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面试-多线程篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-22T12:39:09.951Z" title="发表于 2024-08-22 20:39:09">2024-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-22T13:57:54.657Z" title="更新于 2024-08-22 21:57:54">2024-08-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java面试-多线程篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-进程和线程的区别及优缺点"><a href="#1-进程和线程的区别及优缺点" class="headerlink" title="1. 进程和线程的区别及优缺点"></a>1. 进程和线程的区别及优缺点</h2><p>进程是操作系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间、数据栈和程序计数器。进程的创建、切换和撤销都需要操作系统进行较多的资源操作，如内存分配。进程间通信（IPC）通常需要借助操作系统提供的机制，如管道、消息队列、共享内存等。进程的创建和撤销开销较大，切换速度慢。</p>
<p>线程是进程内的执行单元，是CPU调度和分派的基本单位。一个进程可以有多个线程，它们共享进程的资源，如内存空间、数据栈和程序计数器。线程之间共享进程的资源，包括内存空间。线程的创建、切换和撤销相对进程开销较小。线程间可以直接通过共享内存进行通信，不需要借助系统调用。</p>
<h2 id="2-线程等待和唤醒有几种实现"><a href="#2-线程等待和唤醒有几种实现" class="headerlink" title="2. 线程等待和唤醒有几种实现"></a>2. 线程等待和唤醒有几种实现</h2><p>在 Java 中，线程等待和唤醒的实现手段有以下几种方式：</p>
<ol>
<li>Object 类下的 wait()、notify() 和 notifyAll() 方法；</li>
<li>Condition 类下的 await()、signal() 和 signalAll() 方法；</li>
<li>LockSupport 类下的 park() 和 unpark() 方法。</li>
</ol>
<h3 id="2-1-wait-notify-notifyAll"><a href="#2-1-wait-notify-notifyAll" class="headerlink" title="2.1 wait()/notify()/notifyAll()"></a>2.1 wait()/notify()/notifyAll()</h3><p>Object 类的方法说明：</p>
<ol>
<li>wait()：让当前线程处于等待状态，并释放当前拥有的锁；</li>
<li>notify()：随机唤醒等待该锁的其他线程，重新获取锁，并执行后续的流程，只能唤醒一个线程；</li>
<li>notifyAll()：唤醒所有等待该锁的线程（锁只有一把，虽然所有线程被唤醒，但所有线程需要排队执行）。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 创建线程并执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"线程1：开始执行"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"线程1：进入等待"</span>);</span><br><span class="line">            lock.wait();</span><br><span class="line">            System.out.println(<span class="string">"线程1：继续执行"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"线程1：执行完成"</span>);</span><br><span class="line">    }</span><br><span class="line">}).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (lock) {</span><br><span class="line">    <span class="comment">// 唤醒线程</span></span><br><span class="line">    System.out.println(<span class="string">"执行 notifyAll()"</span>);</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-await-signal-signalAll"><a href="#2-2-await-signal-signalAll" class="headerlink" title="2.2. await()/signal()/signalAll()"></a>2.2. await()/signal()/signalAll()</h3><p>Condition 类的方法说明：</p>
<ol>
<li>await()：对应 Object 的 wait() 方法，线程等待；</li>
<li>signal()：对应 Object 的 notify() 方法，随机唤醒一个线程；</li>
<li>signalAll()：对应 Object 的 notifyAll() 方法，唤醒所有线程。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Condition 对象</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// lock 下可创建多个 Condition</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 业务方法......</span></span><br><span class="line">    <span class="comment">// 1.进入等待状态</span></span><br><span class="line">    condition.await();</span><br><span class="line">    <span class="comment">// 2.唤醒操作</span></span><br><span class="line">    condition.signal();</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-3-park-unpark"><a href="#2-3-park-unpark" class="headerlink" title="2.3. park/unpark"></a>2.3. park/unpark</h3><p>LockSupport 类的方法说明：</p>
<ol>
<li>LockSupport.park()：休眠当前线程。</li>
<li>LockSupport.unpark(线程对象)：唤醒某一个指定的线程。</li>
</ol>
<blockquote>
<p>PS：LockSupport 无需配锁（synchronized 或 Lock）一起使用。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">"线程1"</span>);</span><br><span class="line">    }, <span class="string">"线程1"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"唤醒线程1"</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    }, <span class="string">"线程2"</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>【总结】1. <strong>LockSupport 存在的必要性</strong>：前两种方法 notify 方法以及 signal 方法都是随机唤醒，如果存在多个等待线程的话，可能会唤醒不应该唤醒的线程，因此有 LockSupport 类下的 park 和 unpark 方法指定唤醒线程是非常有必要的。</p>
<p><strong>Condition 存在的必要性</strong>：Condition 相比于 Object 类的 wait 和 notify/notifyAll 方法，前者可以创建多个等待集，例如，我们可以创建一个生产者等待唤醒对象，和一个消费者等待唤醒对象，这样我们就能实现生产者只能唤醒消费者，而消费者只能唤醒生产者的业务逻辑了，如下代码所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Condition 对象</span><br><span class="line">private Lock lock = new ReentrantLock();</span><br><span class="line">// 生产者的 Condition 对象</span><br><span class="line">private Condition producerCondition = lock.newCondition();</span><br><span class="line">// 消费者的 Condition 对象</span><br><span class="line">private Condition consumerCondition = lock.newCondition();</span><br></pre></td></tr></tbody></table></figure>

<p>也就是 Condition 是 Object 等待唤醒模型的升级，Object 类可以实现的功能它都能实现，但 Condition 能实现的功能，Object 却不能实现，这就是 Condition 类存在的必要性。</p>
<h2 id="3-如何创建线程"><a href="#3-如何创建线程" class="headerlink" title="3. 如何创建线程"></a>3. 如何创建线程</h2><p><strong>继承Thread类、 实现Runnable接口、 实现Callable接口、使用线程池、使用<code>CompletableFuture</code>类等等。</strong></p>
<p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。</p>
<p>严格来说，<strong>Java 就只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。</strong>不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {System.out.println(<span class="string">"Thread is running"</span>);}}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();}}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Thread is running"</span>);}}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Callable接口</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用线程池</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用CompletableFuture类：</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Thread is running"</span>);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-说说线程的生命周期和状态？"><a href="#4-说说线程的生命周期和状态？" class="headerlink" title="4. 说说线程的生命周期和状态？"></a>4. 说说线程的生命周期和状态？</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>
<ul>
<li><strong>NEW</strong>: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li>
<li><strong>RUNNABLE</strong>: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li>
<li><strong>BLOCKED</strong>：阻塞状态，需要等待锁释放。</li>
<li><strong>WAITING</strong>：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li><strong>TIME_WAITING</strong>：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li><strong>TERMINATED</strong>：终止状态，表示该线程已经运行完毕。</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<p><strong>调用两次线程的start会怎么样：抛出<code>IllegalThreadStateException</code>异常</strong></p>
<h2 id="5-为什么要使用多线程"><a href="#5-为什么要使用多线程" class="headerlink" title="5. 为什么要使用多线程"></a>5. 为什么要使用多线程</h2><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li>
</ul>
<h2 id="6-使用多线程可能会带来什么问题？"><a href="#6-使用多线程可能会带来什么问题？" class="headerlink" title="6. 使用多线程可能会带来什么问题？"></a>6. 使用多线程可能会带来什么问题？</h2><p>并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>
<h2 id="7-单核CPU上运行多个线程效率一定会高吗？"><a href="#7-单核CPU上运行多个线程效率一定会高吗？" class="headerlink" title="7. 单核CPU上运行多个线程效率一定会高吗？"></a>7. 单核CPU上运行多个线程效率一定会高吗？</h2><p>单核 CPU 同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。一般来说，有两种类型的线程：CPU 密集型和 IO 密集型。CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。</p>
<p>在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配。如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p>
<p><strong>因此，对于单核 CPU 来说，如果任务是 CPU 密集型的，那么开很多线程会影响效率；如果任务是 IO 密集型的，那么开很多线程会提高效率。</strong>当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p>
<h2 id="8-多线程环境下，时间片轮询是如何工作的？"><a href="#8-多线程环境下，时间片轮询是如何工作的？" class="headerlink" title="8. 多线程环境下，时间片轮询是如何工作的？"></a>8. 多线程环境下，时间片轮询是如何工作的？</h2><p>多线程环境下，时间片轮询（Time-sharing）是一种操作系统调度策略，用于分派CPU的时间资源给多个线程。这种策略通常应用于分时系统，它将CPU的时间分割成小的时间片段，称为时间片，并按照线程的优先级或调度策略分配这些时间片段给不同的线程。</p>
<p>在多线程环境下，时间片轮询的工作流程大致如下：</p>
<ol>
<li><strong>线程调度</strong>：操作系统负责调度线程，决定哪个线程将在下一个时间片内执行。</li>
<li><strong>时间片分配</strong>：操作系统为每个线程分配一个时间片，线程在时间片内执行。</li>
<li><strong>时间片耗尽</strong>：当线程的时间片用完时，操作系统会暂停该线程的执行，并将其状态保存到线程调度队列中。</li>
<li><strong>线程切换</strong>：操作系统选择另一个线程并恢复其状态，然后该线程开始执行。</li>
<li><strong>循环执行</strong>：上述过程会不断循环，每个线程都有机会执行，直到所有的线程都执行完毕或等待其他事件的发生。</li>
</ol>
<p>时间片轮询的主要优点是公平地分配CPU时间，使得每个线程都能得到执行的机会。然而，如果线程切换过于频繁，可能会导致性能下降，因为线程切换本身需要一定的开销。</p>
<h2 id="9-并发和并行的区别"><a href="#9-并发和并行的区别" class="headerlink" title="9. 并发和并行的区别"></a>9. 并发和并行的区别</h2><p><strong>并发</strong>：两个及以上的作业在同一<strong>时间段</strong>内执行。</p>
<p><strong>并行</strong>：两个及以上的作业在同一<strong>时刻</strong>执行。</p>
<h2 id="10-同步和异步的区别"><a href="#10-同步和异步的区别" class="headerlink" title="10. 同步和异步的区别"></a>10. 同步和异步的区别</h2><p><strong>同步</strong>：发出一个调用之后，在没有得到结果之间，该调用就不可以返回，一直等待。</p>
<p><strong>异步</strong>：调用在发出后，不用等待返回结果，该调用直接返回。</p>
<h2 id="11-什么是线程上下文切换？"><a href="#11-什么是线程上下文切换？" class="headerlink" title="11. 什么是线程上下文切换？"></a>11. 什么是线程上下文切换？</h2><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h2 id="12-什么是线程死锁？"><a href="#12-什么是线程死锁？" class="headerlink" title="12. 什么是线程死锁？"></a>12. 什么是线程死锁？</h2><p><strong>认识线程死锁</strong></p>
<p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p><strong>产生死锁的四个必要条件</strong></p>
<p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</p>
<h2 id="13-如何预防和避免线程死锁"><a href="#13-如何预防和避免线程死锁" class="headerlink" title="13.如何预防和避免线程死锁"></a>13.如何预防和避免线程死锁</h2><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<blockquote>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p>
</blockquote>
<hr>
<h2 id="14-sleep-方法和wait-方法对比"><a href="#14-sleep-方法和wait-方法对比" class="headerlink" title="14. sleep()方法和wait()方法对比"></a>14. sleep()方法和wait()方法对比</h2><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong>：</p>
<ul>
<li>sleep()方法导致了程序暂停执行指定的时间，让出CPU给其他线程，但是他的监控状态依然保持者，当<strong>指定的时间到了又会自动恢复运行状态</strong>。在调用sleep()方法的过程中，<strong>线程不会释放对象锁。</strong></li>
<li>当调用wait()方法的时候，<strong>线程会放弃对象锁，进入等待此对象的等待锁定池</strong>，只有针对此对象<strong>调用notify()方法后本线程才进入对象锁定池准备</strong>，获取对象锁进入运行状态。</li>
<li>对于sleep()方法，我们首先要知道该方法是<strong>属于Thread类</strong>中的。而wait()方法，则是属于<strong>Object类</strong>中的。</li>
</ul>
<p>【注】为什么 wait()方法不定义在Thread 中？为什么 sleep()方法定义在 Thread 中？</p>
<p>wait()是让<strong>获得对象锁的线程实现等待</strong>，会<strong>自动释放</strong>当前线程<strong>占有的对象锁</strong>。每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，<strong>自然是要操作对应的对象</strong>（Object）而非当前的线程（Thread）。因为 sleep()是让<strong>当前线程暂停执行</strong>，<strong>不涉及到对象类</strong>，也不需要获得对象锁。</p>
<h2 id="15-线程池-star2-star2-star2-star2-star2"><a href="#15-线程池-star2-star2-star2-star2-star2" class="headerlink" title="15. 线程池 :star2::star2::star2::star2::star2:"></a>15. 线程池 :star2::star2::star2::star2::star2:</h2><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>合理利用线程池能够带来三个好处：</p>
<p><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗</p>
<p><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行</p>
<p><strong>提高线程的可管理性。</strong>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="常用的线程池有哪些？"><a href="#常用的线程池有哪些？" class="headerlink" title="常用的线程池有哪些？"></a>常用的线程池有哪些？</h3><ul>
<li><p><strong><code>newSingleThreadExecutor</code><strong>：</strong>创建一个单线程的线程池</strong>，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</li>
<li><p><strong><code>newFixedThreadPool</code><strong>：</strong>创建固定大小的线程池</strong>，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</p>
</li>
<li><p><strong><code>newCachedThreadPool</code><strong>：可</strong>根据实际情况调整线程数量</strong>的线程池。线程池的<strong>线程数量不确定</strong>，但若<strong>有空闲线程可以复用</strong>，则会优先使用可复用的线程。若<strong>所有线程均在工作</strong>，又有新的任务提交，则<strong>会创建新的线程处理任务</strong>。所有线程在当前任务执行完毕后，将<strong>返回线程池进行复用</strong>。</p>
</li>
<li><p><code>newScheduledThreadPool</code>：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个newSingleThreadExecutor</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 创建一个newfixedThreadPool</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 创建一个newCachedThreadPool</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 创建一个newScheduledThreadPool</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool();</span><br></pre></td></tr></tbody></table></figure>

<p>【注】为什么不使用已有的线程池方法创建线程：<strong>FixedThreadPool 和 <strong>Single</strong>ThreadExecutor:使用的是</strong>无界的 <strong>LinkedBlockingQueue</strong>，任务队列最大长度为 Integer.MAX_VALUE,<strong>可能堆积大量的请求，从而导致</strong> <strong>OOM</strong>。<strong>newCachedThreadPool</strong>使用的是 <strong>同步队列SynchronousQueue</strong>, 允许创建的线程数量为Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。<strong>newScheduledThreadPool</strong>使用的 <strong>无界的延迟阻塞队列DelayedWorkQueue</strong>，任务队列最大长度为Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</p>
<h3 id="Java线程池中任务队列-阻塞队列常用类型有哪些？"><a href="#Java线程池中任务队列-阻塞队列常用类型有哪些？" class="headerlink" title="Java线程池中任务队列/阻塞队列常用类型有哪些？"></a>Java线程池中任务队列/阻塞队列常用类型有哪些？</h3><p>在某些情况下，线程池的任务队列可以是阻塞队列。</p>
<p>在Java的<code>ExecutorService</code>接口中，线程池通常会<strong>使用一个队列来存储等待执行的任务</strong>。常见的队列类型有：</p>
<ul>
<li>:book: <strong><code>LinkedBlockingQueue</code><strong>：这是一个基于链表的</strong>阻塞队列</strong>，可以设置队列容量，如果不设置，默认容量为<code>Integer.MAX_VALUE</code>，即<strong>队列可以无限大</strong>。</li>
<li>:book: <strong><code>ArrayBlockingQueue</code><strong>：这是一个基于数组的</strong>阻塞队列</strong>，可以指定队列容量，如果队列已满，则新加入的元素将被阻塞。</li>
</ul>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**【区别】LinkedBlockingQueue和ArrayBlockingQueue的区别**</span></span><br><span class="line"></span><br><span class="line">​底层：ArrayBlockingQueue<span class="code">`基于数组`</span>，LinkedBlockingQueue<span class="code">`基于链表`</span></span><br><span class="line"></span><br><span class="line">​有界/无界：ArrayBlockingQueue是<span class="code">`有界的`</span>，LinkedBlockingQueue<span class="code">`近似无界`</span></span><br><span class="line"></span><br><span class="line">​初始化：ArrayBlockingQueue<span class="code">`初始化时必须分配大小`</span>，LinkedBlockingQueue<span class="code">`动态分配内存大小`</span></span><br><span class="line"></span><br><span class="line">​锁分离：ArrayBlockingQueue<span class="code">`生产和消费用的是同一个锁`</span>，LinkedBlockingQueue<span class="code">`生产用的是putLock,消费用的是takeLock`</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>:book: <strong><code>PriorityBlockingQueue</code><strong>：这是一个基于优先级的</strong>无界阻塞队列</strong>，通常用于优先级高的任务。元素必须<strong>实现</strong> <strong>Comparable接口</strong>或者<strong>在构造函数中传入</strong> <strong>Comparator对象</strong>，并且<strong>不能插入</strong> <strong>null</strong> <strong>元素</strong>。</p>
</li>
<li><p>:book: <strong><code>DelayQueue</code><strong>：</strong>延迟队列</strong>，其中的元素只有<strong>到了其指定的延迟时间</strong>，才从队列中出队。</p>
</li>
<li><p>**<code>PriorityQueue</code>**：这是一个非阻塞的优先级队列，通常用于优先级高的任务。</p>
</li>
<li><p>:book: <strong><code>SynchronousQueue</code><strong>：同步队列是一种</strong>不存储元素</strong>的阻塞队列。每个<strong>插入操作</strong>都必须<strong>等待对应</strong>的<strong>删除操作</strong>，反之删除操作也必须等待插入操作。因此，SynchronousQueue 通常用于线程之间的<strong>直接传递数据</strong>。</p>
</li>
</ul>
<p>[注]newCachedThreadPool创建线程池使用SynchronousQueue，会导致创建大量线程从而导致OOM</p>
<p>在创建<code>ThreadPoolExecutor</code>时，可以<strong>通过<code>setQueue(BlockingQueue&lt;Runnable&gt; workQueue)</code>方法来指定队列类型</strong>。队列的选择会影响线程池的性能和行为，例如：</p>
<ul>
<li>使用无界队列可以提高吞吐量，但可能会导致内存溢出。</li>
<li>使用有界队列可以限制内存使用，但可能会导致队列满时新任务被拒绝。</li>
</ul>
<p>选择合适的队列类型对于设计有效的线程池至关重要。通常，根据任务的特性、系统的内存限制和期望的性能指标来选择合适的队列类型。</p>
<h3 id="线程池原理知道吗？以及核心参数"><a href="#线程池原理知道吗？以及核心参数" class="headerlink" title="线程池原理知道吗？以及核心参数"></a>线程池原理知道吗？以及核心参数</h3><p>首先线程池有几个核心的参数概念：</p>
<ol>
<li><p>**核心线程数 **corePoolSize</p>
</li>
<li><p><strong>最大线程数</strong> maximumPoolSize</p>
</li>
<li><p><strong>活跃时间</strong> keepAliveTime</p>
</li>
<li><p><strong>unit</strong>  keepAliveTimede参数的时间单位</p>
</li>
<li><p><strong>工作队列</strong> workQueue</p>
</li>
<li><p><strong>线程工厂</strong> threadFactory</p>
</li>
<li><p><strong>拒绝策略</strong> RejectedExecutionHandler</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.MINUTES,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy())</span><br></pre></td></tr></tbody></table></figure>

<p>当提交一个新任务到线程池时，具体的执行流程如下：</p>
<ol>
<li><p>当我们提交任务，<strong>线程池会根据corePoolSize大小创建若干任务数量线程执行任务</strong>；</p>
</li>
<li><p>当任务的数量超过corePoolSize数量，<strong>后续的任务将会进入阻塞队列阻塞排队</strong>；</p>
</li>
<li><p>当阻塞队列也满了之后<strong>，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来执行任务</strong>，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程<strong>等待keepAliveTime之后被自动销毁</strong>；</p>
</li>
<li><p><strong>如果达到<code>maximumPoolSize</code>，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理</strong></p>
</li>
</ol>
<p><img src="/../images/image-20240430165555822.png" alt="image-20240430165555822"></p>
<h3 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h3><p>主要有4种拒绝策略：</p>
<ol>
<li><p><strong><code>AbortPolicy</code><strong>：</strong>直接丢弃任务，抛出异常，这是默认策略</strong></p>
</li>
<li><p>**<code>CallerRunsPolicy</code>**：只用调用者所在的线程来处理任务 。 <code>ExecutorService</code>会检查当前线程是否是调用者线程（即提交任务的线程）(使用<code>Thread.currentThread()</code>)。如果当前线程是调用者线程，<code>ExecutorService</code>会将该任务重新提交给调用者线程执行。如果当前线程不是调用者线程，<code>ExecutorService</code>会抛出一个<code>RejectedExecutionException</code>异常，表明该任务被拒绝执行。</p>
</li>
<li><p><strong><code>DiscardOldestPolicy</code><strong>：</strong>丢弃等待队列中最旧</strong>的任务，并执行当前任务</p>
</li>
<li><p>**<code>DiscardPolicy</code>**：直接丢弃任务，也不抛出异常</p>
</li>
</ol>
<h3 id="线程池中核心线程数量大小怎么设置"><a href="#线程池中核心线程数量大小怎么设置" class="headerlink" title="线程池中核心线程数量大小怎么设置"></a>线程池中核心线程数量大小怎么设置</h3><p><em><em>CPU密集型：核心线程数 = N(CPU核心数量)+1 ———- IO密集型：核心线程数 = N(CPU核心数量)</em> 2</em>*     i7-12700的CPU核心数位12，所以我一般设置的核心线程数为13</p>
<p><strong>CPU密集型任务</strong>：比如像<strong>加解密，压缩、计算等一系列需要大量耗费 CPU 资源的任务</strong>，大部分场景下都是纯 CPU 计算。<strong>尽量使用较小的线程池，一般为CPU核心数+1。</strong>因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。 i7-12700的CPU核心数位12，所以我一般设置的核心线程数为24</p>
<p><strong>IO密集型任务：</strong>比如像 <strong>MySQL 数据库、文件的读写、网络通信等任务</strong>，这类任务不会特别消耗 CPU 资源，但是 IO 操作比较耗时，会占用比较多时间。<strong>可以使用稍大的线程池，一般为2*CPU核心数。</strong>IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。 </p>
<p>另外：<strong>线程的平均工作时间所占比例越高，就需要越少的线程</strong>；线程的平均等待时间所占比例越高，就需要越多的线程； 以上只是理论值，实际项目中建议在本地或者测试环境进行多次调优，找到相对理想的值大小。</p>
<h2 id="16-CompletableFuture类-star-star-star-star"><a href="#16-CompletableFuture类-star-star-star-star" class="headerlink" title="16.CompletableFuture类 :star::star::star::star:"></a>16.CompletableFuture类 :star::star::star::star:</h2><p>CompletableFuture 类提供一种<strong>观察者模式机制</strong>，可以让任务执行完成后通知监听的一方。CompletableFuture 同时实现了 Future 接口和CompletionStage 接口。CompletionStage 接口描述了一个<strong>异步计算的阶段</strong>。很多计算可以<strong>分成多个阶段或步骤</strong>，此时可以通过它将所有步骤组合起来，<strong>形成异步计算的流水线</strong>。</p>
<p><strong>四个静态方法：</strong></p>
<ul>
<li>无返回值：<strong>run</strong>Async(Runnable r)；runAsync(Runnable r, Executor e)</li>
<li>有返回值：<strong>supply</strong>Async(Supplier&lt;\U&gt; s)；supplyAsync(Supplier&lt;\U&gt; s, Executor e)</li>
</ul>
<p>【注】没有指定 Executor 的方法，<strong>默认</strong>使用 <strong>ForkJoinPool()<strong>作为线程池执行异步代码，该线程池</strong>全局共享</strong>，可能会<strong>被其他任务占用</strong>，导致<strong>性能下降或者饥饿</strong>。</p>
<p><strong>CompletableFuture 类获得结果的方法</strong> —不完整</p>
<ul>
<li>get()阻塞等待；get(时间，单位)超时报异常；</li>
<li>join()和get区别：编译不用抛Interrupte异常；getNow(valueIfAbsent):没计算完就返回该值；</li>
</ul>
<p><strong>处理异步计算的结果</strong></p>
<ul>
<li>有返回值，可以访问异步结果—thenApply()：<strong>函数型接口</strong>，s-&gt;{处理上一步的结果 s，<strong>有返回值</strong> <strong>return;</strong>}</li>
<li>没有返回值，可以访问异步结果—thenAccept()：<strong>消费型接口</strong>；</li>
<li>没有返回值，不可以访问异步结果—thenRun()：方法参数是 <strong>Runnable</strong>；</li>
</ul>
<p><strong>处理异常结果</strong></p>
<p>handle()：跟 thenApply()的区别在于，有异常的时候，可以往下多走一步，根据带的异常参数可以进一步处理。</p>
<p><strong>CompletableFuture 的组合</strong></p>
<ul>
<li><strong>thenCompose()：</strong>将前一个任务的<strong>返回结果作为下一个任务的参数</strong>，它们之间存<strong>在着先后顺序</strong>。</li>
<li><strong>thenCombine()：</strong>会在<strong>两个任务都执行完成后</strong>，把两个任务的<strong>结果合并</strong>。两个任务并行。</li>
</ul>
<p><strong>并行运行多个 CompletableFuture（静态）</strong></p>
<ul>
<li>allOf()：并行运行多个 CompletableFuture，等<strong>所有任务都运行完</strong>成之后<strong>再返回结果</strong>；</li>
<li>anyOf()：返回<strong>最先执行完</strong>的<strong>任务结果</strong>。</li>
</ul>
<h2 id="17-线程安全需要保证几个基本特征？"><a href="#17-线程安全需要保证几个基本特征？" class="headerlink" title="17. 线程安全需要保证几个基本特征？"></a>17. 线程安全需要保证几个基本特征？</h2><p><strong>原子性</strong>：简单来说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</p>
<p><strong>可见性</strong>：是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。</p>
<p><strong>有序性</strong>：保证线程内串行语义，避免指令重排等</p>
<h2 id="18-线程之间的通信"><a href="#18-线程之间的通信" class="headerlink" title="18. 线程之间的通信"></a>18. 线程之间的通信</h2><p>线程之间的通信有两种方式：共享内存和消息传递。</p>
<p><strong>共享内存</strong>：在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p><strong>消息传递</strong>：在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 wait() 和 notify() ，或者 <code>BlockingQueue</code> 。</p>
<h2 id="19-CSA"><a href="#19-CSA" class="headerlink" title="19. CSA"></a>19. CSA</h2><h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>CAS（Compare and Swap，比较并交换）是一种硬件指令，用于实现无锁的数据结构。CAS的原理是：</p>
<ol>
<li><strong>比较</strong>：首先，它会将内存中的值与一个预期的值进行比较。</li>
<li><strong>交换</strong>：如果内存中的值与预期的值相匹配，它就会将内存中的值更新为新值。</li>
<li><strong>成功与失败</strong>：如果比较成功，即内存中的值与预期值相匹配，则交换操作成功，CAS会返回<code>true</code>。如果比较失败，即内存中的值与预期值不匹配，则交换操作失败，CAS会返回<code>false</code>。</li>
</ol>
<p>CAS的原理基于CPU提供的原子操作指令，如<code>cmpxchg</code>（比较并交换）指令。CAS操作是原子的，这意味着在比较和交换的过程中，不会有其他线程能够修改内存中的值。这保证了在多线程环境下，CAS操作是线程安全的。</p>
<h3 id="CSA的缺点？"><a href="#CSA的缺点？" class="headerlink" title="CSA的缺点？"></a>CSA的缺点？</h3><p>CAS（Compare and Swap，比较并交换）是一种高效的同步机制，用于实现无锁的数据结构。尽管CAS在多线程环境下提供了很好的性能，但它也存在一些缺点：</p>
<ol>
<li><strong>ABA问题</strong>：CAS操作中的比较是基于内存地址和值进行的，如果两个线程同时执行CAS操作，并且第一个线程成功更新了内存中的值，而第二个线程仍然使用旧的值进行比较，那么它可能会误认为值没有变化，从而导致数据不一致。为了解决这个问题，通常需要引入版本号或者时间戳来跟踪值的变化。</li>
<li><strong>循环时间长</strong>：当一个线程执行CAS操作失败时，它需要等待并再次尝试执行CAS操作。如果这个线程一直在循环中执行CAS操作而没有成功，它会浪费大量的CPU时间。</li>
<li><strong>伪共享</strong>：伪共享是指当多个变量位于同一个缓存行时，即使这些变量是独立的，更新其中一个变量也可能会影响其他变量。在多核处理器上，这可能会导致性能问题。</li>
<li><strong>性能开销</strong>：尽管CAS操作本身很快，但当它失败时，可能会导致线程挂起和唤醒的开销，这可能会抵消CAS操作的性能优势。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：CAS操作通常只能保证对一个共享变量的原子操作，如果要同时更新多个共享变量，则需要其他同步机制。</li>
</ol>
<p>为了克服这些缺点，Java提供了一些高级的同步类，如<code>AtomicInteger</code>、<code>AtomicReference</code>等，这些类在内部实现了CAS操作，并提供了解决ABA问题的机制。此外，还有一些高级的数据结构，如<code>AtomicMarkableReference</code>，它们能够同时支持CAS操作和标记操作，以解决更复杂的问题。</p>
<h2 id="20-引用类型有哪些？有什么区别？"><a href="#20-引用类型有哪些？有什么区别？" class="headerlink" title="20. 引用类型有哪些？有什么区别？"></a>20. 引用类型有哪些？有什么区别？</h2><p>引用类型主要分为强软虚弱四种：</p>
<ol>
<li><strong>强引用（Strong Reference）</strong>：这是最常见的引用类型。如果一个对象有强引用指向它，那么这个对象就不会被垃圾收集器回收，直到强引用被解除或对象被垃圾收集器标记为不可达。</li>
<li><strong>软引用（Soft Reference）</strong>：软引用是指向那些有用但不是必需的对象的引用。如果内存不足，垃圾收集器会回收软引用指向的对象，以便为其他对象腾出空间。</li>
<li><strong>弱引用（Weak Reference）</strong>：弱引用是指向那些非必需且不太可能被使用的对象的引用。垃圾收集器会定期检查弱引用指向的对象，如果对象不再被任何强引用或软引用所指向，那么垃圾收集器会立即回收该对象。</li>
<li><strong>虚引用（Phantom Reference）</strong>：虚引用也称为幻象引用，它指向那些只被虚引用所引用的对象。当对象被垃圾收集器回收时，垃圾收集器会发送一个通知给虚引用。虚引用不能用来获取对象实例，因为它们总是为<code>null</code>。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huzongfei.github.io">hzf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huzongfei.github.io/2024/08/22/java%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/">https://huzongfei.github.io/2024/08/22/java%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huzongfei.github.io" target="_blank">草莓熊的秘密基地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/08/22/java%E9%9D%A2%E8%AF%95-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">hzf</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">1. 进程和线程的区别及优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">2. 线程等待和唤醒有几种实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-wait-notify-notifyAll"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 wait()/notify()/notifyAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-await-signal-signalAll"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. await()/signal()/signalAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-park-unpark"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. park/unpark</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3. 如何创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4. 说说线程的生命周期和状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">5. 为什么要使用多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6. 使用多线程可能会带来什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8D%95%E6%A0%B8CPU%E4%B8%8A%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%95%88%E7%8E%87%E4%B8%80%E5%AE%9A%E4%BC%9A%E9%AB%98%E5%90%97%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">7. 单核CPU上运行多个线程效率一定会高吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%AF%A2%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">8. 多线程环境下，时间片轮询是如何工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">9. 并发和并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">10. 同步和异步的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">11. 什么是线程上下文切换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">12. 什么是线程死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">13.</span> <span class="toc-text">13.如何预防和避免线程死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-sleep-%E6%96%B9%E6%B3%95%E5%92%8Cwait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">14.</span> <span class="toc-text">14. sleep()方法和wait()方法对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%BA%BF%E7%A8%8B%E6%B1%A0-star2-star2-star2-star2-star2"><span class="toc-number">15.</span> <span class="toc-text">15. 线程池 :star2::star2::star2::star2::star2:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">15.1.</span> <span class="toc-text">线程池的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">15.2.</span> <span class="toc-text">常用的线程池有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">15.3.</span> <span class="toc-text">Java线程池中任务队列/阻塞队列常用类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">15.4.</span> <span class="toc-text">线程池原理知道吗？以及核心参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">15.5.</span> <span class="toc-text">线程池的拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E5%A4%A7%E5%B0%8F%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE"><span class="toc-number">15.6.</span> <span class="toc-text">线程池中核心线程数量大小怎么设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-CompletableFuture%E7%B1%BB-star-star-star-star"><span class="toc-number">16.</span> <span class="toc-text">16.CompletableFuture类 :star::star::star::star:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">17. 线程安全需要保证几个基本特征？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">18.</span> <span class="toc-text">18. 线程之间的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-CSA"><span class="toc-number">19.</span> <span class="toc-text">19. CSA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%8E%9F%E7%90%86"><span class="toc-number">19.1.</span> <span class="toc-text">CAS原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSA%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">19.2.</span> <span class="toc-text">CSA的缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">20. 引用类型有哪些？有什么区别？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/java%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/" title="java面试-多线程篇">java面试-多线程篇</a><time datetime="2024-08-22T12:39:09.951Z" title="发表于 2024-08-22 20:39:09">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/java%E9%9D%A2%E8%AF%95-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87/" title="无题">无题</a><time datetime="2024-08-22T12:38:28.398Z" title="发表于 2024-08-22 20:38:28">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="java常见面试题总结">java常见面试题总结</a><time datetime="2024-08-22T12:33:17.271Z" title="发表于 2024-08-22 20:33:17">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/24/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/" title="简历相关问题">简历相关问题</a><time datetime="2024-07-24T13:12:01.186Z" title="发表于 2024-07-24 21:12:01">2024-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/24/SpringBoot/" title="SpringBoot面试集合">SpringBoot面试集合</a><time datetime="2024-07-24T12:43:40.318Z" title="发表于 2024-07-24 20:43:40">2024-07-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By hzf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>