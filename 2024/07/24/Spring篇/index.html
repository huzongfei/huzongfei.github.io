<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring常见面试题 | 草莓熊的秘密基地</title><meta name="author" content="hzf"><meta name="copyright" content="hzf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.什么是SpringSpring是一个轻量级的IoC和AOP容器框架，用于简化企业级Java应用程序的开发。Spring提供了一个全面的编程和配置模型，用于构建模块化、可测试和可重用的代码。Spring的核心理念是“Inversion of Control”（控制反转）和“Dependency Injection”（依赖注入），这些概念有助于减少代码的耦合度，提高代码的灵活性和可维护性。 主要组">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring常见面试题">
<meta property="og:url" content="https://huzongfei.github.io/2024/07/24/Spring%E7%AF%87/index.html">
<meta property="og:site_name" content="草莓熊的秘密基地">
<meta property="og:description" content="1.什么是SpringSpring是一个轻量级的IoC和AOP容器框架，用于简化企业级Java应用程序的开发。Spring提供了一个全面的编程和配置模型，用于构建模块化、可测试和可重用的代码。Spring的核心理念是“Inversion of Control”（控制反转）和“Dependency Injection”（依赖注入），这些概念有助于减少代码的耦合度，提高代码的灵活性和可维护性。 主要组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-07-24T10:51:35.465Z">
<meta property="article:modified_time" content="2024-07-24T11:01:11.061Z">
<meta property="article:author" content="hzf">
<meta property="article:tag" content="积少成多">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huzongfei.github.io/2024/07/24/Spring%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring常见面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-24 19:01:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="草莓熊的秘密基地"><span class="site-name">草莓熊的秘密基地</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring常见面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-24T10:51:35.465Z" title="发表于 2024-07-24 18:51:35">2024-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-24T11:01:11.061Z" title="更新于 2024-07-24 19:01:11">2024-07-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring常见面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-什么是Spring"><a href="#1-什么是Spring" class="headerlink" title="1.什么是Spring"></a>1.什么是Spring</h3><p>Spring是一个<strong>轻量级的IoC和AOP容器框架</strong>，用于简化企业级Java应用程序的开发。Spring提供了一个全面的编程和配置模型，用于构建模块化、可测试和可重用的代码。Spring的<strong>核心理念是“Inversion of Control”（控制反转）和“Dependency Injection”（依赖注入）</strong>，这些概念有助于减少代码的耦合度，提高代码的灵活性和可维护性。</p>
<p>主要组成：</p>
<p><strong>Spring Core</strong>：核心类库，提供IOC服务；</p>
<p><strong>Spring Context</strong>：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p>
<p><strong>Spring AOP</strong>：AOP服务；</p>
<p><strong>Spring DAO</strong>：对JDBC的抽象，简化了数据访问异常的处理；</p>
<p><strong>Spring ORM</strong>：对现有的ORM框架的支持；</p>
<p><strong>Spring Web</strong>：提供了基本的面向Web的综合特性，例如多方文件上传；</p>
<p><strong>Spring MVC</strong>：提供面向Web应用的Model-View-Controller实现。</p>
<h3 id="2-为什么使用Spring框架？"><a href="#2-为什么使用Spring框架？" class="headerlink" title="2. 为什么使用Spring框架？"></a>2. 为什么使用Spring框架？</h3><p><strong>轻量</strong>：Spring 是轻量的，基本的版本大约2MB。</p>
<p><strong>控制反转</strong>：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p>
<p><strong>面向切面编程</strong>：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p>
<p><strong>容器</strong>：Spring 包含并管理应用中对象的生命周期和配置。</p>
<p><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</p>
<p><strong>事务管理</strong>：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事物（JTA）。</p>
<p><strong>异常处理</strong>：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p>
<h3 id="3-Autowired和Resource关键字的区别？"><a href="#3-Autowired和Resource关键字的区别？" class="headerlink" title="3. Autowired和Resource关键字的区别？"></a>3. Autowired和Resource关键字的区别？</h3><ul>
<li><code>@Autowired</code> 是 <strong>Spring 提供的注解</strong>，<code>@Resource</code> 是 <strong>JDK 提供的注解</strong>。</li>
<li>**<code>Autowired</code> 默认的注入方式为<code>byType</code><strong>（根据类型进行匹配），</strong><code>@Resource</code>默认注入方式为 <code>byName</code>**（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。**<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称**。</li>
<li><strong><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用</strong>。**<code>@Resource</code> 主要用于字段和方法上的注入**，不支持在构造函数或参数上使用。</li>
</ul>
<p>在实际使用中，可以根据具体需求选择使用<code>Autowired</code>还是<code>Resource</code>注解。如果需要更多的灵活性，可以使用<code>Autowired</code>；如果只需要简单的依赖注入，可以使用<code>Resource</code>。</p>
<h3 id="4-依赖注入有哪几种方式？"><a href="#4-依赖注入有哪几种方式？" class="headerlink" title="4. 依赖注入有哪几种方式？"></a>4. 依赖注入有哪几种方式？</h3><p>依赖注入（Dependency Injection，简称DI）是一种设计模式，用于将依赖对象传递给组件，而不是让组件自己创建依赖对象。在Java中，依赖注入通常通过以下几种方式实现：</p>
<ol>
<li><strong>构造器注入（Constructor Injection）</strong>：<ul>
<li>通过组件的构造器来注入依赖。</li>
<li>每个依赖都是一个构造器的参数。</li>
<li>通常使用注解（如<code>@Autowired</code>）来指定依赖的注入。</li>
</ul>
</li>
<li><strong>设值注入（Setter Injection）</strong>：<ul>
<li>通过组件的设值方法来注入依赖。</li>
<li>每个依赖都是一个设值方法的参数。</li>
<li>通常使用注解（如<code>@Autowired</code>）来指定依赖的注入。</li>
</ul>
</li>
<li><strong>接口注入（Interface Injection）</strong>：<ul>
<li>通过实现一个或多个接口来注入依赖。</li>
<li>依赖对象通过实现接口的方式注入。</li>
<li>通常不使用注解，而是通过编程的方式来实现。</li>
</ul>
</li>
</ol>
<h3 id="5-Spring-MVC"><a href="#5-Spring-MVC" class="headerlink" title="5.Spring MVC"></a>5.Spring MVC</h3><p>M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）</p>
<p>V-View 视图（做界面的展示 jsp，html……）</p>
<p>C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面）</p>
<p><img src="/2024/07/24/Spring%E7%AF%87/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240501091209217.png" alt="image-20240501091209217"></p>
<p>1、 用户发送请求至前端控制器<strong>DispatcherServlet</strong>。</p>
<p>2、 DispatcherServlet收到请求调用<strong>HandlerMapping</strong>处理器映射器。</p>
<p>3、 <strong>处理器映射器找到具体的处理器</strong>(可以根据xml配置、注解进行查找)，<strong>生成处理器对象及处理器拦截器</strong>(如果有则生成)一并返回给DispatcherServlet。</p>
<p>4、 DispatcherServlet调用<strong>HandlerAdapter</strong>处理器适配器。</p>
<p>5、 <strong>HandlerAdapter</strong>经过适配<strong>调用具体的处理器</strong>(Controller，也叫后端控制器)。</p>
<p>6、 <strong>Controller执行完成返回ModelAndView</strong>。</p>
<p>7、 HandlerAdapter将controller<strong>执行结果ModelAndView返回给DispatcherServlet。</strong></p>
<p>8、 DispatcherServlet将<strong>ModelAndView传给ViewReslover视图解析器</strong>。</p>
<p>9、 ViewReslover解析后<strong>返回具体View</strong>。</p>
<p>10、DispatcherServlet<strong>根据View进行渲染视图</strong>（即将模型数据填充至视图中）。</p>
<p>11、 DispatcherServlet<strong>响应用户</strong>。</p>
<h3 id="6-Spring-MVC常用的注解有哪些？"><a href="#6-Spring-MVC常用的注解有哪些？" class="headerlink" title="6. Spring MVC常用的注解有哪些？"></a>6. Spring MVC常用的注解有哪些？</h3><p><code>@RequestMapping</code>:用于处理请求 url 映射的注解，<strong>可用于类或方法上</strong>。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p><code>@RequestBody</code>: 注解实现接收http请求的json数据，将<strong>json转换为java对象</strong>。</p>
<p><code>@ResponseBody</code>: 注解实现将conreoller方法<strong>返回对象转化为json对象</strong>响应给客户。</p>
<h3 id="7-谈谈你对Spring的AOP理解"><a href="#7-谈谈你对Spring的AOP理解" class="headerlink" title="7. 谈谈你对Spring的AOP理解"></a>7. 谈谈你对Spring的AOP理解</h3><p>AOP（Aspect-Oriented Programming，<strong>面向切面编程</strong>）能够<strong>将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p>
<p><strong>Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"></p>
<h3 id="8-Spring-AOP和AspectJ-AOP有什么区别？"><a href="#8-Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="8. Spring AOP和AspectJ AOP有什么区别？"></a>8. Spring AOP和AspectJ AOP有什么区别？</h3><p><strong>Spring AOP是属于运行时增强，而AspectJ是编译时增强。</strong></p>
<p><strong>Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）</strong>。</p>
<p>Spring AOP已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。</p>
<h3 id="AspectJ定义的通知类型有哪些？"><a href="#AspectJ定义的通知类型有哪些？" class="headerlink" title="AspectJ定义的通知类型有哪些？"></a>AspectJ定义的通知类型有哪些？</h3><p><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</p>
<p><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</p>
<p><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</p>
<p><strong>AfterThrowing</strong>（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p>
<p><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</p>
<h3 id="9-谈谈你对Spring的IOC的理解。"><a href="#9-谈谈你对Spring的IOC的理解。" class="headerlink" title="9. 谈谈你对Spring的IOC的理解。"></a>9. 谈谈你对Spring的IOC的理解。</h3><p><strong>Spring的IoC是一种设计原则，用于减少代码之间的耦合。</strong>通过控制反转，应用程序和组件之间的耦合度降低，使得应用程序更加模块化和可维护。<strong>Spring的IoC容器是实现控制反转的核心，它负责创建和管理对象的生命周期，包括对象的创建、依赖关系的注入和对象的销毁</strong>。<strong>依赖注入是实现控制反转的一种方式，它允许将依赖关系注入到组件中。</strong></p>
<p><strong>控制反转的理解</strong></p>
<ol>
<li><strong>创建和销毁对象</strong>：在传统的编程模式中，应用程序负责创建和管理对象。在Spring的IoC容器中，容器负责创建和管理对象，应用程序只需要通过容器来获取对象。</li>
<li><strong>依赖注入</strong>：在传统的编程模式中，应用程序需要手动创建和管理对象之间的依赖关系。在Spring的IoC容器中，容器负责创建和管理对象之间的依赖关系，应用程序只需要通过容器来获取依赖对象。</li>
<li><strong>解耦合</strong>：通过控制反转，应用程序和组件之间的耦合度降低，使得应用程序更加模块化和可维护。</li>
</ol>
<p><strong>Spring的IoC容器</strong></p>
<p>Spring的IoC容器是实现控制反转的核心。它负责创建和管理对象的生命周期，包括对象的创建、依赖关系的注入和对象的销毁。Spring提供了多种IoC容器的实现，如基于XML的配置、基于注解的配置和基于Java的配置等。</p>
<p><strong>依赖注入（DI）</strong></p>
<p>依赖注入是实现控制反转的一种方式，它允许将依赖关系注入到组件中。Spring提供了多种依赖注入的方式，如构造器注入、设值注入、接口注入和字段注入等。</p>
<h3 id="10-Spring-Bean的生命周期"><a href="#10-Spring-Bean的生命周期" class="headerlink" title="10. Spring Bean的生命周期"></a>10. Spring Bean的生命周期</h3><p>Spring Bean的生命周期指的是从Bean被创建到被销毁的过程。Spring容器管理Bean的生命周期，确保它们在需要时被创建、初始化、使用和最终销毁。以下是Spring Bean生命周期的基本步骤： 实例化 —&gt; 属性赋值 —&gt; 初始化 —&gt; 销毁。</p>
<ol>
<li><p><strong>创建 Bean 的实例</strong>：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</p>
</li>
<li><p><strong>Bean 属性赋值/填充</strong>：为 Bean 设置相关属性和依赖，例如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</p>
</li>
<li><p><strong>Bean 初始化</strong>：</p>
<ul>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行**<code>postProcessBeforeInitialization()</code> 方法**</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，<strong>执行<code>afterPropertiesSet()</code>方法。</strong></li>
<li>如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li>
</ul>
</li>
<li><p><strong>销毁 Bean</strong>：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。 </p>
<ul>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/spring-bean-lifestyle.png" alt="img"></p>
</li>
</ol>
<h3 id="11-获取bean对象"><a href="#11-获取bean对象" class="headerlink" title="11. 获取bean对象"></a>11. 获取bean对象</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一 通过ClassPathXmlApplicationContext获取bean对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">"bookDao"</span>);</span><br><span class="line"><span class="comment">// BookDao bookDao = ctx.getBean("bookDao",BookDao.class);</span></span><br><span class="line"><span class="comment">// BookDao bookDao = ctx.getBean(BookDao.class);</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式二 通过beanFactory获取bean对象</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2024/07/24/Spring%E7%AF%87/Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240506092732154.png" alt="image-20240506092732154"></p>
<p>使用@Qualifier实现按照名称注入</p>
<h3 id="12-Bean的作用域有哪些"><a href="#12-Bean的作用域有哪些" class="headerlink" title="12. Bean的作用域有哪些"></a>12. Bean的作用域有哪些</h3><p>singletion： IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</p>
<p>prototype：每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</p>
<p>request：为每一次HTTP请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p>
<p>session：每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</p>
<p>global-session：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</p>
<p>websocket(仅 Web 应用可用): 每一次 WebSocket 会话产生一个新的 bean</p>
<p><strong>配置bean作用域方法</strong></p>
<p>xml方式</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注解方式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Bean是线程安全的嘛"><a href="#Bean是线程安全的嘛" class="headerlink" title="Bean是线程安全的嘛"></a>Bean是线程安全的嘛</h3><p>Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。</p>
<p>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。</p>
<p>singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存</p>
<p>在线程安全问题（**有状态 Bean 是指包含<font color="red">可变的成员变量对象</font>**）。</p>
<p>对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：</p>
<ol>
<li>在 Bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）</li>
</ol>
<h3 id="13-Spring-基于xml注入bean的几种方式"><a href="#13-Spring-基于xml注入bean的几种方式" class="headerlink" title="13. Spring 基于xml注入bean的几种方式"></a>13. Spring 基于xml注入bean的几种方式</h3><ol>
<li>Set方法注入</li>
<li>构造器注入</li>
<li>静态方法注入</li>
<li>实例工厂</li>
</ol>
<h3 id="14-Spring-框架中都用到了哪些设计模式"><a href="#14-Spring-框架中都用到了哪些设计模式" class="headerlink" title="14. Spring 框架中都用到了哪些设计模式"></a>14. Spring 框架中都用到了哪些设计模式</h3><p><strong>简单工厂模式</strong>：Spring 中的 BeanFactory 就是简单工厂模式的体现。根据传入一个唯一的标识来获得 Bean 对象，但是在传入参数后创建还是传入参数前创建，要根据具体情况来定。</p>
<p><strong>工厂模式</strong>：</p>
<ul>
<li><code>BeanFactory</code>是Spring框架中最基础的工厂模式实现，它提供了Bean的创建和管理功能。</li>
<li><code>BeanFactory</code>提供了getBean方法来获取Bean实例，这个方法可以接受Bean的ID或名称作为参数。</li>
<li><code>BeanFactory</code>管理Bean的生命周期，包括创建、初始化、使用和销毁。</li>
</ul>
<p><strong>单例模式</strong>：在Spring框架中，<strong>单例模式（Singleton Pattern）用于确保一个Bean在应用的整个生命周期中只有一个实例</strong>。这意味着在整个应用中，对于某个Bean的请求都会得到同一个实例。这种模式在Spring中非常普遍，因为大多数Bean都是作为单例实例在Spring容器中管理的。</p>
<ol>
<li><strong>默认行为</strong>：<ul>
<li>当Spring容器启动时，它会创建所有单例Bean的实例。</li>
<li>之后，对于任何给定的Bean ID，Spring容器都会返回同一个实例。</li>
</ul>
</li>
<li><strong>作用域（Scope）</strong>：<ul>
<li>虽然单例是Spring Bean的默认作用域，但你也可以通过设置<code>scope</code>属性来定义其他作用域，如原型（Prototype）、会话（Session）或请求（Request）。</li>
</ul>
</li>
</ol>
<p><strong>原型模式</strong>：<strong>在 spring 中用到的原型模式有： scope=”prototype” ，每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</strong></p>
<p><strong>迭代器模式</strong>：在 Spring 中有个 CompositeIterator 实现了 Iterator，Iterable 接口和 Iterator 接口，这两个都是迭代相关的接口。可以这么认为，实现了 Iterable 接口，则表示某个对象是可被迭代的。Iterator 接口相当于是一个迭代器，实现了 Iterator 接口，等于具体定义了这个可被迭代的对象时如何进行迭代的。</p>
<p><strong>代理模式</strong>：<strong>Spring 中经典的 AOP，就是使用动态代理实现的，分 JDK 和 CGlib 动态代理。</strong></p>
<p><strong>适配器模式</strong>：Spring 中的 AOP 中 AdvisorAdapter 类，它有三个实现：MethodBeforAdviceAdapter、AfterReturnningAdviceAdapter、ThrowsAdviceAdapter。Spring会根据不同的 AOP 配置来使用对应的 Advice，与策略模式不同的是，一个方法可以同时拥有多个Advice。Spring 存在很多以 Adapter 结尾的，大多数都是适配器模式。</p>
<p><strong>观察者模式</strong>：Spring 中的 Event 和 Listener。spring 事件：ApplicationEvent，该抽象类继承了EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。spring 事件监听器：ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承EventListener。</p>
<p><strong>模板模式</strong>：Spring 中的 org.springframework.jdbc.core.JdbcTemplate 就是非常经典的模板模式的应用，里面的 execute 方法，把整个算法步骤都定义好了。</p>
<p><strong>责任链模式</strong>：DispatcherServlet 中的 doDispatch() 方法中获取与请求匹配的处理器HandlerExecutionChain，this.getHandler() 方法的处理使用到了责任链模式。</p>
<h3 id="16-Spring是如何解决循环依赖的"><a href="#16-Spring是如何解决循环依赖的" class="headerlink" title="16. Spring是如何解决循环依赖的"></a>16. Spring是如何解决循环依赖的</h3><p><strong>循环依赖是指 Bean 对象循环引用，是两个或多个 Bean 之间相互持有对方的引用</strong>，例如 CircularDependencyA → CircularDependencyB → CircularDependencyA。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyA</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyB</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Spring 框架通过使用三级缓存来解决这个问题，确保即使在循环依赖的情况下也能正确创建 Bean。</strong></p>
<p>Spring 的三级缓存包括：</p>
<ol>
<li><strong>一级缓存（singletonObjects）</strong>：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</li>
<li><strong>二级缓存（earlySingletonObjects）</strong>：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</li>
<li><strong>三级缓存（singletonFactories）</strong>：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法（最终调用的是<code>getEarlyBeanReference()</code>方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。</li>
</ol>
<p>Spring创建Bean的流程：</p>
<ol>
<li><strong>先去一级缓存<code>SignletonObjects</code>中获取</strong>，存在就返回</li>
<li>如果不存在或者对象正在创建中，于是去 <strong>二级缓存 <code>earlySingletonObjects</code></strong> 中获取；</li>
<li>如果还没有获取到，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中获取，通过执行 <code>ObjectFacotry</code> 的 <code>getObject()</code> 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。</li>
</ol>
<p>在三级缓存中存储的是 <code>ObjectFacoty</code> ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; {</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Spring 在创建 Bean 的时候，如果允许循环依赖的话，Spring 就会将刚刚实例化完成，但是属性还没有初始化完的 Bean 对象给提前暴露出去，</strong>这里通过 <strong><code>addSingletonFactory</code> 方法，向三级缓存中添加一个 <code>ObjectFactory</code> 对象</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory # doCreateBean #</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> ... {</span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(...)</span> {</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 支撑循环依赖：将 ()-&gt;getEarlyBeanReference 作为一个 ObjectFactory 对象的 getObject() 方法加入到三级缓存中</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>三级缓存、提前曝光</strong></p>
<h3 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h3><h4 id="Spring管理事务的方式有哪几种？"><a href="#Spring管理事务的方式有哪几种？" class="headerlink" title="Spring管理事务的方式有哪几种？"></a>Spring管理事务的方式有哪几种？</h4><ul>
<li><strong>编程式事务</strong>：在代码中硬编码(在分布式系统中推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li>
<li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>
</ul>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>事务的隔离级别定义了事务与其他并发事务的隔离程度，以及它们如何处理数据一致性问题。不同的隔离级别会影响数据库在执行事务时如何处理读取和写入操作，从而影响数据的一致性和性能。</p>
<p>以下是几种常见的事务隔离级别：</p>
<ol>
<li><strong>未提交读（Read Uncommitted）</strong>：<ul>
<li>允许读取未提交的数据变更，可能会导致脏读（Dirty Read）。</li>
<li>脏读：一个事务读取了另一个事务尚未提交的数据变更，如果另一个事务回滚，那么读取的数据将是不一致的。</li>
</ul>
</li>
<li><strong>提交读（Read Committed）</strong>：Oracle默认<ul>
<li>确保一个事务只读取另一个事务已经提交的数据。</li>
<li>防止脏读，但可能会导致不可重复读（Nonrepeatable Read）和幻读（Phantom Read）。</li>
<li>不可重复读：在一个事务内，由于另一个事务的更新，导致同一查询的结果集在不同时间点不一致。</li>
<li>幻读：在一个事务内，由于另一个事务的插入，导致同一查询的结果集在不同时间点不一致。</li>
</ul>
</li>
<li><strong>可重复读（Repeatable Read）</strong>： Mysql默认<ul>
<li>确保一个事务内对数据的多次读取结果是一致的，即使在事务执行期间有其他事务对数据进行了修改。</li>
<li>防止脏读和不可重复读，但可能会导致幻读。</li>
</ul>
</li>
<li><strong>可序列化（Serializable）</strong>：<ul>
<li>完全服从ACID的隔离级别，确保事务串行执行，避免了脏读、不可重复读和幻读。</li>
<li>通常是通过强制事务串行执行来实现的，这可能会导致性能问题，因为数据库需要对事务进行排序并等待其他事务完成。</li>
</ul>
</li>
</ol>
<p>选择合适的隔离级别取决于具体的需求和场景。例如，如果数据一致性非常重要，可能需要选择<code>Serializable</code>隔离级别。如果性能是关键，可能需要选择较低的隔离级别，尽管这可能会增加数据不一致的风险。</p>
<h4 id="事务的传播级别"><a href="#事务的传播级别" class="headerlink" title="事务的传播级别"></a>事务的传播级别</h4><p>事务的传播级别（Transaction Propagation）定义了当一个方法被另一个事务方法调用时，这个方法应该如何处理事务。Spring框架支持多种事务传播级别，允许你在不同的事务边界内控制事务行为。以下是几种常见的事务传播级别：</p>
<ol>
<li><strong>REQUIRED</strong>：<strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</strong>这是最常见的传播级别，通常用于大多数业务操作。</li>
<li><strong>SUPPORTS</strong>：<ul>
<li>如果当前有事务，则加入该事务。</li>
<li>如果当前没有事务，则以非事务方式执行。</li>
<li>通常用于只读操作或操作不会影响数据一致性的情况。</li>
</ul>
</li>
<li><strong>MANDATORY</strong>：<ul>
<li>如果当前有事务，则加入该事务。</li>
<li>如果当前没有事务，则抛出异常。</li>
<li>通常用于需要参与现有事务的操作。</li>
</ul>
</li>
<li><strong>REQUIRES_NEW</strong>：<ul>
<li>创建一个新事务，如果当前有事务，则挂起当前事务。</li>
<li>当前事务暂停后，新事务开始执行。</li>
<li>新事务完成后，如果当前事务未完成，则恢复当前事务的执行。</li>
<li>通常用于需要独立事务的场景，例如一个操作需要回滚，但不会影响其他操作。</li>
</ul>
</li>
<li><strong>NOT_SUPPORTED</strong>：<ul>
<li>如果当前有事务，则暂停当前事务。</li>
<li>以非事务方式执行。</li>
<li>如果当前没有事务，则创建一个新事务。</li>
<li>通常用于需要在无事务环境中执行操作的情况。</li>
</ul>
</li>
<li><strong>NEVER</strong>：<ul>
<li>如果当前有事务，则抛出异常。</li>
<li>如果当前没有事务，则以非事务方式执行。</li>
<li>通常用于不希望事务参与的操作。</li>
</ul>
</li>
<li><strong>NESTED</strong>：<ul>
<li>如果当前有事务，则在嵌套事务中执行。</li>
<li>如果当前没有事务，则创建一个新事务。</li>
<li>嵌套事务会在外部事务完成后自动提交，即使外部事务回滚，嵌套事务也会回滚。</li>
<li>通常用于需要嵌套事务的场景，例如一个操作需要回滚，但不会影响其他操作。</li>
</ul>
</li>
</ol>
<p>选择合适的事务传播级别取决于具体的需求和场景。例如，如果一个操作需要独立于外部事务执行，可能需要选择<code>REQUIRES_NEW</code>传播级别。如果一个操作需要参与外部事务，可能需要选择<code>REQUIRED</code>或<code>NESTED</code>传播级别。</p>
<h4 id="事务失效的几种情况"><a href="#事务失效的几种情况" class="headerlink" title="事务失效的几种情况"></a>事务失效的几种情况</h4><ol>
<li>方法内的自调用</li>
<li>方法是private</li>
<li>方法是final</li>
<li>单独的线程调用方法</li>
<li>没加@Configuration注解</li>
<li>异常被吃掉</li>
<li>类没有被Spring管理</li>
<li>数据库不支持事务</li>
</ol>
<h3 id="19-Spring-AOP-通知和执行顺序"><a href="#19-Spring-AOP-通知和执行顺序" class="headerlink" title="19. Spring AOP 通知和执行顺序"></a>19. Spring AOP 通知和执行顺序</h3><p>前置通知：在目标方法被调用之前调用通知功能；</p>
<p>后置通知：目标对象的方法调用之后触发</p>
<p>返回通知：目标对象的方法调用完成，在返回结果值之后触发</p>
<p>异常通知：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p>
<p>环绕通知：编程式控制目标对象的方法调用。<strong>环绕通知是所有通知类型中可操作范围最大的一种</strong>，因为它<strong>可以直接拿到目标对象，以及要执行的方法</strong>，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法。</p>
<p>执行顺序—正常：前置–&gt;环绕–&gt;后置–&gt;返回    异常：前置–&gt;环绕–&gt;后置–&gt;异常</p>
<h3 id="SpringMVC的核心组件有哪些"><a href="#SpringMVC的核心组件有哪些" class="headerlink" title="SpringMVC的核心组件有哪些"></a>SpringMVC的核心组件有哪些</h3><p><strong>DispatcherServlet</strong>: <strong>核心的中央处理器，负责接受请求，分片，并给与客户端响应</strong></p>
<p><strong>HandlerMapper：处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p>
<p><strong>HandlerAdapter:处理器适配器</strong>，根据HandlerMapper找到的Handler,适配执行对应的Handler</p>
<p><strong>Handler: 请求处理器，处理实际请求的处理器</strong></p>
<p><strong>ViewResolver: 视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</p>
<h3 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h3><ol>
<li>客户端（浏览器）发送请求，<code>DispatcherServlet</code>拦截请求</li>
<li><strong><code>DispatcherServlet</code>根据请求信息调用<code>HandlerMapper</code><strong>。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，</strong>并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</strong></li>
<li><strong><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code></strong> 。</li>
<li><strong><code>Handler</code>完成对用户请求的处理后，会返回一个<code>ModelAndView</code>对象给<code>DispatchServlet</code></strong>, <code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li>**<code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>**。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h3 id="SpringMVC中的重定向和转发分别是如何实现的"><a href="#SpringMVC中的重定向和转发分别是如何实现的" class="headerlink" title="SpringMVC中的重定向和转发分别是如何实现的"></a>SpringMVC中的重定向和转发分别是如何实现的</h3><p>使用**forward:**对当前请求进行转发</p>
<p>使用**redirect:**对当前请求进行重定向</p>
<p>当SpringMVC接收到一个请求后，会先处理请求，如果后续方法要进行转发，就会利用RequestDispatcher将当前请求转发到指定地址，这种情况下，一直是同一个请求，只不过两次请求的路径不一样，并且转发对于浏览器而言是透明的</p>
<p>而如果SpringMVC接收到一个请求，并进行处理后，发现要进行重定向，此时SpringMVC会向浏览器响应303，同时会告诉浏览器要重定向的路径，表示告诉浏览器要访问另外一个路径，由浏览器自己来访问，所以重定向是需要浏览器参与的，是不同的两个请求</p>
<h3 id="统一异常处理怎么做"><a href="#统一异常处理怎么做" class="headerlink" title="统一异常处理怎么做"></a>统一异常处理怎么做</h3><p>推荐使用注解的方式统一异常处理，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) {</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> {</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code> 织入异常处理的逻辑（AOP），当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huzongfei.github.io">hzf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huzongfei.github.io/2024/07/24/Spring%E7%AF%87/">https://huzongfei.github.io/2024/07/24/Spring%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huzongfei.github.io" target="_blank">草莓熊的秘密基地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/24/Redis/" title="Redis 常见面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis 常见面试题</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/24/SpringBoot/" title="SpringBoot面试集合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot面试集合</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">hzf</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFSpring"><span class="toc-number">1.</span> <span class="toc-text">1.什么是Spring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Spring%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 为什么使用Spring框架？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Autowired%E5%92%8CResource%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. Autowired和Resource关键字的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4. 依赖注入有哪几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring-MVC"><span class="toc-number">5.</span> <span class="toc-text">5.Spring MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Spring-MVC%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6. Spring MVC常用的注解有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Spring%E7%9A%84AOP%E7%90%86%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">7. 谈谈你对Spring的AOP理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Spring-AOP%E5%92%8CAspectJ-AOP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">8. Spring AOP和AspectJ AOP有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AspectJ%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">AspectJ定义的通知类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Spring%E7%9A%84IOC%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82"><span class="toc-number">10.</span> <span class="toc-text">9. 谈谈你对Spring的IOC的理解。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.</span> <span class="toc-text">10. Spring Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%8E%B7%E5%8F%96bean%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.</span> <span class="toc-text">11. 获取bean对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">13.</span> <span class="toc-text">12. Bean的作用域有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%98%9B"><span class="toc-number">14.</span> <span class="toc-text">Bean是线程安全的嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Spring-%E5%9F%BA%E4%BA%8Exml%E6%B3%A8%E5%85%A5bean%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">13. Spring 基于xml注入bean的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">14. Spring 框架中都用到了哪些设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84"><span class="toc-number">17.</span> <span class="toc-text">16. Spring是如何解决循环依赖的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1"><span class="toc-number">18.</span> <span class="toc-text">Spring 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">18.1.</span> <span class="toc-text">Spring管理事务的方式有哪几种？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">18.2.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB"><span class="toc-number">18.3.</span> <span class="toc-text">事务的传播级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">18.4.</span> <span class="toc-text">事务失效的几种情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Spring-AOP-%E9%80%9A%E7%9F%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">19.</span> <span class="toc-text">19. Spring AOP 通知和执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">20.</span> <span class="toc-text">SpringMVC的核心组件有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">21.</span> <span class="toc-text">SpringMVC工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E4%B8%AD%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E5%88%86%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">22.</span> <span class="toc-text">SpringMVC中的重定向和转发分别是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">23.</span> <span class="toc-text">统一异常处理怎么做</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="java常见面试题总结">java常见面试题总结</a><time datetime="2024-08-22T12:33:17.271Z" title="发表于 2024-08-22 20:33:17">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/test/" title="无题">无题</a><time datetime="2024-08-22T12:09:14.408Z" title="发表于 2024-08-22 20:09:14">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/24/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/" title="简历相关问题">简历相关问题</a><time datetime="2024-07-24T13:12:01.186Z" title="发表于 2024-07-24 21:12:01">2024-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/24/SpringBoot/" title="SpringBoot面试集合">SpringBoot面试集合</a><time datetime="2024-07-24T12:43:40.318Z" title="发表于 2024-07-24 20:43:40">2024-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/24/Spring%E7%AF%87/" title="Spring常见面试题">Spring常见面试题</a><time datetime="2024-07-24T10:51:35.465Z" title="发表于 2024-07-24 18:51:35">2024-07-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By hzf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>