<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="集合概述1. Java 集合概览Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 、 Queue、Map。 Java 集合框架如下图所示： 注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了Abstrac">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="集合概述1. Java 集合概览Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 、 Queue、Map。 Java 集合框架如下图所示： 注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了Abstrac">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240425195847907.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240425195918896.png">
<meta property="article:published_time" content="2024-04-26T00:19:30.193Z">
<meta property="article:modified_time" content="2024-04-25T12:27:26.890Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java集合常见面试题总结（上）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:19:30.193Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0">集合概述</a></h1><h3 id="1-Java-集合概览"><a href="#1-Java-集合概览" class="headerlink" title="1. Java 集合概览"></a>1. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#java-%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88">Java 集合概览</a></h3><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>、<code>Map</code>。</p>
<p>Java 集合框架如下图所示：<img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt="Java 集合框架概览"></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
<h3 id="2-说说-List-Set-Queue-Map-四者的区别？"><a href="#2-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="2. 说说 List, Set, Queue, Map 四者的区别？"></a>2. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E8%AF%B4%E8%AF%B4-list-set-queue-map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB">说说 List, Set, Queue, Map 四者的区别？</a></h3><p><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</p>
<p><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。</p>
<p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p>
<p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值</p>
<h3 id="3-集合框架底层数据结构总结"><a href="#3-集合框架底层数据结构总结" class="headerlink" title="3.集合框架底层数据结构总结"></a>3.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">集合框架底层数据结构总结</a></h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a><a href="#list">List</a></h4><ul>
<li><code>ArrayList</code>：<code>Object[]</code> 数组。详细可以查看：<a href="">ArrayList 源码分析</a>。</li>
<li><code>Vector</code>：<code>Object[]</code> 数组。</li>
<li><code>LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：<a href="">LinkedList 源码分析</a>。</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a><a href="#set">Set</a></h4><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)。</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><a href="#queue">Queue</a></h4><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆。详细可以查看：<a href="">PriorityQueue 源码分析</a>。</li>
<li><code>DelayQueue</code>:<code>PriorityQueue</code>。详细可以查看：<a href="">DelayQueue 源码分析</a>。</li>
<li><code>ArrayDeque</code>: 可扩容动态双向数组。</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="#map">Map</a></h4><ul>
<li><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。详细可以查看：<a href="">HashMap 源码分析</a>。</li>
<li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="">LinkedHashMap 源码分析</a></li>
<li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li>
</ul>
<h3 id="4-如何选用集合"><a href="#4-如何选用集合" class="headerlink" title="4. 如何选用集合?"></a>4. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88">如何选用集合?</a></h3><p>当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多</p>
<p>个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。</p>
<p>相较于数组，Java 集合的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>
<h1 id="List-1"><a href="#List-1" class="headerlink" title="List"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#list-1">List</a></h1><h3 id="5-ArrayList-和-Array（数组）的区别？"><a href="#5-ArrayList-和-Array（数组）的区别？" class="headerlink" title="5. ArrayList 和 Array（数组）的区别？"></a>5. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E5%92%8C-array-%E6%95%B0%E7%BB%84-%E7%9A%84%E5%8C%BA%E5%88%AB">ArrayList 和 Array（数组）的区别？</a></h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p>
<ul>
<li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li>
<li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li>
<li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li>
<li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li>
<li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li>
</ul>
<h3 id="6-ArrayList-和-Vector-的区别-（了解即可）"><a href="#6-ArrayList-和-Vector-的区别-（了解即可）" class="headerlink" title="6.ArrayList 和 Vector 的区别?（了解即可）"></a>6.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E5%92%8C-vector-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF">ArrayList 和 Vector 的区别?（了解即可）</a></h3><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</p>
<h3 id="7-Vector-和-Stack-的区别-（了解即可）"><a href="#7-Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="7.Vector 和 Stack 的区别?（了解即可）"></a>7.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#vector-%E5%92%8C-stack-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF">Vector 和 Stack 的区别?（了解即可）</a></h3><ul>
<li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li>
<li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li>
</ul>
<p>随着 Java 并发编程的发展，<code>Vector</code> 和 <code>Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>
<h3 id="8-ArrayList-可以添加-null-值吗？"><a href="#8-ArrayList-可以添加-null-值吗？" class="headerlink" title="8. ArrayList 可以添加 null 值吗？"></a>8. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0-null-%E5%80%BC%E5%90%97">ArrayList 可以添加 null 值吗？</a></h3><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过，不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p>
<h3 id="9-ArrayList-插入和删除元素的时间复杂度？"><a href="#9-ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="9. ArrayList 插入和删除元素的时间复杂度？"></a>9. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">ArrayList 插入和删除元素的时间复杂度？</a></h3><p>对于插入：</p>
<ul>
<li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li>
<li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li>
</ul>
<p>对于删除：</p>
<ul>
<li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li>
<li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
<h3 id="10-LinkedList-插入和删除元素的时间复杂度？"><a href="#10-LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="10. LinkedList 插入和删除元素的时间复杂度？"></a>10. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#linkedlist-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">LinkedList 插入和删除元素的时间复杂度？</a></h3><p>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p>
<p>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p>
<p>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</p>
<h3 id="11-LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#11-LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="11.LinkedList 为什么不能实现 RandomAccess 接口？"></a>11.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#linkedlist-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0-randomaccess-%E6%8E%A5%E5%8F%A3">LinkedList 为什么不能实现 RandomAccess 接口？</a></h3><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p>
<h3 id="12-ArrayList-与-LinkedList-区别"><a href="#12-ArrayList-与-LinkedList-区别" class="headerlink" title="12.ArrayList 与 LinkedList 区别?"></a>12.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E4%B8%8E-linkedlist-%E5%8C%BA%E5%88%AB">ArrayList 与 LinkedList 区别?</a></h3><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
<p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li>
</ul>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h3 id="13-ArrayList的扩容机制"><a href="#13-ArrayList的扩容机制" class="headerlink" title="13. ArrayList的扩容机制"></a>13. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/arraylist-source-code.html#arraylist-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">ArrayList的扩容机制</a></h3><h1 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h1><h3 id="14-Comparable-和-Comparator-的区别"><a href="#14-Comparable-和-Comparator-的区别" class="headerlink" title="14. Comparable 和 Comparator 的区别"></a>14. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#comparable-%E5%92%8C-comparator-%E7%9A%84%E5%8C%BA%E5%88%AB">Comparable 和 Comparator 的区别</a></h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul>
<li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 <code>song</code> 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 <code>Comparator</code> 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<h3 id="15-无序性和不可重复性的含义是什么"><a href="#15-无序性和不可重复性的含义是什么" class="headerlink" title="15.无序性和不可重复性的含义是什么"></a>15.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88">无序性和不可重复性的含义是什么</a></h3><p>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</p>
<h3 id="16-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#16-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="16.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>16.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E6%AF%94%E8%BE%83-hashset%E3%80%81linkedhashset-%E5%92%8C-treeset-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</a></h3><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p>
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
<p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
<h1 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h1><h3 id="17-Queue-与-Deque-的区别"><a href="#17-Queue-与-Deque-的区别" class="headerlink" title="17. Queue 与 Deque 的区别"></a>17. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#queue-%E4%B8%8E-deque-%E7%9A%84%E5%8C%BA%E5%88%AB">Queue 与 Deque 的区别</a></h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240425195847907.png" alt="image-20240425195847907"></p>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240425195918896.png" alt="image-20240425195918896"></p>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h3 id="18-ArrayDeque-与-LinkedList-的区别"><a href="#18-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="18.ArrayDeque 与 LinkedList 的区别"></a>18.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraydeque-%E4%B8%8E-linkedlist-%E7%9A%84%E5%8C%BA%E5%88%AB">ArrayDeque 与 LinkedList 的区别</a></h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="length属性，length-方法，size-方法"><a href="#length属性，length-方法，size-方法" class="headerlink" title="length属性，length()方法，size()方法"></a>length属性，length()方法，size()方法</h3><ul>
<li>Java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>Java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>Java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" data-id="clvfxgucd000474tu7ryp8a7e" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>