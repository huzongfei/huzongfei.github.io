<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1. Java SE vs Java EE Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。 Java EE（Java Platform, Enterprise Edition ）">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. Java SE vs Java EE Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。 Java EE（Java Platform, Enterprise Edition ）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-include-jre.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160348016.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160648790.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160325214.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423170037053.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171140098.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/up-1ae0425ce8646adfb768b5374951eeb820d.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171825236.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171924882.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/member-var-vs-local-var.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423173544912.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423173552505.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201407572.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201852094.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201911042.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201942808.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201958820.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423202027492.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423151525232.png">
<meta property="article:published_time" content="2024-04-26T00:27:08.199Z">
<meta property="article:modified_time" content="2024-04-24T08:04:19.941Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java基础常见面试题总结（上）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.199Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-Java-SE-vs-Java-EE"><a href="#1-Java-SE-vs-Java-EE" class="headerlink" title="1. Java SE vs Java EE"></a>1. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#java-se-vs-java-ee">Java SE vs Java EE</a></h3><ul>
<li>Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。</li>
<li>Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。</li>
</ul>
<h3 id="2-JVM-vs-JDK-vs-JRE"><a href="#2-JVM-vs-JDK-vs-JRE" class="headerlink" title="2.JVM vs JDK vs JRE"></a>2.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm-vs-jdk-vs-jre">JVM vs JDK vs JRE</a></h3><h5 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm">JVM</a></h5><p>Java 虚拟机（Java Virtual Machine）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png" alt="运行在 Java 虚拟机之上的编程语言"><br>JVM不是只有一种</p>
<h5 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jdk-%E5%92%8C-jre">JDK 和 JRE</a></h5><p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p>
<p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-include-jre.png" alt="JDK 包含 JRE"></p>
<h3 id="3-什么是字节码-采用字节码的好处是什么"><a href="#3-什么是字节码-采用字节码的好处是什么" class="headerlink" title="3. 什么是字节码?采用字节码的好处是什么?"></a>3. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">什么是字节码?采用字节码的好处是什么?</a></h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><strong>Java程序从源代码到运行的过程如下图所示</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160348016.png" alt="image-20240423160348016"></p>
<p><strong>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png" alt="JDK、JRE、JVM、JIT 这四者的关系"></p>
<h3 id="4-为什么说-Java-语言“编译与解释并存”？"><a href="#4-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="4.为什么说 Java 语言“编译与解释并存”？"></a>4.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-java-%E8%AF%AD%E8%A8%80-%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98">为什么说 Java 语言“编译与解释并存”？</a></h3><p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><strong>编译型</strong>：编译型语言会通过[编译器]将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型</strong>：[解释型语言]会通过[解释器]一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160648790.png" alt="image-20240423160648790"></p>
<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>
<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="5-AOT-有什么优点？为什么不全部使用-AOT-呢？"><a href="#5-AOT-有什么优点？为什么不全部使用-AOT-呢？" class="headerlink" title="5. AOT 有什么优点？为什么不全部使用 AOT 呢？"></a>5. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#aot-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8-aot-%E5%91%A2">AOT 有什么优点？为什么不全部使用 AOT 呢？</a></h3><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160325214.png" alt="image-20240423160325214"><br>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>
<p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p>
<p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>
<h3 id="6-Java-和-C-的区别"><a href="#6-Java-和-C-的区别" class="headerlink" title="6.  Java 和 C++ 的区别?"></a>6.  <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#java-%E5%92%8C-c-%E7%9A%84%E5%8C%BA%E5%88%AB">Java 和 C++ 的区别?</a></h3><p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p>
<ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
</ul>
<h3 id="7-continue、break-和-return-的区别是什么？"><a href="#7-continue、break-和-return-的区别是什么？" class="headerlink" title="7.continue、break 和 return 的区别是什么？"></a>7.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#continue%E3%80%81break-%E5%92%8C-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">continue、break 和 return 的区别是什么？</a></h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li>
</ol>
<p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<h3 id="8-Java-中的几种基本数据类型了解么？"><a href="#8-Java-中的几种基本数据类型了解么？" class="headerlink" title="8.Java 中的几种基本数据类型了解么？"></a>8.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88">Java 中的几种基本数据类型了解么？</a></h3><p>8中基本类型：byte,short,int,long,char,float,double,boolean</p>
<p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型： <ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ul>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423170037053.png" alt="image-20240423170037053"></p>
<h3 id="9-基本类型和包装类型的区别？"><a href="#9-基本类型和包装类型的区别？" class="headerlink" title="9. 基本类型和包装类型的区别？"></a>9. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB">基本类型和包装类型的区别？</a></h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p>
<p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</p>
<p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p>
<p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p>
<p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p>
<p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p>
<p><strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p>
<h3 id="10-包装类型的缓存机制了解么？"><a href="#10-包装类型的缓存机制了解么？" class="headerlink" title="10. 包装类型的缓存机制了解么？"></a>10. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88">包装类型的缓存机制了解么？</a></h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171140098.png" alt="image-20240423171140098"></p>
<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/up-1ae0425ce8646adfb768b5374951eeb820d.png" alt="img"></p>
<h3 id="11-自动装箱与拆箱了解吗？原理是什么？"><a href="#11-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="11. 自动装箱与拆箱了解吗？原理是什么？"></a>11. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%BA%86%E8%A7%A3%E5%90%97-%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">自动装箱与拆箱了解吗？原理是什么？</a></h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>原理：我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h3 id="12-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#12-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="12. 为什么浮点数运算的时候会有精度丢失的风险？"></a>12. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A3%8E%E9%99%A9">为什么浮点数运算的时候会有精度丢失的风险？</a></h3><p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171825236.png" alt="image-20240423171825236"></p>
<p>为什么会出现这个问题呢？</p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<h3 id="13-如何解决浮点数运算的精度丢失问题？"><a href="#13-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="13.如何解决浮点数运算的精度丢失问题？"></a>13.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98">如何解决浮点数运算的精度丢失问题？</a></h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171924882.png" alt="image-20240423171924882"></p>
<h3 id="14-成员变量与局部变量的区别？"><a href="#14-成员变量与局部变量的区别？" class="headerlink" title="14.成员变量与局部变量的区别？"></a>14.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">成员变量与局部变量的区别？</a></h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/member-var-vs-local-var.png" alt="成员变量 vs 局部变量"></p>
<p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
<p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
<p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p>
<p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
<h3 id="15-字符型常量和字符串常量的区别"><a href="#15-字符型常量和字符串常量的区别" class="headerlink" title="15.字符型常量和字符串常量的区别?"></a>15.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">字符型常量和字符串常量的区别?</a></h3><p><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
<p><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p>
<p><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
<p>字符型常量和字符串常量代码示例：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423173544912.png" alt="image-20240423173544912"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423173552505.png" alt="image-20240423173552505"></p>
<h3 id="16-重载和重写有什么区别？"><a href="#16-重载和重写有什么区别？" class="headerlink" title="16. 重载和重写有什么区别？"></a>16. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">重载和重写有什么区别？</a></h3><p><strong>重载</strong>就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p><strong>重写</strong>就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E9%87%8D%E8%BD%BD">重载</a></h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a><a href="#%E9%87%8D%E5%86%99">重写</a></h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201407572.png" alt="image-20240423201407572"></p>
<p><strong>方法的重写要遵循“两同两小一大”</strong></p>
<p>“两同”即方法名相同、形参列表相同；</p>
<p>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</p>
<p>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</p>
<p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h3 id="17-什么是可变长参数？"><a href="#17-什么是可变长参数？" class="headerlink" title="17. 什么是可变长参数？"></a>17. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0">什么是可变长参数？</a></h3><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201852094.png" alt="image-20240423201852094"></p>
<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201911042.png" alt="image-20240423201911042"></p>
<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>我们通过下面这个例子来证明一下。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201942808.png" alt="image-20240423201942808"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201958820.png" alt="image-20240423201958820"></p>
<p>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423202027492.png" alt="image-20240423202027492"></p>
<h3 id="HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？"><a href="#HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？" class="headerlink" title="HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？"></a>HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</h3><h5 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h5><p><strong>数组+链表</strong>：HashMap 内部有一个数组，数组的每个元素是一个链表的头节点。当我们往HashMap中插入一个键值对时，会根据key的hashCode()方法计算出该键值对在数组中的位置，如果该位置上没有元素，就直接放在那里；如果有，则以链表形式存放，即在对应的链表节点上添加一个新节点。</p>
<p><strong>扩容：</strong> 当HashMap中的元素数量达到一定的阈值（容量*加载因子，默认加载因子是0.75），就会进行扩容操作，新的容量是旧容量的两倍，并且重新计算每个键值对的位置。</p>
<p><strong>resize()：</strong> 扩容操作会创建一个新的数组，并将旧数组中的所有元素重新插入到新数组中。</p>
<h5 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a>ConcurrentHashMap 的实现原理</h5><p>ConcurrentHashMap 的实现原理与HashMap类似，但是它是线程安全的，可以在多线程环境下使用。</p>
<p><strong>数组 + 链表 + 红黑树：</strong> ConcurrentHashMap 也是基于数组和链表来实现，但是为了减少哈希碰撞造成的性能影响，当链表的长度超过一定阈值（默认为8）时，链表会被转换为平衡树（红黑树），这样即使在最坏的情况下查找的时间复杂度也可以从<code>O(n)</code>降低到<code>O(log n)</code>。</p>
<p><strong>分段锁：</strong> ConcurrentHashMap 采用分段锁技术来保证线程安全。它将数据分为若干段（Segment），每段独立锁，不同的线程可以并行地访问不同的段。对于大多数操作，只需要锁定一个段即可。这种设计减少了锁竞争，提高了并发性能。</p>
<p><strong>volatile和final：</strong> ConcurrentHashMap 中的变量基本都声明为volatile或final，以保证内存可见性和防止指令重排。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423151525232.png" alt="image-20240423151525232"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" data-id="clvfxxzbo0000tstu7nnxdjhi" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2024/04/26/javaj%E5%9F%BA%E7%A1%80%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>