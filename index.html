<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.425Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>对扩展开放，对修改关闭</p>
<p>使用抽象类进行构建，使用实现扩展细节</p>
<p>面向抽象编程</p>
<p>提高软件系统得可复用性和可维护性</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><h2 id="单一原则"><a href="#单一原则" class="headerlink" title="单一原则"></a>单一原则</h2><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clvfxxzby0007tstufxcsc17z" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java集合使用注意事项总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.395Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java集合使用注意事项总结"><a href="#Java集合使用注意事项总结" class="headerlink" title="Java集合使用注意事项总结"></a><a href="Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93">Java集合使用注意事项总结</a></h1><h3 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h3><p>利用<code>集合.isEmpty()</code>，而不是size()&#x3D;&#x3D;0</p>
<h3 id="集合转map"><a href="#集合转map" class="headerlink" title="集合转map"></a>集合转map</h3><p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p>
<h3 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h3><p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></p>
<h3 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h3><p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeduplicateList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个包含重复元素的ArrayList</span></span><br><span class="line">        List&lt;String&gt; listWithDuplicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        listWithDuplicates.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        listWithDuplicates.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        listWithDuplicates.add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">        listWithDuplicates.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        listWithDuplicates.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将ArrayList转换为HashSet，自动去重</span></span><br><span class="line">        Set&lt;String&gt; setWithNoDuplicates = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(listWithDuplicates);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将去重后的Set转换回ArrayList</span></span><br><span class="line">        List&lt;String&gt; listWithoutDuplicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(setWithNoDuplicates);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;去重后的ArrayList: &quot;</span> + listWithoutDuplicates);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h3><p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数组转集合</p>
<p>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93/" data-id="clvfxxzbu0003tstuhmsjeu1a" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java集合常见面试题总结（下）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.366Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h1><h3 id="1-HashMap-和-Hashtable-的区别"><a href="#1-HashMap-和-Hashtable-的区别" class="headerlink" title="1.HashMap 和 Hashtable 的区别"></a>1.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-02.html#hashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB">HashMap 和 Hashtable 的区别</a></h3><p><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p>
<p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它;</p>
<p><strong>对 Null key 和 Null value 的支持：</strong><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出<code>NullPointerException</code>。</p>
<p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
<p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</p>
<h3 id="2-HashMap-和-HashSet-区别"><a href="#2-HashMap-和-HashSet-区别" class="headerlink" title="2.HashMap 和 HashSet 区别"></a>2.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-02.html#hashmap-%E5%92%8C-hashset-%E5%8C%BA%E5%88%AB">HashMap 和 HashSet 区别</a></h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240425203148835.png" alt="image-20240425203148835"></p>
<h3 id="3-HashMap-和-TreeMap-区别"><a href="#3-HashMap-和-TreeMap-区别" class="headerlink" title="3.HashMap 和 TreeMap 区别"></a>3.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-02.html#hashmap-%E5%92%8C-treemap-%E5%8C%BA%E5%88%AB">HashMap 和 TreeMap 区别</a></h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/treemap_hierarchy.png" alt="TreeMap 继承关系图"></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p><code>NavigableMap</code> 接口提供了丰富的方法来探索和操作键值对:</p>
<ol>
<li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于、小于、大于等于、小于等于给定键的最接近的键值对。</li>
<li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li>
<li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li>
<li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li>
</ol>
<h3 id="4-HashSet-如何检查重复"><a href="#4-HashSet-如何检查重复" class="headerlink" title="4.HashSet 如何检查重复?"></a>4.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-02.html#hashset-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D">HashSet 如何检查重复?</a></h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/" data-id="clvfxxzbw0005tstud20t9xw3" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java集合常见面试题总结（上）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.338Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0">集合概述</a></h1><h3 id="1-Java-集合概览"><a href="#1-Java-集合概览" class="headerlink" title="1. Java 集合概览"></a>1. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#java-%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88">Java 集合概览</a></h3><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>、<code>Map</code>。</p>
<p>Java 集合框架如下图所示：<img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt="Java 集合框架概览"></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
<h3 id="2-说说-List-Set-Queue-Map-四者的区别？"><a href="#2-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="2. 说说 List, Set, Queue, Map 四者的区别？"></a>2. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E8%AF%B4%E8%AF%B4-list-set-queue-map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB">说说 List, Set, Queue, Map 四者的区别？</a></h3><p><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</p>
<p><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。</p>
<p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p>
<p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值</p>
<h3 id="3-集合框架底层数据结构总结"><a href="#3-集合框架底层数据结构总结" class="headerlink" title="3.集合框架底层数据结构总结"></a>3.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">集合框架底层数据结构总结</a></h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a><a href="#list">List</a></h4><ul>
<li><code>ArrayList</code>：<code>Object[]</code> 数组。详细可以查看：<a href="">ArrayList 源码分析</a>。</li>
<li><code>Vector</code>：<code>Object[]</code> 数组。</li>
<li><code>LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：<a href="">LinkedList 源码分析</a>。</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a><a href="#set">Set</a></h4><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)。</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><a href="#queue">Queue</a></h4><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆。详细可以查看：<a href="">PriorityQueue 源码分析</a>。</li>
<li><code>DelayQueue</code>:<code>PriorityQueue</code>。详细可以查看：<a href="">DelayQueue 源码分析</a>。</li>
<li><code>ArrayDeque</code>: 可扩容动态双向数组。</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="#map">Map</a></h4><ul>
<li><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。详细可以查看：<a href="">HashMap 源码分析</a>。</li>
<li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="">LinkedHashMap 源码分析</a></li>
<li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li>
</ul>
<h3 id="4-如何选用集合"><a href="#4-如何选用集合" class="headerlink" title="4. 如何选用集合?"></a>4. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88">如何选用集合?</a></h3><p>当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多</p>
<p>个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。</p>
<p>相较于数组，Java 集合的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>
<h1 id="List-1"><a href="#List-1" class="headerlink" title="List"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#list-1">List</a></h1><h3 id="5-ArrayList-和-Array（数组）的区别？"><a href="#5-ArrayList-和-Array（数组）的区别？" class="headerlink" title="5. ArrayList 和 Array（数组）的区别？"></a>5. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E5%92%8C-array-%E6%95%B0%E7%BB%84-%E7%9A%84%E5%8C%BA%E5%88%AB">ArrayList 和 Array（数组）的区别？</a></h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p>
<ul>
<li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li>
<li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li>
<li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li>
<li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li>
<li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li>
</ul>
<h3 id="6-ArrayList-和-Vector-的区别-（了解即可）"><a href="#6-ArrayList-和-Vector-的区别-（了解即可）" class="headerlink" title="6.ArrayList 和 Vector 的区别?（了解即可）"></a>6.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E5%92%8C-vector-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF">ArrayList 和 Vector 的区别?（了解即可）</a></h3><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</p>
<h3 id="7-Vector-和-Stack-的区别-（了解即可）"><a href="#7-Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="7.Vector 和 Stack 的区别?（了解即可）"></a>7.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#vector-%E5%92%8C-stack-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF">Vector 和 Stack 的区别?（了解即可）</a></h3><ul>
<li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li>
<li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li>
</ul>
<p>随着 Java 并发编程的发展，<code>Vector</code> 和 <code>Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>
<h3 id="8-ArrayList-可以添加-null-值吗？"><a href="#8-ArrayList-可以添加-null-值吗？" class="headerlink" title="8. ArrayList 可以添加 null 值吗？"></a>8. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0-null-%E5%80%BC%E5%90%97">ArrayList 可以添加 null 值吗？</a></h3><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过，不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p>
<h3 id="9-ArrayList-插入和删除元素的时间复杂度？"><a href="#9-ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="9. ArrayList 插入和删除元素的时间复杂度？"></a>9. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">ArrayList 插入和删除元素的时间复杂度？</a></h3><p>对于插入：</p>
<ul>
<li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li>
<li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li>
</ul>
<p>对于删除：</p>
<ul>
<li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li>
<li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
<h3 id="10-LinkedList-插入和删除元素的时间复杂度？"><a href="#10-LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="10. LinkedList 插入和删除元素的时间复杂度？"></a>10. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#linkedlist-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">LinkedList 插入和删除元素的时间复杂度？</a></h3><p>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p>
<p>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p>
<p>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</p>
<h3 id="11-LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#11-LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="11.LinkedList 为什么不能实现 RandomAccess 接口？"></a>11.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#linkedlist-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0-randomaccess-%E6%8E%A5%E5%8F%A3">LinkedList 为什么不能实现 RandomAccess 接口？</a></h3><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p>
<h3 id="12-ArrayList-与-LinkedList-区别"><a href="#12-ArrayList-与-LinkedList-区别" class="headerlink" title="12.ArrayList 与 LinkedList 区别?"></a>12.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-%E4%B8%8E-linkedlist-%E5%8C%BA%E5%88%AB">ArrayList 与 LinkedList 区别?</a></h3><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
<p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li>
</ul>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h3 id="13-ArrayList的扩容机制"><a href="#13-ArrayList的扩容机制" class="headerlink" title="13. ArrayList的扩容机制"></a>13. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/arraylist-source-code.html#arraylist-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">ArrayList的扩容机制</a></h3><h1 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h1><h3 id="14-Comparable-和-Comparator-的区别"><a href="#14-Comparable-和-Comparator-的区别" class="headerlink" title="14. Comparable 和 Comparator 的区别"></a>14. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#comparable-%E5%92%8C-comparator-%E7%9A%84%E5%8C%BA%E5%88%AB">Comparable 和 Comparator 的区别</a></h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul>
<li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 <code>song</code> 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 <code>Comparator</code> 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<h3 id="15-无序性和不可重复性的含义是什么"><a href="#15-无序性和不可重复性的含义是什么" class="headerlink" title="15.无序性和不可重复性的含义是什么"></a>15.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88">无序性和不可重复性的含义是什么</a></h3><p>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</p>
<h3 id="16-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#16-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="16.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>16.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E6%AF%94%E8%BE%83-hashset%E3%80%81linkedhashset-%E5%92%8C-treeset-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</a></h3><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p>
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
<p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
<h1 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h1><h3 id="17-Queue-与-Deque-的区别"><a href="#17-Queue-与-Deque-的区别" class="headerlink" title="17. Queue 与 Deque 的区别"></a>17. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#queue-%E4%B8%8E-deque-%E7%9A%84%E5%8C%BA%E5%88%AB">Queue 与 Deque 的区别</a></h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240425195847907.png" alt="image-20240425195847907"></p>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240425195918896.png" alt="image-20240425195918896"></p>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h3 id="18-ArrayDeque-与-LinkedList-的区别"><a href="#18-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="18.ArrayDeque 与 LinkedList 的区别"></a>18.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#arraydeque-%E4%B8%8E-linkedlist-%E7%9A%84%E5%8C%BA%E5%88%AB">ArrayDeque 与 LinkedList 的区别</a></h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="length属性，length-方法，size-方法"><a href="#length属性，length-方法，size-方法" class="headerlink" title="length属性，length()方法，size()方法"></a>length属性，length()方法，size()方法</h3><ul>
<li>Java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>Java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>Java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" data-id="clvfxxzby0006tstu02ow09vp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础常见面试题总结（中）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.308Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">面向对象和面向过程的区别</a></h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="2-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#2-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="2. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>2. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">创建一个对象用什么运算符?对象实体与对象引用有何不同?</a></h3><p>new 运算符，new 创建对象实例（<strong>对象实例在堆内存中</strong>），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li>
<li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>
</ul>
<h3 id="3-对象的相等和引用相等的区别"><a href="#3-对象的相等和引用相等的区别" class="headerlink" title="3. 对象的相等和引用相等的区别"></a>3. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB">对象的相等和引用相等的区别</a></h3><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203459479.png" alt="image-20240423203459479"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203520925.png" alt="image-20240423203520925"></p>
<h3 id="4-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#4-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="4. 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>4. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97">如果一个类没有声明构造方法，该程序能正确执行吗?</a></h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p>
<h3 id="5-构造方法有哪些特点？是否可被-override"><a href="#5-构造方法有哪些特点？是否可被-override" class="headerlink" title="5. 构造方法有哪些特点？是否可被 override?"></a>5. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9-%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override">构造方法有哪些特点？是否可被 override?</a></h3><p>构造方法特点如下：</p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="6-面向对象三大特征"><a href="#6-面向对象三大特征" class="headerlink" title="6. 面向对象三大特征"></a>6. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81">面向对象三大特征</a></h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%B0%81%E8%A3%85">封装</a></h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E7%BB%A7%E6%89%BF">继承</a></h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><a href="#%E5%A4%9A%E6%80%81">多态</a></h4><p>多态，顾名思义，表示一个对象具有多种的状态，**<code>具体表现为父类的引用指向子类的实例</code>**。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="7-接口和抽象类有什么共同点和区别？"><a href="#7-接口和抽象类有什么共同点和区别？" class="headerlink" title="7.接口和抽象类有什么共同点和区别？"></a>7.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB">接口和抽象类有什么共同点和区别？</a></h3><p><strong>共同点</strong>：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是<code>所属关系</code>。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值.</li>
</ul>
<h3 id="8-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#8-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="8.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>8.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
<li><strong>引用拷贝（Reference Copy）</strong>：<ul>
<li>引用拷贝通常是指浅拷贝中对于引用类型的处理方式。</li>
<li>在浅拷贝中，当我们复制一个包含引用的对象时，我们实际上复制的是引用本身的值，而不是引用指向的对象。</li>
<li>这意味着，如果原始对象和复制对象都引用同一个对象，那么它们实际上共享这个对象的所有权。任何一方对引用的修改都会影响到另一方。</li>
</ul>
</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png"></p>
<h3 id="9-Object-类的常见方法有哪些？"><a href="#9-Object-类的常见方法有哪些？" class="headerlink" title="9.Object 类的常见方法有哪些？"></a>9.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Object 类的常见方法有哪些？</a></h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423215156605.png" alt="image-20240423215156605"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423215234839.png" alt="image-20240423215234839"></p>
<h3 id="10-和-equals-的区别"><a href="#10-和-equals-的区别" class="headerlink" title="10. &#x3D;&#x3D; 和 equals() 的区别"></a>10. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB">&#x3D;&#x3D; 和 equals() 的区别</a></h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p>String类的equals()方法被重写过，用来比较的是对象的值</p>
<h3 id="11-hashCode-有什么用？"><a href="#11-hashCode-有什么用？" class="headerlink" title="11. hashCode() 有什么用？"></a>11. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#hashcode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">hashCode() 有什么用？</a></h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png" alt="hashCode() 方法"></p>
<p>​                                                                hashCode() 方法</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<h3 id="12-为什么要有-hashCode？"><a href="#12-为什么要有-hashCode？" class="headerlink" title="12.为什么要有 hashCode？"></a>12.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashcode">为什么要有 hashCode？</a></h3><p>在Java中，<code>hashCode()</code> 方法的作用是为了支持哈希表的数据结构，特别是当对象用于作为哈希表（例如，Java中的<code>HashMap</code>、<code>HashSet</code>等）的键时。以下是<code>hashCode()</code> 方法的几个关键作用：</p>
<ol>
<li><strong>哈希表的索引</strong>：哈希表是通过哈希函数来索引数据的。对象的<code>hashCode()</code> 方法为对象返回一个整数哈希码，这个哈希码用于计算对象在哈希表中的索引位置。如果两个对象的哈希码相同，它们可能会被存储在哈希表中的同一个位置，这可能导致冲突。</li>
<li><strong>冲突解决</strong>：当两个不同的对象具有相同的哈希码（或者在哈希表中计算出的索引位置相同）时，会发生哈希冲突。在这种情况下，哈希表需要一种方法来区分这些对象。这就是<code>equals()</code> 方法的作用，它用于判断两个对象是否相等。如果两个对象的哈希码不同，它们在哈希表中的位置也必须不同，这样就不会发生冲突。</li>
<li><strong>性能优化</strong>：在哈希表操作中，如添加、删除和查找，使用哈希码可以大大提高性能。不使用哈希码，每次操作都需要对表中所有元素进行线性搜索，这将导致性能急剧下降。</li>
<li><strong>快速比较</strong>：在某些情况下，可以使用哈希码来快速比较对象。例如，当哈希码不相同时，可以立即知道两个对象在哈希表中的位置不同，从而不需要进一步的<code>equals()</code> 比较。</li>
<li><strong>对象的识别</strong>：虽然<code>equals()</code> 方法用于判断对象内容的相等性，但在某些情况下，哈希码也可以用于识别对象。例如，在<code>IdentityHashMap</code>中，就使用了对象的引用而不是哈希码来存储对象。</li>
</ol>
<p>根据Java的规范，如果两个对象通过<code>equals()</code> 方法测试为相等，那么它们必须有相同的哈希码。然而，两个对象即使不相等，也有可能具有相同的哈希码。这就是为什么在处理哈希表时，需要同时考虑<code>hashCode()</code> 和 <code>equals()</code> 方法。</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（**<code>哈希碰撞</code>**）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="13-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#13-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="13. 为什么重写 equals() 时必须重写 hashCode() 方法？"></a>13. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashcode-%E6%96%B9%E6%B3%95">为什么重写 equals() 时必须重写 hashCode() 方法？</a></h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>在重写<code>equals()</code> 方法时，也应该相应地重写<code>hashCode()</code> 方法，以确保哈希表的行为符合预期。如果不重写<code>hashCode()</code>，Java会默认使用对象的内存地址作为哈希码，这在大多数情况下都不是预期的行为。</p>
<h3 id="14-String、StringBuffer、StringBuilder-的区别？"><a href="#14-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="14. String、StringBuffer、StringBuilder 的区别？"></a>14. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string%E3%80%81stringbuffer%E3%80%81stringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB">String、StringBuffer、StringBuilder 的区别？</a></h3><p><strong>可变性</strong></p>
<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
<h3 id="15-String-为什么是不可变的"><a href="#15-String-为什么是不可变的" class="headerlink" title="15. String 为什么是不可变的?"></a>15. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84">String 为什么是不可变的?</a></h3><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</p>
<p>修正：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h3 id="16-字符串拼接用“-”-还是-StringBuilder"><a href="#16-字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="16. 字符串拼接用“+” 还是 StringBuilder?"></a>16. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E8%BF%98%E6%98%AF-stringbuilder">字符串拼接用“+” 还是 StringBuilder?</a></h3><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424091621680.png" alt="image-20240424091621680"></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png" alt="img"></p>
<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。</p>
<h3 id="17-String-equals-和-Object-equals-有何区别？"><a href="#17-String-equals-和-Object-equals-有何区别？" class="headerlink" title="17.String#equals() 和 Object#equals() 有何区别？"></a>17.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-equals-%E5%92%8C-object-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB">String#equals() 和 Object#equals() 有何区别？</a></h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>
<h3 id="18-字符串常量池的作用了解吗？"><a href="#18-字符串常量池的作用了解吗？" class="headerlink" title="18.字符串常量池的作用了解吗？"></a>18.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97">字符串常量池的作用了解吗？</a></h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093100211.png" alt="image-20240424093100211"></p>
<h3 id="19-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#19-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="19.String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>19.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-s1-new-string-abc-%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</a></h3><p>会创建 1 或 2 个字符串对象。</p>
<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093227444.png" alt="image-20240424093227444"></p>
<p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p>
<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093310489.png" alt="image-20240424093310489"></p>
<h3 id="20-String-intern-方法有什么作用"><a href="#20-String-intern-方法有什么作用" class="headerlink" title="20.String#intern 方法有什么作用?"></a>20.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">String#intern 方法有什么作用?</a></h3><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093529761.png" alt="image-20240424093529761"></p>
<h3 id="21-String-类型的变量和常量做“-”运算时发生了什么？"><a href="#21-String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="21.String 类型的变量和常量做“+”运算时发生了什么？"></a>21.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A-%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">String 类型的变量和常量做“+”运算时发生了什么？</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/" data-id="clvfxxzbu0002tstucjkgdf4n" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础常见面试题总结（下）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.302Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><strong>Java 异常类层次结构图概览</strong>：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424151721592.png" alt="image-20240424151721592"></p>
<h3 id="1-Exception-和-Error-有什么区别？"><a href="#1-Exception-和-Error-有什么区别？" class="headerlink" title="1.Exception 和 Error 有什么区别？"></a>1.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#exception-%E5%92%8C-error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Exception 和 Error 有什么区别？</a></h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<p><strong><code>Exception</code></strong> :<strong>程序本身可以处理的异常</strong>，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p>
<p>**<code>Error</code>**：<code>Error</code> <strong>属于程序无法处理的错误</strong> ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
<h3 id="2-Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#2-Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="2. Checked Exception 和 Unchecked Exception 有什么区别？"></a>2. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#checked-exception-%E5%92%8C-unchecked-exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Checked Exception 和 Unchecked Exception 有什么区别？</a></h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p>
<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
</ul>
<h3 id="3-Throwable-类常用方法有哪些？"><a href="#3-Throwable-类常用方法有哪些？" class="headerlink" title="3.Throwable 类常用方法有哪些？"></a>3.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Throwable 类常用方法有哪些？</a></h3><p><code>String getMessage()</code>: 返回异常发生时的简要描述</p>
<p><code>String toString()</code>: 返回异常发生时的详细信息</p>
<p><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</p>
<p><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</p>
<h3 id="4-try-catch-finally-如何使用？"><a href="#4-try-catch-finally-如何使用？" class="headerlink" title="4.try-catch-finally 如何使用？"></a>4.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">try-catch-finally 如何使用？</a></h3><p><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p>
<p><code>catch</code>块：用于处理 try 捕获到的异常。</p>
<p><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424152640780.png" alt="image-20240424152640780"></p>
<p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<h3 id="5-finally-中的代码一定会执行吗？"><a href="#5-finally-中的代码一定会执行吗？" class="headerlink" title="5.finally 中的代码一定会执行吗？"></a>5.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#finally-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97">finally 中的代码一定会执行吗？</a></h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p>
<p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424152848442.png" alt="image-20240424152848442"></p>
<p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p>
<ol>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<h3 id="6-如何使用-try-with-resources-代替try-catch-finally？"><a href="#6-如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="6.如何使用 try-with-resources 代替try-catch-finally？"></a>6.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-try-with-resources-%E4%BB%A3%E6%9B%BFtry-catch-finally">如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</a></h3><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者<code>java.io.Closeable</code> 的对象</p>
<p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。</p>
<p>**面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>**。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
<h3 id="7-异常使用有哪些需要注意的地方？"><a href="#7-异常使用有哪些需要注意的地方？" class="headerlink" title="7.异常使用有哪些需要注意的地方？"></a>7.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9">异常使用有哪些需要注意的地方？</a></h3><ul>
<li><strong>不要把异常定义为静态变量</strong>，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要有意义。</li>
<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>
<li>避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h3 id="8-什么是泛型？有什么作用？"><a href="#8-什么是泛型？有什么作用？" class="headerlink" title="8. 什么是泛型？有什么作用？"></a>8. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">什么是泛型？有什么作用？</a></h3><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>
<h3 id="9-泛型的使用方式有哪几种？"><a href="#9-泛型的使用方式有哪几种？" class="headerlink" title="9. 泛型的使用方式有哪几种？"></a>9. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D">泛型的使用方式有哪几种？</a></h3><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
<p><strong>1.泛型类</strong>：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154532054.png" alt="image-20240424154532054"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154551300.png" alt="image-20240424154551300"></p>
<p><strong>2.泛型接口</strong>：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154629140.png" alt="image-20240424154629140"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154653779.png" alt="image-20240424154653779"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154716668.png" alt="image-20240424154716668"></p>
<p><strong>3.泛型方法</strong></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154819692.png" alt="image-20240424154819692"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424154844326.png" alt="image-20240424154844326"></p>
<p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，<strong>所以静态泛型方法是没有办法使用类上声明的泛型的</strong>。只能使用自己声明的 <code>&lt;E&gt;</code>.</p>
<h3 id="10-项目中哪里用到了泛型？"><a href="#10-项目中哪里用到了泛型？" class="headerlink" title="10.项目中哪里用到了泛型？"></a>10.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E6%B3%9B%E5%9E%8B">项目中哪里用到了泛型？</a></h3><p>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</p>
<p>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</p>
<p>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h3 id="11-何谓反射？"><a href="#11-何谓反射？" class="headerlink" title="11.何谓反射？"></a>11.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E4%BD%95%E8%B0%93%E5%8F%8D%E5%B0%84">何谓反射？</a></h3><p><strong>反射机制允许程序在运行时查询类、接口、字段和方法的信息，并且能够动态地创建和操作对象。</strong></p>
<p>以下是 Java 反射机制的一些关键点：</p>
<ol>
<li><strong>动态加载类</strong>：反射可以在运行时动态地加载类，而不必在使用类之前显式地加载它。</li>
<li><strong>访问私有成员</strong>：反射可以访问一个类的所有成员，包括私有字段和方法，这在正常情况下是无法做到的。</li>
<li><strong>修改字段值</strong>：反射机制可以用来读取和修改私有字段的值，这对于框架和库开发者来说非常有用，可以实现通用代码来处理不同类的数据。</li>
<li><strong>调用方法</strong>：反射机制可以让开发者调用任何对象的方法，即使这些方法在编译时是私有的。</li>
<li><strong>生成对象</strong>：反射还可以用于动态地生成对象，这在诸如框架和脚本语言中非常常见。</li>
<li><strong>注解处理</strong>：反射与注解（Annotations）结合使用，可以方便地处理注解信息，如自动装配、日志记录和代码生成等。</li>
<li><strong>动态代理</strong>：反射还可以用来创建动态代理，这是 Java 代理模式的基础，用于在不修改原始类代码的情况下，添加额外的功能。</li>
</ol>
<h3 id="12-反射的优缺点？"><a href="#12-反射的优缺点？" class="headerlink" title="12.反射的优缺点？"></a>12.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">反射的优缺点？</a></h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<h3 id="13-反射的应用场景？"><a href="#13-反射的应用场景？" class="headerlink" title="13.反射的应用场景？"></a>13.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">反射的应用场景？</a></h3><p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424155858229.png" alt="image-20240424155858229"></p>
<p>外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h3 id="14-何谓注解？"><a href="#14-何谓注解？" class="headerlink" title="14.何谓注解？"></a>14.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E4%BD%95%E8%B0%93%E6%B3%A8%E8%A7%A3">何谓注解？</a></h3><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424160103501.png" alt="image-20240424160103501"></p>
<p>JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
<h3 id="15-注解的解析方法有哪几种？"><a href="#15-注解的解析方法有哪几种？" class="headerlink" title="15.注解的解析方法有哪几种？"></a>15.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D">注解的解析方法有哪几种？</a></h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/" data-id="clvfxxzbs0001tstudir98nng" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础常见面试题总结（上）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.199Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-Java-SE-vs-Java-EE"><a href="#1-Java-SE-vs-Java-EE" class="headerlink" title="1. Java SE vs Java EE"></a>1. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#java-se-vs-java-ee">Java SE vs Java EE</a></h3><ul>
<li>Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。</li>
<li>Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。</li>
</ul>
<h3 id="2-JVM-vs-JDK-vs-JRE"><a href="#2-JVM-vs-JDK-vs-JRE" class="headerlink" title="2.JVM vs JDK vs JRE"></a>2.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm-vs-jdk-vs-jre">JVM vs JDK vs JRE</a></h3><h5 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm">JVM</a></h5><p>Java 虚拟机（Java Virtual Machine）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png" alt="运行在 Java 虚拟机之上的编程语言"><br>JVM不是只有一种</p>
<h5 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jdk-%E5%92%8C-jre">JDK 和 JRE</a></h5><p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p>
<p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-include-jre.png" alt="JDK 包含 JRE"></p>
<h3 id="3-什么是字节码-采用字节码的好处是什么"><a href="#3-什么是字节码-采用字节码的好处是什么" class="headerlink" title="3. 什么是字节码?采用字节码的好处是什么?"></a>3. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">什么是字节码?采用字节码的好处是什么?</a></h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><strong>Java程序从源代码到运行的过程如下图所示</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160348016.png" alt="image-20240423160348016"></p>
<p><strong>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png" alt="JDK、JRE、JVM、JIT 这四者的关系"></p>
<h3 id="4-为什么说-Java-语言“编译与解释并存”？"><a href="#4-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="4.为什么说 Java 语言“编译与解释并存”？"></a>4.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-java-%E8%AF%AD%E8%A8%80-%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98">为什么说 Java 语言“编译与解释并存”？</a></h3><p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><strong>编译型</strong>：编译型语言会通过[编译器]将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型</strong>：[解释型语言]会通过[解释器]一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160648790.png" alt="image-20240423160648790"></p>
<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>
<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="5-AOT-有什么优点？为什么不全部使用-AOT-呢？"><a href="#5-AOT-有什么优点？为什么不全部使用-AOT-呢？" class="headerlink" title="5. AOT 有什么优点？为什么不全部使用 AOT 呢？"></a>5. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#aot-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8-aot-%E5%91%A2">AOT 有什么优点？为什么不全部使用 AOT 呢？</a></h3><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423160325214.png" alt="image-20240423160325214"><br>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>
<p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p>
<p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>
<h3 id="6-Java-和-C-的区别"><a href="#6-Java-和-C-的区别" class="headerlink" title="6.  Java 和 C++ 的区别?"></a>6.  <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#java-%E5%92%8C-c-%E7%9A%84%E5%8C%BA%E5%88%AB">Java 和 C++ 的区别?</a></h3><p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p>
<ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
</ul>
<h3 id="7-continue、break-和-return-的区别是什么？"><a href="#7-continue、break-和-return-的区别是什么？" class="headerlink" title="7.continue、break 和 return 的区别是什么？"></a>7.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#continue%E3%80%81break-%E5%92%8C-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">continue、break 和 return 的区别是什么？</a></h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li>
</ol>
<p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<h3 id="8-Java-中的几种基本数据类型了解么？"><a href="#8-Java-中的几种基本数据类型了解么？" class="headerlink" title="8.Java 中的几种基本数据类型了解么？"></a>8.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88">Java 中的几种基本数据类型了解么？</a></h3><p>8中基本类型：byte,short,int,long,char,float,double,boolean</p>
<p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型： <ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ul>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423170037053.png" alt="image-20240423170037053"></p>
<h3 id="9-基本类型和包装类型的区别？"><a href="#9-基本类型和包装类型的区别？" class="headerlink" title="9. 基本类型和包装类型的区别？"></a>9. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB">基本类型和包装类型的区别？</a></h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p>
<p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</p>
<p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p>
<p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p>
<p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p>
<p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p>
<p><strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p>
<h3 id="10-包装类型的缓存机制了解么？"><a href="#10-包装类型的缓存机制了解么？" class="headerlink" title="10. 包装类型的缓存机制了解么？"></a>10. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88">包装类型的缓存机制了解么？</a></h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171140098.png" alt="image-20240423171140098"></p>
<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/up-1ae0425ce8646adfb768b5374951eeb820d.png" alt="img"></p>
<h3 id="11-自动装箱与拆箱了解吗？原理是什么？"><a href="#11-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="11. 自动装箱与拆箱了解吗？原理是什么？"></a>11. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%BA%86%E8%A7%A3%E5%90%97-%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">自动装箱与拆箱了解吗？原理是什么？</a></h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>原理：我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h3 id="12-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#12-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="12. 为什么浮点数运算的时候会有精度丢失的风险？"></a>12. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A3%8E%E9%99%A9">为什么浮点数运算的时候会有精度丢失的风险？</a></h3><p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171825236.png" alt="image-20240423171825236"></p>
<p>为什么会出现这个问题呢？</p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<h3 id="13-如何解决浮点数运算的精度丢失问题？"><a href="#13-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="13.如何解决浮点数运算的精度丢失问题？"></a>13.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98">如何解决浮点数运算的精度丢失问题？</a></h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423171924882.png" alt="image-20240423171924882"></p>
<h3 id="14-成员变量与局部变量的区别？"><a href="#14-成员变量与局部变量的区别？" class="headerlink" title="14.成员变量与局部变量的区别？"></a>14.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">成员变量与局部变量的区别？</a></h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/member-var-vs-local-var.png" alt="成员变量 vs 局部变量"></p>
<p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
<p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
<p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p>
<p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
<h3 id="15-字符型常量和字符串常量的区别"><a href="#15-字符型常量和字符串常量的区别" class="headerlink" title="15.字符型常量和字符串常量的区别?"></a>15.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">字符型常量和字符串常量的区别?</a></h3><p><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
<p><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p>
<p><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
<p>字符型常量和字符串常量代码示例：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423173544912.png" alt="image-20240423173544912"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423173552505.png" alt="image-20240423173552505"></p>
<h3 id="16-重载和重写有什么区别？"><a href="#16-重载和重写有什么区别？" class="headerlink" title="16. 重载和重写有什么区别？"></a>16. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">重载和重写有什么区别？</a></h3><p><strong>重载</strong>就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p><strong>重写</strong>就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E9%87%8D%E8%BD%BD">重载</a></h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a><a href="#%E9%87%8D%E5%86%99">重写</a></h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201407572.png" alt="image-20240423201407572"></p>
<p><strong>方法的重写要遵循“两同两小一大”</strong></p>
<p>“两同”即方法名相同、形参列表相同；</p>
<p>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</p>
<p>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</p>
<p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h3 id="17-什么是可变长参数？"><a href="#17-什么是可变长参数？" class="headerlink" title="17. 什么是可变长参数？"></a>17. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0">什么是可变长参数？</a></h3><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201852094.png" alt="image-20240423201852094"></p>
<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201911042.png" alt="image-20240423201911042"></p>
<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>我们通过下面这个例子来证明一下。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201942808.png" alt="image-20240423201942808"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423201958820.png" alt="image-20240423201958820"></p>
<p>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423202027492.png" alt="image-20240423202027492"></p>
<h3 id="HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？"><a href="#HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？" class="headerlink" title="HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？"></a>HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</h3><h5 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h5><p><strong>数组+链表</strong>：HashMap 内部有一个数组，数组的每个元素是一个链表的头节点。当我们往HashMap中插入一个键值对时，会根据key的hashCode()方法计算出该键值对在数组中的位置，如果该位置上没有元素，就直接放在那里；如果有，则以链表形式存放，即在对应的链表节点上添加一个新节点。</p>
<p><strong>扩容：</strong> 当HashMap中的元素数量达到一定的阈值（容量*加载因子，默认加载因子是0.75），就会进行扩容操作，新的容量是旧容量的两倍，并且重新计算每个键值对的位置。</p>
<p><strong>resize()：</strong> 扩容操作会创建一个新的数组，并将旧数组中的所有元素重新插入到新数组中。</p>
<h5 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a>ConcurrentHashMap 的实现原理</h5><p>ConcurrentHashMap 的实现原理与HashMap类似，但是它是线程安全的，可以在多线程环境下使用。</p>
<p><strong>数组 + 链表 + 红黑树：</strong> ConcurrentHashMap 也是基于数组和链表来实现，但是为了减少哈希碰撞造成的性能影响，当链表的长度超过一定阈值（默认为8）时，链表会被转换为平衡树（红黑树），这样即使在最坏的情况下查找的时间复杂度也可以从<code>O(n)</code>降低到<code>O(log n)</code>。</p>
<p><strong>分段锁：</strong> ConcurrentHashMap 采用分段锁技术来保证线程安全。它将数据分为若干段（Segment），每段独立锁，不同的线程可以并行地访问不同的段。对于大多数操作，只需要锁定一个段即可。这种设计减少了锁竞争，提高了并发性能。</p>
<p><strong>volatile和final：</strong> ConcurrentHashMap 中的变量基本都声明为volatile或final，以保证内存可见性和防止指令重排。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423151525232.png" alt="image-20240423151525232"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" data-id="clvfxxzbo0000tstu7nnxdjhi" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javaj基础重要知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/javaj%E5%9F%BA%E7%A1%80%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:27:08.198Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1·Java-值传递详解"><a href="#1·Java-值传递详解" class="headerlink" title="1·Java 值传递详解"></a>1·<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/why-there-only-value-passing-in-java.html">Java 值传递详解</a></h3><h3 id="2-Java-序列化详解"><a href="#2-Java-序列化详解" class="headerlink" title="2.Java 序列化详解"></a>2.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/serialization.html">Java 序列化详解</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/javaj%E5%9F%BA%E7%A1%80%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="clvfxxzbz0008tstu0bi3bn7x" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/26/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-04-26T00:14:16.607Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/26/hello-world/" data-id="clvfxxzbv0004tstu6w9w6qk2" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>