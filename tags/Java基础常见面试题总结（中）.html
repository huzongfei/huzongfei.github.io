<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"huzongfei.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 面向对象和面向过程的区别两者的主要区别在于解决问题的方式不同：  面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。  另外，面向对象开发的程序一般更易维护、易复用、易扩展。 2. 创建一个对象用什么运算符?对象实体与对象引用有何不同?new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实">
<meta property="og:type" content="website">
<meta property="og:title" content="Java面试总结">
<meta property="og:url" content="https://huzongfei.github.io/tags/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89.html">
<meta property="og:site_name" content="Java面试总结">
<meta property="og:description" content="1. 面向对象和面向过程的区别两者的主要区别在于解决问题的方式不同：  面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。  另外，面向对象开发的程序一般更易维护、易复用、易扩展。 2. 创建一个对象用什么运算符?对象实体与对象引用有何不同?new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203459479.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203520925.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423215156605.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423215234839.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424091621680.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093100211.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093227444.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093310489.png">
<meta property="og:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093529761.png">
<meta property="article:published_time" content="2024-04-24T01:36:45.702Z">
<meta property="article:modified_time" content="2024-04-24T01:36:45.702Z">
<meta property="article:author" content="hzf">
<meta property="article:tag" content="java基础，java集合，设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203459479.png">


<link rel="canonical" href="https://huzongfei.github.io/tags/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://huzongfei.github.io/tags/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89.html","path":"tags/Java基础常见面试题总结（中）.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Java面试总结
</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Java面试总结</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">奔赴山海, 保持热爱</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">1. 面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="nav-number">2.</span> <span class="nav-text">2. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">3. 对象的相等和引用相等的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97"><span class="nav-number">4.</span> <span class="nav-text">4. 如果一个类没有声明构造方法，该程序能正确执行吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override"><span class="nav-number">5.</span> <span class="nav-text">5. 构造方法有哪些特点？是否可被 override?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">6.</span> <span class="nav-text">6. 面向对象三大特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">6.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">6.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">6.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">7.接口和抽象类有什么共同点和区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">8.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">9.Object 类的常见方法有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">10. &#x3D;&#x3D; 和 equals() 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-hashCode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">11. hashCode() 有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashCode%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">12.为什么要有 hashCode？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">13. 为什么重写 equals() 时必须重写 hashCode() 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-String%E3%80%81StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">14. String、StringBuffer、StringBuilder 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">15.</span> <span class="nav-text">15. String 为什么是不可变的?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8%E2%80%9C-%E2%80%9D-%E8%BF%98%E6%98%AF-StringBuilder"><span class="nav-number">16.</span> <span class="nav-text">16. 字符串拼接用“+” 还是 StringBuilder?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-String-equals-%E5%92%8C-Object-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">17.String#equals() 和 Object#equals() 有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">18.字符串常量池的作用了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-String-s1-new-String-%E2%80%9Cabc%E2%80%9D-%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">19.String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-String-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">20.</span> <span class="nav-text">20.String#intern 方法有什么作用?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-String-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A%E2%80%9C-%E2%80%9D%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">21.String 类型的变量和常量做“+”运算时发生了什么？</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hzf</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta-container">
</div>

</header>

      
      
      
      <div class="post-body">
          <h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">面向对象和面向过程的区别</a></h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="2-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#2-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="2. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>2. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">创建一个对象用什么运算符?对象实体与对象引用有何不同?</a></h3><p>new 运算符，new 创建对象实例（<strong>对象实例在堆内存中</strong>），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li>
<li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>
</ul>
<h3 id="3-对象的相等和引用相等的区别"><a href="#3-对象的相等和引用相等的区别" class="headerlink" title="3. 对象的相等和引用相等的区别"></a>3. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB">对象的相等和引用相等的区别</a></h3><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203459479.png" alt="image-20240423203459479"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423203520925.png" alt="image-20240423203520925"></p>
<h3 id="4-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#4-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="4. 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>4. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97">如果一个类没有声明构造方法，该程序能正确执行吗?</a></h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p>
<h3 id="5-构造方法有哪些特点？是否可被-override"><a href="#5-构造方法有哪些特点？是否可被-override" class="headerlink" title="5. 构造方法有哪些特点？是否可被 override?"></a>5. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9-%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override">构造方法有哪些特点？是否可被 override?</a></h3><p>构造方法特点如下：</p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="6-面向对象三大特征"><a href="#6-面向对象三大特征" class="headerlink" title="6. 面向对象三大特征"></a>6. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81">面向对象三大特征</a></h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%B0%81%E8%A3%85">封装</a></h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E7%BB%A7%E6%89%BF">继承</a></h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><a href="#%E5%A4%9A%E6%80%81">多态</a></h4><p>多态，顾名思义，表示一个对象具有多种的状态，**<code>具体表现为父类的引用指向子类的实例</code>**。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="7-接口和抽象类有什么共同点和区别？"><a href="#7-接口和抽象类有什么共同点和区别？" class="headerlink" title="7.接口和抽象类有什么共同点和区别？"></a>7.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB">接口和抽象类有什么共同点和区别？</a></h3><p><strong>共同点</strong>：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是<code>所属关系</code>。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值.</li>
</ul>
<h3 id="8-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#8-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="8.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>8.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
<li><strong>引用拷贝（Reference Copy）</strong>：<ul>
<li>引用拷贝通常是指浅拷贝中对于引用类型的处理方式。</li>
<li>在浅拷贝中，当我们复制一个包含引用的对象时，我们实际上复制的是引用本身的值，而不是引用指向的对象。</li>
<li>这意味着，如果原始对象和复制对象都引用同一个对象，那么它们实际上共享这个对象的所有权。任何一方对引用的修改都会影响到另一方。</li>
</ul>
</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png"></p>
<h3 id="9-Object-类的常见方法有哪些？"><a href="#9-Object-类的常见方法有哪些？" class="headerlink" title="9.Object 类的常见方法有哪些？"></a>9.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Object 类的常见方法有哪些？</a></h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423215156605.png" alt="image-20240423215156605"></p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240423215234839.png" alt="image-20240423215234839"></p>
<h3 id="10-和-equals-的区别"><a href="#10-和-equals-的区别" class="headerlink" title="10. &#x3D;&#x3D; 和 equals() 的区别"></a>10. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB">&#x3D;&#x3D; 和 equals() 的区别</a></h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p>String类的equals()方法被重写过，用来比较的是对象的值</p>
<h3 id="11-hashCode-有什么用？"><a href="#11-hashCode-有什么用？" class="headerlink" title="11. hashCode() 有什么用？"></a>11. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#hashcode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">hashCode() 有什么用？</a></h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png" alt="hashCode() 方法"></p>
<p>​                                                                hashCode() 方法</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<h3 id="12-为什么要有-hashCode？"><a href="#12-为什么要有-hashCode？" class="headerlink" title="12.为什么要有 hashCode？"></a>12.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashcode">为什么要有 hashCode？</a></h3><p>在Java中，<code>hashCode()</code> 方法的作用是为了支持哈希表的数据结构，特别是当对象用于作为哈希表（例如，Java中的<code>HashMap</code>、<code>HashSet</code>等）的键时。以下是<code>hashCode()</code> 方法的几个关键作用：</p>
<ol>
<li><strong>哈希表的索引</strong>：哈希表是通过哈希函数来索引数据的。对象的<code>hashCode()</code> 方法为对象返回一个整数哈希码，这个哈希码用于计算对象在哈希表中的索引位置。如果两个对象的哈希码相同，它们可能会被存储在哈希表中的同一个位置，这可能导致冲突。</li>
<li><strong>冲突解决</strong>：当两个不同的对象具有相同的哈希码（或者在哈希表中计算出的索引位置相同）时，会发生哈希冲突。在这种情况下，哈希表需要一种方法来区分这些对象。这就是<code>equals()</code> 方法的作用，它用于判断两个对象是否相等。如果两个对象的哈希码不同，它们在哈希表中的位置也必须不同，这样就不会发生冲突。</li>
<li><strong>性能优化</strong>：在哈希表操作中，如添加、删除和查找，使用哈希码可以大大提高性能。不使用哈希码，每次操作都需要对表中所有元素进行线性搜索，这将导致性能急剧下降。</li>
<li><strong>快速比较</strong>：在某些情况下，可以使用哈希码来快速比较对象。例如，当哈希码不相同时，可以立即知道两个对象在哈希表中的位置不同，从而不需要进一步的<code>equals()</code> 比较。</li>
<li><strong>对象的识别</strong>：虽然<code>equals()</code> 方法用于判断对象内容的相等性，但在某些情况下，哈希码也可以用于识别对象。例如，在<code>IdentityHashMap</code>中，就使用了对象的引用而不是哈希码来存储对象。</li>
</ol>
<p>根据Java的规范，如果两个对象通过<code>equals()</code> 方法测试为相等，那么它们必须有相同的哈希码。然而，两个对象即使不相等，也有可能具有相同的哈希码。这就是为什么在处理哈希表时，需要同时考虑<code>hashCode()</code> 和 <code>equals()</code> 方法。</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（**<code>哈希碰撞</code>**）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="13-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#13-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="13. 为什么重写 equals() 时必须重写 hashCode() 方法？"></a>13. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashcode-%E6%96%B9%E6%B3%95">为什么重写 equals() 时必须重写 hashCode() 方法？</a></h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>在重写<code>equals()</code> 方法时，也应该相应地重写<code>hashCode()</code> 方法，以确保哈希表的行为符合预期。如果不重写<code>hashCode()</code>，Java会默认使用对象的内存地址作为哈希码，这在大多数情况下都不是预期的行为。</p>
<h3 id="14-String、StringBuffer、StringBuilder-的区别？"><a href="#14-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="14. String、StringBuffer、StringBuilder 的区别？"></a>14. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string%E3%80%81stringbuffer%E3%80%81stringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB">String、StringBuffer、StringBuilder 的区别？</a></h3><p><strong>可变性</strong></p>
<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
<h3 id="15-String-为什么是不可变的"><a href="#15-String-为什么是不可变的" class="headerlink" title="15. String 为什么是不可变的?"></a>15. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84">String 为什么是不可变的?</a></h3><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</p>
<p>修正：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h3 id="16-字符串拼接用“-”-还是-StringBuilder"><a href="#16-字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="16. 字符串拼接用“+” 还是 StringBuilder?"></a>16. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E8%BF%98%E6%98%AF-stringbuilder">字符串拼接用“+” 还是 StringBuilder?</a></h3><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424091621680.png" alt="image-20240424091621680"></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png" alt="img"></p>
<p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。</p>
<h3 id="17-String-equals-和-Object-equals-有何区别？"><a href="#17-String-equals-和-Object-equals-有何区别？" class="headerlink" title="17.String#equals() 和 Object#equals() 有何区别？"></a>17.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-equals-%E5%92%8C-object-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB">String#equals() 和 Object#equals() 有何区别？</a></h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>
<h3 id="18-字符串常量池的作用了解吗？"><a href="#18-字符串常量池的作用了解吗？" class="headerlink" title="18.字符串常量池的作用了解吗？"></a>18.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97">字符串常量池的作用了解吗？</a></h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093100211.png" alt="image-20240424093100211"></p>
<h3 id="19-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#19-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="19.String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>19.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-s1-new-string-abc-%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</a></h3><p>会创建 1 或 2 个字符串对象。</p>
<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093227444.png" alt="image-20240424093227444"></p>
<p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p>
<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093310489.png" alt="image-20240424093310489"></p>
<h3 id="20-String-intern-方法有什么作用"><a href="#20-String-intern-方法有什么作用" class="headerlink" title="20.String#intern 方法有什么作用?"></a>20.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">String#intern 方法有什么作用?</a></h3><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<p><img src="C:\Users\huzongfei\AppData\Roaming\Typora\typora-user-images\image-20240424093529761.png" alt="image-20240424093529761"></p>
<h3 id="21-String-类型的变量和常量做“-”运算时发生了什么？"><a href="#21-String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="21.String 类型的变量和常量做“+”运算时发生了什么？"></a>21.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A-%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">String 类型的变量和常量做“+”运算时发生了什么？</a></h3>
      </div>
      
      
      
    </div>

    
    


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">hzf</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
